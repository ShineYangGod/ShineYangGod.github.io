{"posts":[{"title":"使用editor.md作为后台富文本编辑器以及前台Markdown文档展示","content":"整个流程 首先需要在后台管理页插入富文本编辑器 然后拿到编辑好的html代码并把它存入数据库，为了在前台展示时加载页面。同时还应拿到对应md源代码（也存入数据库），为了让文章在必要的时候可以重新编辑修改。 前端拿到html代码后，引入editor.md相应的css和js文件，对页面进行正确的加载。 1.下载安装 在github上把项目clone下来传送门 或者在官网上直接下载安装传送门 2.基本研究思路 不感兴趣的可以直接跳到实战部分 a.打开项目文件件下面的examples文件夹中的full.html或者use-zepto文件，可以看到需要引入的css和js文件如下： &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/editormd.css&quot; /&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../editormd.js&quot;&gt;&lt;/script&gt; editor.md的基本配置项以及可以使用的函数： &lt;script type=&quot;text/javascript&quot;&gt; var testEditor; $(function() { $.get('test.md', function(md){ testEditor = editormd(&quot;test-editormd&quot;, { width: &quot;90%&quot;, height: 740, path : '../lib/', theme : &quot;dark&quot;, previewTheme : &quot;dark&quot;, editorTheme : &quot;pastel-on-dark&quot;, markdown : md, codeFold : true, //syncScrolling : false, saveHTMLToTextarea : true, // 保存 HTML 到 Textarea searchReplace : true, //watch : false, // 关闭实时预览 htmlDecode : &quot;style,script,iframe|on*&quot;, // 开启 HTML 标签解析，为了安全性，默认不开启 //toolbar : false, //关闭工具栏 //previewCodeHighlight : false, // 关闭预览 HTML 的代码块高亮，默认开启 emoji : true, taskList : true, tocm : true, // Using [TOCM] tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //dialogLockScreen : false, // 设置弹出层对话框不锁屏，全局通用，默认为true //dialogShowMask : false, // 设置弹出层对话框显示透明遮罩层，全局通用，默认为true //dialogDraggable : false, // 设置弹出层对话框不可拖动，全局通用，默认为true //dialogMaskOpacity : 0.4, // 设置透明遮罩层的透明度，全局通用，默认值为0.1 //dialogMaskBgColor : &quot;#000&quot;, // 设置透明遮罩层的背景颜色，全局通用，默认为#fff imageUpload : true, imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], imageUploadURL : &quot;./php/upload.php&quot;, onload : function() { console.log('onload', this); //this.fullscreen(); //this.unwatch(); //this.watch().fullscreen(); //this.setMarkdown(&quot;#PHP&quot;); //this.width(&quot;100%&quot;); //this.height(480); //this.resize(&quot;100%&quot;, 640); } }); }); $(&quot;#goto-line-btn&quot;).bind(&quot;click&quot;, function(){ testEditor.gotoLine(90); }); $(&quot;#show-btn&quot;).bind('click', function(){ testEditor.show(); }); $(&quot;#hide-btn&quot;).bind('click', function(){ testEditor.hide(); }); $(&quot;#get-md-btn&quot;).bind('click', function(){ alert(testEditor.getMarkdown()); }); $(&quot;#get-html-btn&quot;).bind('click', function() { alert(testEditor.getHTML()); }); $(&quot;#watch-btn&quot;).bind('click', function() { testEditor.watch(); }); $(&quot;#unwatch-btn&quot;).bind('click', function() { testEditor.unwatch(); }); $(&quot;#preview-btn&quot;).bind('click', function() { testEditor.previewing(); }); $(&quot;#fullscreen-btn&quot;).bind('click', function() { testEditor.fullscreen(); }); $(&quot;#show-toolbar-btn&quot;).bind('click', function() { testEditor.showToolbar(); }); $(&quot;#close-toolbar-btn&quot;).bind('click', function() { testEditor.hideToolbar(); }); $(&quot;#toc-menu-btn&quot;).click(function(){ testEditor.config({ tocDropdown : true, tocTitle : &quot;目录 Table of Contents&quot;, }); }); $(&quot;#toc-default-btn&quot;).click(function() { testEditor.config(&quot;tocDropdown&quot;, false); }); }); &lt;/script&gt; 对于配置项只说明一点，就是主题theme的设置: 打开同一目录下的theme.html（用浏览器打开），这时候你可以看到不同主题的呈现效果，选定你想要的主题，对配置项进行相应的修改。 例如我修改的配置项如下： theme : &quot;default&quot;, previewTheme : &quot;default&quot;, editorTheme : &quot;base16-light&quot;, 对于函数，只有两个函数与我们的需求相关，那就是getHtml()还有getMarkDown()函数，这两个函数是否符合我们的需求的。 3.开始实战 清空example文件夹下的所有html文件,并建立两个html文件，admin.html是后台管理页，user.html用于前台展示页 两个文件分别引入相关的css和js文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/editormd.css&quot; /&gt; &lt;script src=&quot;js/zepto.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../editormd.js&quot;&gt;&lt;/script&gt; admin.html &lt;div id=&quot;layout&quot;&gt; &lt;div class=&quot;editormd&quot; id=&quot;test-editormd&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;br/&gt;&lt;input id=&quot;submit&quot; type=&quot;button&quot; name=&quot;submit&quot; value=&quot;Submit&quot; class=&quot;btn&quot; style=&quot;margin-left: 5%;&quot; /&gt; &lt;button id=&quot;preview-btn&quot;&gt;Preview HTML (Press Shift + ESC cancel)&lt;/button&gt; &lt;/div&gt; js部分新建一个editormd对象： testEditor = editormd(); submit函数用于获取html代码和markdown源代码： document.getElementById(&quot;submit&quot;).onclick = function(){ let htmlCode = document.getElementsByClassName(&quot;editormd-preview-container&quot;)[0].innerHTML; let mdCode = testEditor.getMarkdown(); console.log(htmlCode); } 模拟用户从数据库拿到md源代码，可以修改文章: document.getElementsByTagName('textarea')[0].innerHTML = &quot;##HELLO keke&quot;; user.html &lt;div class=&quot;markdown-body editormd-preview-container&quot;&gt;&lt;/div&gt; 模拟从后台获取数据 编辑后台管理（admin.html)md编辑器，按submit按钮，把控制台打印出来的代码贴到（user.html)markdowm-body标签里面： &lt;div class=&quot;markdown-body editormd-preview-container&quot;&gt; &lt;h2 id=&quot;h2-kek&quot;&gt;&lt;a name=&quot;kek&quot; class=&quot;reference-link&quot;&gt;&lt;/a&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;&gt;&lt;/span&gt;kek&lt;/h2&gt;&lt;p&gt;Wad&lt;/p&gt; &lt;div class=&quot;markdown-toc editormd-markdown-toc&quot;&gt;&lt;ul class=&quot;markdown-toc-list&quot;&gt;&lt;li&gt;&lt;a class=&quot;toc-level-2&quot; href=&quot;#kek&quot; level=&quot;2&quot;&gt;kek&lt;/a&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;pre class=&quot;prettyprint linenums prettyprinted&quot;&gt;&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; i &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt; &lt;/div&gt; 注意：关键点就在于获取容器editormd-preview-container里面的html代码了 ","link":"https://shineyangpro.com/shi-yong-editormd-zuo-wei-hou-tai-fu-wen-ben-bian-ji-qi-yi-ji-qian-tai-markdown-wen-dang-zhan-shi/"},{"title":"JQuery 如何ul动态添加li标签","content":"首先在html页面中找到相应的ul标签对。 如下图： &lt;ul id=&quot;ulPlayPist&quot;&gt; &lt;li class=&quot;li_style&quot;&gt; &lt;div id=&quot;divItem1&quot; class=&quot;div_item_v_style&quot;&gt; &lt;img id=&quot;img_item_1&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt; &lt;input id=&quot;listItem_1&quot; type=&quot;button&quot; value=&quot;暂无&quot; class=&quot;btn_list_item_v_style&quot; onclick=&quot;Item_Click(1);&quot;/&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; 上面是一个html文件内ul标签的一个范例，并且li标签内含有div 等子标签。这个就不多说了，如果不懂建议先学习一下html基础。 二、需要在js函数内找到ul标签控件。 要获取ul对象可以通过id来进行查找。不过jQuery提供了一些简单的方法。 如下图： //通过id=lPlayPist查找ul标签控件 $('#ulPlayPist').append(&quot;&quot;); 上面代码已经包含查找一阶添加。 三、动态添加。 组织需要添加标签String。如下 var li_str = '&lt;li class=&quot;li_style&quot;&gt;'; li_str += '&lt;div id=&quot;divItem'+(i+1).toString()+'&quot; class=&quot;div_item_v_style&quot;&gt;'; li_str += '&lt;img id=&quot;img_item_' + (i + 1).toString() + '&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt;'; li_str += '&lt;input id=&quot;listItem_' + (i + 1).toString() + '&quot; type=&quot;button&quot; value=&quot;' + dict_data[&quot;List&quot;][i] + '&quot; class=&quot;btn_list_item_v_style&quot; οnclick=&quot;Item_Click(' + (i + 1).toString() + ');&quot;/&gt;'; li_str += '&lt;/div&gt;&lt;/li&gt;'; 然后通过append这个语句，添加进去。 //添加数据到UL function AddListToUl(dict_data) { var list_count = parseInt(dict_data[&quot;Count&quot;]); $(&quot;#ulPlayPist&quot;).find(&quot;li&quot;).remove(); for (var i = 0; i &lt; list_count; i++) { var li_str = '&lt;li class=&quot;li_style&quot;&gt;'; li_str += '&lt;div id=&quot;divItem'+(i+1).toString()+'&quot; class=&quot;div_item_v_style&quot;&gt;'; li_str += '&lt;img id=&quot;img_item_' + (i + 1).toString() + '&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt;'; li_str += '&lt;input id=&quot;listItem_' + (i + 1).toString() + '&quot; type=&quot;button&quot; value=&quot;' + dict_data[&quot;List&quot;][i] + '&quot; class=&quot;btn_list_item_v_style&quot; οnclick=&quot;Item_Click(' + (i + 1).toString() + ');&quot;/&gt;'; li_str += '&lt;/div&gt;&lt;/li&gt;'; $('#ulPlayPist').append(li_str); } } 以上就是基本代码 ","link":"https://shineyangpro.com/jquery-ru-he-ul-dong-tai-tian-jia-li-biao-qian/"},{"title":"Gin框架介绍及使用","content":"Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上Gin。 Gin框架安装与使用 安装 下载并安装Gin: go get -u github.com/gin-gonic/gin 第一个Gin示例： package main import ( &quot;github.com/gin-gonic/gin&quot; ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(&quot;/hello&quot;, func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() } 将上面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。 RESTful API REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。 推荐阅读阮一峰 理解RESTful架构 简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。 GET用来获取资源 POST用来新建资源 PUT用来更新资源 DELETE用来删除资源。 只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。 例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式： Gin框架支持开发RESTful API的开发。 func main() { r := gin.Default() r.GET(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;GET&quot;, }) }) r.POST(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;POST&quot;, }) }) r.PUT(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;PUT&quot;, }) }) r.DELETE(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;DELETE&quot;, }) }) } 开发RESTful API的时候我们通常使用Postman来作为客户端的测试工具。 Gin渲染 我们首先定义一个存放模板文件的templates文件夹，然后在其内部按照业务分别定义一个posts文件夹和一个users文件夹。 posts/index.html文件的内容如下： {{define &quot;posts/index.html&quot;}} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;posts/index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{.title}} &lt;/body&gt; &lt;/html&gt; {{end}} users/index.html文件的内容如下： {{define &quot;users/index.html&quot;}} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;users/index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{.title}} &lt;/body&gt; &lt;/html&gt; {{end}} Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。 func main() { r := gin.Default() r.LoadHTMLGlob(&quot;templates/**/*&quot;) //r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;) r.GET(&quot;/posts/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{ &quot;title&quot;: &quot;posts/index&quot;, }) }) r.GET(&quot;users/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{ &quot;title&quot;: &quot;users/index&quot;, }) }) r.Run(&quot;:8080&quot;) } 自定义模板函数 定义一个不转义相应内容的safe模板函数如下：func main() { router := gin.Default() router.SetFuncMap(template.FuncMap{ &quot;safe&quot;: func(str string) template.HTML{ return template.HTML(str) }, }) router.LoadHTMLFiles(&quot;./index.tmpl&quot;) router.GET(&quot;/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;index.tmpl&quot;, &quot;&lt;a href='https://liwenzhou.com'&gt;李文周的博客&lt;/a&gt;&quot;) }) router.Run(&quot;:8080&quot;) } 在index.tmpl中使用定义好的safe模板函数： <!DOCTYPE html> 修改模板引擎的标识符 {{ . | safe }} ``` + 静态文件处理 当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用gin.Static方法即可。 ``` func main() { r := gin.Default() r.Static(\"/static\", \"./static\") r.LoadHTMLGlob(\"templates/**/*\") // ... r.Run(\":8080\") } ``` + 使用模板继承 Gin框架默认都是使用单模板，如果需要使用block template功能，可以通过&quot;github.com/gin-contrib/multitemplate&quot;库实现，具体示例如下： 首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中home.tmpl和index.tmpl继承了base.tmpl： templates ├── includes │ ├── home.tmpl │ └── index.tmpl ├── layouts │ └── base.tmpl └── scripts.tmpl 然后我们定义一个loadTemplates函数如下： func loadTemplates(templatesDir string) multitemplate.Renderer { r := multitemplate.NewRenderer() layouts, err := filepath.Glob(templatesDir + &quot;/layouts/*.tmpl&quot;) if err != nil { panic(err.Error()) } includes, err := filepath.Glob(templatesDir + &quot;/includes/*.tmpl&quot;) if err != nil { panic(err.Error()) } // 为layouts/和includes/目录生成 templates map for _, include := range includes { layoutCopy := make([]string, len(layouts)) copy(layoutCopy, layouts) files := append(layoutCopy, include) r.AddFromFiles(filepath.Base(include), files...) } return r } 我们在main函数中 func indexFunc(c *gin.Context){ c.HTML(http.StatusOK, &quot;index.tmpl&quot;, nil) } func homeFunc(c *gin.Context){ c.HTML(http.StatusOK, &quot;home.tmpl&quot;, nil) } func main(){ r := gin.Default() r.HTMLRender = loadTemplates(&quot;./templates&quot;) r.GET(&quot;/index&quot;, indexFunc) r.GET(&quot;/home&quot;, homeFunc) r.Run() } 补充文件路径处理 关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。 func getCurrentPath() string { if ex, err := os.Executable(); err == nil { return filepath.Dir(ex) } return &quot;./&quot; } JSON渲染 func main() { r := gin.Default() // gin.H 是map[string]interface{}的缩写 r.GET(&quot;/someJSON&quot;, func(c *gin.Context) { // 方式一：自己拼接JSON c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;}) }) r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) { // 方法二：使用结构体 var msg struct { Name string `json:&quot;user&quot;` Message string Age int } msg.Name = &quot;小王子&quot; msg.Message = &quot;Hello world!&quot; msg.Age = 18 c.JSON(http.StatusOK, msg) }) r.Run(&quot;:8080&quot;) } XML渲染 注意需要使用具名的结构体类型。 func main() { r := gin.Default() // gin.H 是map[string]interface{}的缩写 r.GET(&quot;/someXML&quot;, func(c *gin.Context) { // 方式一：自己拼接JSON c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;}) }) r.GET(&quot;/moreXML&quot;, func(c *gin.Context) { // 方法二：使用结构体 type MessageRecord struct { Name string Message string Age int } var msg MessageRecord msg.Name = &quot;小王子&quot; msg.Message = &quot;Hello world!&quot; msg.Age = 18 c.XML(http.StatusOK, msg) }) r.Run(&quot;:8080&quot;) } YMAL渲染 r.GET(&quot;/someYAML&quot;, func(c *gin.Context) { c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK}) }) protobuf渲染 r.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) { reps := []int64{int64(1), int64(2)} label := &quot;test&quot; // protobuf 的具体定义写在 testdata/protoexample 文件中。 data := &amp;protoexample.Test{ Label: &amp;label, Reps: reps, } // 请注意，数据在响应中变为二进制数据 // 将输出被 protoexample.Test protobuf 序列化了的数据 c.ProtoBuf(http.StatusOK, data) }) 获取参数 获取querystring参数 querystring指的是URL中?后面携带的参数，例如：/user/search?username=小王子&amp;address=沙河。 获取请求的querystring参数的方法如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(&quot;/user/search&quot;, func(c *gin.Context) { username := c.DefaultQuery(&quot;username&quot;, &quot;小王子&quot;) //username := c.Query(&quot;username&quot;) address := c.Query(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run() } 获取form参数 请求的数据通过form表单来提交，例如向/user/search发送一个POST请求，获取请求数据的方式如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.POST(&quot;/user/search&quot;, func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 //username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;) username := c.PostForm(&quot;username&quot;) address := c.PostForm(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run(&quot;:8080&quot;) } 获取path参数 请求的参数通过URL路径传递，例如：/user/search/小王子/沙河。 获取请求URL路径中的参数的方式如下。 func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(&quot;/user/search/:username/:address&quot;, func(c *gin.Context) { username := c.Param(&quot;username&quot;) address := c.Param(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run(&quot;:8080&quot;) } 参数绑定 为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。 // Binding from JSON type Login struct { User string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;` Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;` } func main() { router := gin.Default() // 绑定JSON的示例 ({&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;}) router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) { var login Login if err := c.ShouldBind(&amp;login); err == nil { fmt.Printf(&quot;login info:%#v\\n&quot;, login) c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // 绑定form表单示例 (user=q1mi&amp;password=123456) router.POST(&quot;/loginForm&quot;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(&amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456) router.GET(&quot;/loginForm&quot;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(&amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // Listen and serve on 0.0.0.0:8080 router.Run(&quot;:8080&quot;) } ShouldBind会按照下面的顺序解析请求中的数据完成绑定： 1、如果是 GET 请求，只使用 Form 绑定引擎（query）。 2、如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。 文件上传 单个文件上传 文件上传前端页面代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;title&gt;上传文件示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 后端gin框架部分代码： func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(&quot;/upload&quot;, func(c *gin.Context) { // 单个文件 file, err := c.FormFile(&quot;f1&quot;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ &quot;message&quot;: err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: fmt.Sprintf(&quot;'%s' uploaded!&quot;, file.Filename), }) }) router.Run() } 多个文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(&quot;/upload&quot;, func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[&quot;file&quot;] for index, file := range files { log.Println(file.Filename) dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) } c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)), }) }) router.Run() } 重定向 HTTP重定向 HTTP 重定向很容易。 内部、外部重定向均支持。 r.GET(&quot;/test&quot;, func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, &quot;http://www.sogo.com/&quot;) }) 路由重定向 路由重定向，使用HandleContext： r.GET(&quot;/test&quot;, func(c *gin.Context) { // 指定重定向的URL c.Request.URL.Path = &quot;/test2&quot; r.HandleContext(c) }) r.GET(&quot;/test2&quot;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;}) }) 普通路由 r.GET(&quot;/index&quot;, func(c *gin.Context) {...}) r.GET(&quot;/login&quot;, func(c *gin.Context) {...}) r.POST(&quot;/login&quot;, func(c *gin.Context) {...}) 此外，还有一个可以匹配所有请求方法的Any方法如下： r.Any(&quot;/test&quot;, func(c *gin.Context) {...}) 为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回views/404.html页面。 r.NoRoute(func(c *gin.Context) { c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil) }) 路由组 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 func main() { r := gin.Default() userGroup := r.Group(&quot;/user&quot;) { userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...}) userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...}) } shopGroup := r.Group(&quot;/shop&quot;) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...}) shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...}) } r.Run() } 路由组也是支持嵌套的，例如： shopGroup := r.Group(&quot;/shop&quot;) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...}) shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...}) // 嵌套路由组 xx := shopGroup.Group(&quot;xx&quot;) xx.GET(&quot;/oo&quot;, func(c *gin.Context) {...}) } Gin中间件 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 定义中间件 Gin中的中间件必须是一个gin.HandlerFunc类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。 // StatCost 是一个统计耗时请求耗时的中间件 func StatCost() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Set(&quot;name&quot;, &quot;小王子&quot;) // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值 // 调用该请求的剩余处理程序 c.Next() // 不调用该请求的剩余处理程序 // c.Abort() // 计算耗时 cost := time.Since(start) log.Println(cost) } } 注册中间件 在gin框架中，我们可以为每个路由添加任意数量的中间件。 为全局路由注册 func main() { // 新建一个没有任何默认中间件的路由 r := gin.New() // 注册一个全局中间件 r.Use(StatCost()) r.GET(&quot;/test&quot;, func(c *gin.Context) { name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) r.Run() } 为某个路由单独注册 // 给/test2路由单独注册中间件（可注册多个） r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) { name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) 为路由组注册中间件 为路由组注册中间件有以下两种写法。 写法1： shopGroup := r.Group(&quot;/shop&quot;, StatCost()) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) ... } 写法2: shopGroup := r.Group(&quot;/shop&quot;) shopGroup.Use(StatCost()) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) ... } 中间件注意事项 gin默认中间件 gin.Default()默认使用了Logger和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release。 Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。 gin中间件中使用goroutine 当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 运行多个服务 我们可以在多个端口启动服务，例如： package main import ( &quot;log&quot; &quot;net/http&quot; &quot;time&quot; &quot;github.com/gin-gonic/gin&quot; &quot;golang.org/x/sync/errgroup&quot; ) var ( g errgroup.Group ) func router01() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&quot;/&quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &quot;code&quot;: http.StatusOK, &quot;error&quot;: &quot;Welcome server 01&quot;, }, ) }) return e } func router02() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&quot;/&quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &quot;code&quot;: http.StatusOK, &quot;error&quot;: &quot;Welcome server 02&quot;, }, ) }) return e } func main() { server01 := &amp;http.Server{ Addr: &quot;:8080&quot;, Handler: router01(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server02 := &amp;http.Server{ Addr: &quot;:8081&quot;, Handler: router02(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } // 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务 g.Go(func() error { return server01.ListenAndServe() }) g.Go(func() error { return server02.ListenAndServe() }) if err := g.Wait(); err != nil { log.Fatal(err) } } ","link":"https://shineyangpro.com/gin-kuang-jia-jie-shao-ji-shi-yong/"},{"title":"MWeb 3.4.1 中文破解版 (专业Markdown写作软件)","content":"安装步骤 如果遇到xxx.app已损坏，你应该将它移到废纸篓」 或者 「来自身份不明开发者」问题，请看解决办法: 1、最简单的方式：按住键盘上的control键，点击或者右键应用图标，再点击打开即可，但是此方法无疑是麻烦的。 2、打开终端输入:sudo spctl --master-disable 安装与激活 MWeb 如图所示：按住 control 键点击[安装]，再点击打开 ，按提示操作即可自动完成 MWeb 破解安装。 软件介绍/功能 MWeb是一款适用于macOS的专业Markdown写作、笔记本应用软件。喜欢写博客的朋友，那你一定会需要MWeb 破解版这款软件。为您提供最佳的写作体验。现为大家带来MWeb mac 破解版，此版本已经为大家破解激活，无需输入MWeb 激活码。 Markdown 语法支持 使用 Github Flavored Markdown 语法，简称 GFM 语法。支持表格、TOC、LaTeX、代码块、任务列表、脚注等。画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。 辅助功能 支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。在兼容 Markdown 语法的情况下支持设置图片宽度。好用的表格插入和 LaTeX 书写辅助。 输出功能 支持导出为图片、HTML、Epub、PDF、RTF、Docx。支持发布到 Wordpress、印象笔记、Blogger、Medium、Tumblr等。支持七牛云、又拍云等以及自定义的图床服务。 更多详情进入官网了解，点我传送 下载安装 下载地址1:点我传送 下载地址2点我传送 如果下载地址1无法访问，请使用下载地址2 ","link":"https://shineyangpro.com/mweb-341-zhong-wen-po-jie-ban-zhuan-ye-markdown-xie-zuo-ruan-jian/"},{"title":"在 Mac 端获取【网易云音乐】付费音乐的播放地址（注意下载要坚决支持正版！）","content":"在网易云音乐下载付费音乐，如果你是未付费人员会弹出如下的提示： 出于好奇，感觉音乐既然已经能够试听肯定是有有效的下载地址，只是在下载的时候做了权限判断，既然有地址那怎么去获取呢？ 首先查看下 云音乐 这个软件的 Bundle identifier ： 然后按照 Mac 软件的惯例，存在默认的缓存目录，先去看看果真有一个 com.netease.163music 文件夹。路径如下： 但是查看里面的信息只有一部分数据库记录和音乐专辑封面图片的缓存内容，使用 Navicat 查看也并未找到音乐地址的相关信息，难道就这样结束了吗？ 既然 Bundle identifier 以及 缓存目录中 163music 这个关键字，依据大家习惯的命名规则，应该通过这个也能定位查找到一部分数据信息呀，采用直接的关键字全局搜索还真的找到了部分日志文件：(或者可以打开Mac自带的控制台) 通过修改日期排列下顺序，那就直接 cat 看一下最近的那一个，不看不知道，一看这里面还真记录了基本上我听过的每首歌曲的详细信息啊，那就 COM+F 直接搜索刚才的一首 【爸爸妈妈】，直接就定位如下： 可以看到，有相关的歌词信息，也有具体的下载信息，为了保证用户可以正常欣赏咱们可以看到具体的播放地址有三个，看来网易的工作人员还是蛮严谨的嘛，直接去浏览器验证下地址： 果真是刚才听得的哪一首 _ 不过到最后还是要说，这属于一次好奇心“研究”，生命在于折腾寻找不同的可行路线嘛。 大家下载音乐还是要支持正版啊，支持辛苦创作的音乐人！ ","link":"https://shineyangpro.com/zai-mac-duan-huo-qu-wang-yi-yun-yin-le-fu-fei-yin-le-de-bo-fang-di-zhi-zhu-yi-xia-zai-yao-jian-jue-zhi-chi-zheng-ban/"},{"title":"Mac版Office 2019官方原版安装包和激活工具，Office 2019激活工具：Microsoft_Office_2019_VL_Serializer.pkg","content":"步骤预览 1、下载并安装 Office 2019 for mac 安装包； 2、安装 Office 2019 for mac 激活软件包； Office 2019激活方法：安装完Office后，运行下载的pkg文件按照提示进行激活。 安装 ① 下载 Mac版Office 2019 ② 安装 下载好的Office 2019 for Mac 激活 ①下载 Office 2019 for mac激活软件 ②安装下载好的Office 2019 for mac激活软件 完成了 那两个都安装完成后就Office 2019 for mac破解成功了，功能也会全部解锁。 Mac版Office 2019简介 Office 2019 mac简体中文版已经推出，具体包含Word，Excel，PowerPoint，Outlook，OneNote五大套件，注册登陆用户可以漫游文具包以及个性化功能区。 Office 2019 mac新版中，Word支持焦点模式（专注模式），也就是类似Win10 v1803中的“专注助手”，可以让你专心码字而屏蔽掉一切通知，声音等干扰内容。同时，还有新的内置翻译，无障碍优化等。 PPT加入了更多的转场效果，3D模型，时序序列以及4K视频导出； Excel预先添加了更多函数（CONCAT，TEXTJOIN，IFS，SWITCH），表格甚至2D地图等，OutLook的收件箱体验改善。 ","link":"https://shineyangpro.com/mac-ban-office-2019-guan-fang-yuan-ban-an-zhuang-bao-he-ji-huo-gong-ju-office-2019-ji-huo-gong-ju-microsoft_office_2019_vl_serializerpkg/"},{"title":"Navicat Premium 15.0.22 强大的数据库管理工具(Big Sur 可用)","content":" Navicat Premium是一个可多重连接的数据库管理工具，Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器的新手来说又相当容易学习。它可让你以单一程序同時连接到目前世面上所有版本的主流数据库并进行管理和操作，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL。让管理不同类型的数据库更加方便。 应用介绍 Navicat Premium 结合了其他 Navicat 成员的功能。有了不同数据库类型的连接能力，Navicat Premium 支持在 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 之间传输数据。包括存储过程，事件，触发器，函数，视图等。 Navicat Premium 适用于三种平台 - Microsoft Windows、Mac OS X 及 Linux。它可以让用户连接本机或远程服务器、提供一些实用的数据库工具如数据模型工具、数据同步、结构同步、导入、导出、备份、还原及报表以协助管理数据。 下载 点我传送 推荐 如果上面的打不开，可以使用百度网盘下载点我下载 提取码:pdt8 ","link":"https://shineyangpro.com/navicat-premium-15022-qiang-da-de-shu-ju-ku-guan-li-gong-ju-big-sur-ke-yong/"},{"title":"Swift-如何实现Cell可收起和展开","content":"这是一个简单的iOS swift项目，旨在介绍如何实现可收起和展开的table section，并且，项目不需要main storyboard, XIB, 注册nib等，只需要纯的Swfit代码！ 项目源代码 如果你希望获得Swift 3.0的代码，可以在migrate-to-swift-3.0分支里找到, 最终将会汇入master分支。 效果 如何实现可收起和展开的Table Section? 第一步. 准备数据 假设我们有如下的数据，它已经按照不同的section进行组织和整理，每个section都是一个Section结构（或对象）： struct Section { var name: String! var items: [String]! var collapsed: Bool! init(name: String, items: [String], collapsed: Bool = false) { self.name = name self.items = items self.collapsed = collapsed } } var sections = [Section]() sections = [ Section(name: &quot;Mac&quot;, items: [&quot;MacBook&quot;, &quot;MacBook Air&quot;, &quot;MacBook Pro&quot;, &quot;iMac&quot;, &quot;Mac Pro&quot;, &quot;Mac mini&quot;, &quot;Accessories&quot;, &quot;OS X El Capitan&quot;]), Section(name: &quot;iPad&quot;, items: [&quot;iPad Pro&quot;, &quot;iPad Air 2&quot;, &quot;iPad mini 4&quot;, &quot;Accessories&quot;]), Section(name: &quot;iPhone&quot;, items: [&quot;iPhone 6s&quot;, &quot;iPhone 6&quot;, &quot;iPhone SE&quot;, &quot;Accessories&quot;]) ] collapsed表示当前的section是否被收起或展开，默认下是false，即展开。 第二步. Section Header 根据苹果 API reference, 我们应该使用UITableViewHeaderFooterView. 让我们创建一个section header的类来继承它，我们把这个section header类起名为CollapsibleTableViewHeader: class CollapsibleTableViewHeader: UITableViewHeaderFooterView { let titleLabel = UILabel() let arrowLabel = UILabel() override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) contentView.addSubview(titleLabel) contentView.addSubview(arrowLabel) } required init?(coder aDecoder: NSCoder) { fatalError(&quot;init(coder:) has not been implemented&quot;) } } 当用户点击section header的时候我们需要收起或者展开这个section，为了实现这样的效果，让我们借用一下UITapGestureRecognizer. 同时我们需要将这个tap事件通知给table view并让它来更新section的collapsed值。 protocol CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) } class CollapsibleTableViewHeader: UITableViewHeaderFooterView { var delegate: CollapsibleTableViewHeaderDelegate? var section: Int = 0 ... override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) ... addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(CollapsibleTableViewHeader.tapHeader(_:)))) } ... func tapHeader(gestureRecognizer: UITapGestureRecognizer) { guard let cell = gestureRecognizer.view as? CollapsibleTableViewHeader else { return } delegate?.toggleSection(self, section: cell.section) } func setCollapsed(collapsed: Bool) { // Animate the arrow rotation (see Extensions.swf) arrowLabel.rotate(collapsed ? 0.0 : CGFloat(M_PI_2)) } } 既然我们不用任何storyboard或者XIB，如何实现自动布局呢？答案是运用NSLayoutConstraint的constraintsWithVisualFormat函数。 override init(reuseIdentifier: String?) { ... // arrowLabel must have fixed width and height arrowLabel.widthAnchor.constraintEqualToConstant(12).active = true arrowLabel.heightAnchor.constraintEqualToConstant(12).active = true titleLabel.translatesAutoresizingMaskIntoConstraints = false arrowLabel.translatesAutoresizingMaskIntoConstraints = false } override func layoutSubviews() { super.layoutSubviews() ... let views = [ &quot;titleLabel&quot; : titleLabel, &quot;arrowLabel&quot; : arrowLabel, ] contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;H:|-20-[titleLabel]-[arrowLabel]-20-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[titleLabel]-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[arrowLabel]-|&quot;, options: [], metrics: nil, views: views )) } 第三步. UITableView DataSource 以及 Delegate 首先，sections的数量为sections.count: override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return sections.count } 每个section里面cell的数量为: override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return sections[section].items.count } 接下来使用tableView的viewForHeaderInSection函数来渲染我们的section header: override func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { let header = tableView.dequeueReusableHeaderFooterViewWithIdentifier(&quot;header&quot;) as? CollapsibleTableViewHeader ?? CollapsibleTableViewHeader(reuseIdentifier: &quot;header&quot;) header.titleLabel.text = sections[section].name header.arrowLabel.text = &quot;&gt;&quot; header.setCollapsed(sections[section].collapsed) header.section = section header.delegate = self return header } 普通的cell就很简单了，没什么好说的： override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) as UITableViewCell? ?? UITableViewCell(style: .Default, reuseIdentifier: &quot;cell&quot;) cell.textLabel?.text = sections[indexPath.section].items[indexPath.row] return cell } 最后一步. 如何收起和展开？ 思路超级简单！如果该section的collapsed值为true, 我们就将这个section里所有cell的高度都设为0, 否则为 44.0! override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat { return sections[indexPath.section].collapsed! ? 0 : 44.0 } 切换收起和展开的函数如下: extension CollapsibleTableViewController: CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) { let collapsed = !sections[section].collapsed // Toggle collapse sections[section].collapsed = collapsed header.setCollapsed(collapsed) // Adjust the height of the rows inside the section tableView.beginUpdates() for i in 0 ..&lt; sections[section].items.count { tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: i, inSection: section)], withRowAnimation: .Automatic) } tableView.endUpdates() } } 注意到我们不是简单的重绘整个section，实际上我们只需要重绘section里的所有cell就好, 这样做的好处是避免了section header因重绘时闪烁的效果, 最重要是的可以让我们更平滑地处理我们想要的动画效果, 例如旋转那个箭头，改变背景颜色等等。 好了就这么多吧，如果你很感兴趣，请参考源码。 更多的关于table section收起和展开的项目 有时候你可能想要在grouped-style的table里实现section的收起和展开, 我写了另外一个Dome 实现的方法其实很类似。 ","link":"https://shineyangpro.com/swift-ru-he-shi-xian-cell-ke-shou-qi-he-zhan-kai/"},{"title":"构建更好的iOS App动画","content":" 动画是高质量用户体验的关键。它们具有多种用途，包括引导用户的注意力并将用户的操作与屏幕上的结果联系起来。 动画使您的应用程序体验独具特色-它们可以使其他媒体无法实现的响应性和交互性达到一定水平。为了制作更好的动画，他们需要传达一种更好的用户交互和视觉变化之间的直接联系感。实现此目的的一种方法是使动画完全互动。 为什么要创建互动动画？ 自从iPhone推出以来，互动动画就已经出现。世界上首次看到原始iPhone的是经典的“滑动解锁”屏幕，用户可以在其中直接移动滑块以解锁设备。对于以前从未使用过多点触摸设备的用户而言，此交互式动画立即直观。 交互式动画使用户可以更好地控制用户界面。直接操纵是自然的交互模型，尤其是在移动设备上。它将他们的动作连接到屏幕上的动画，并让他们完全控制其动作的完成或取消。 他们看起来也很棒。用户通常将应用程序的外观与应用程序的性能相关联，因此，如果应用程序看起来不错，则他们更有可能原谅其他缺点。 在本教程中，我们将使用来在Swift中构建一个交互式弹出动画UIViewPropertyAnimator。 UIViewPropertyAnimator简介 UIViewPropertyAnimator 已在iOS 10中添加到UIKit，并在iOS 11中进行了一些改进。它提供了UIView级别的面向对象的API来创建动画。 使用传统UIView动画，您可以编写如下内容： UIView.animate(withDuration: 1, delay: 0, options: [.curveEaseOut], animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }, completion: nil) 使用new UIViewPropertyAnimator，您可以编写以下代码： let animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut, animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }) animator.startAnimations() 代码非常相似。使用UIViewPropertyAnimator，您首先创建一个动画设计器对象，然后调用startAnimation()而不是在UIView类上调用静态方法。 随着动画复杂性的增加，UIViewPropertyAnimator变得更加有用。让我们看一个更复杂的动画。 该动画在平移视图时开始，可以在任一方向上进行擦洗，并且在平移完成后会动画到其最终位置。 在查看代码之前，了解状态机支持很重要UIViewPropertyAnimator。 动画师可以处于三种可能的状态之一：不活动，活动和停止。动画器初始化为非活动状态，但在启动或暂停时会移动到活动状态。动画完成后，它将返回到非活动状态。如果动画已开始且已暂停，则动画将保持活动状态，并且不会进行状态转换。 让我们看看如何使用UIPanGestureRecognizer旁边的UIViewPropertyAnimator来创建上面的动画。 var animator = UIViewPropertyAnimator() private func handlePan(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animator = UIViewPropertyAnimator(duration: 3, curve: .easeOut, animations: { myView.transform = CGAffineTransform(translationX: 275, y: 0) myView.alpha = 0 }) animator.startAnimation() animator.pauseAnimation() case .changed: animator.fractionComplete = recognizer.translation(in: myView).x / 275 case .ended: animator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 请注意，pauseAnimation()在之后立即调用startAnimation()。因为我们的动画是从平移手势开始的，所以用户最有可能先松开动画，然后再释放其点击。动画暂停时，设置fractionComplete属性以将视图与用户的触摸一起移动。 如果我们尝试使用标准UIView动画执行此操作，则将需要比上面示例中列出的逻辑更多的逻辑。UIView动画无法提供直接控制动画完成百分比的简便方法，也无法让我们轻松地暂停并继续动画直到完成。 让我们建立一个弹出菜单！ 我们将分十步构建一个完全交互式，可中断，可擦除和可逆的弹出菜单。（如果您希望从最终代码开始进行反向操作，则可以在本文末尾找到指向最终存储库的链接。） 为了简单起见，所有视图都将在代码中创建和修改（而不是在故事板中，尽管此代码与在故事板上创建的视图同样适用）。同样，所有代码都将放置在ViewController.swift文件中。 步骤＃1：点击以打开和关闭。 首先，让我们的弹出视图在打开状态和关闭状态之间进行动画处理。这里没有花哨的技巧，只是UIViewPropertyAnimator我们之前学习的基础知识。 private enum State { case closed case open } extension State { var opposite: State { switch self { case .open: return .closed case .closed: return .open } } } class ViewController: UIViewController { private lazy var popupView: UIView = { let view = UIView() view.backgroundColor = .gray return view }() override func viewDidLoad() { super.viewDidLoad() layout() popupView.addGestureRecognizer(tapRecognizer) } private var bottomConstraint = NSLayoutConstraint() private func layout() { popupView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(popupView) popupView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true popupView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true bottomConstraint = popupView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: 440) bottomConstraint.isActive = true popupView.heightAnchor.constraint(equalToConstant: 500).isActive = true } private var currentState: State = .closed private lazy var tapRecognizer: UITapGestureRecognizer = { let recognizer = UITapGestureRecognizer() recognizer.addTarget(self, action: #selector(popupViewTapped(recognizer:))) return recognizer }() @objc private func popupViewTapped(recognizer: UITapGestureRecognizer) { let state = currentState.opposite let transitionAnimator = UIViewPropertyAnimator(duration: 1, dampingRatio: 1, animations: { switch state { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } self.view.layoutIfNeeded() }) transitionAnimator.addCompletion { position in switch position { case .start: self.currentState = state.opposite case .end: self.currentState = state case .current: () } switch self.currentState { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } } transitionAnimator.startAnimation() } } popupViewTapped函数中有相关的动画代码，在点击视图时会调用该动画。我们只需创建一个动画师，设置其动画以修改约束的值，然后启动动画师。 我们引入一个State枚举来指示弹出窗口是打开还是关闭。它还具有计算opposite属性，该属性返回与当前状态相反的状态。我们本来可以用布尔标志来实现，但这更容易推论，尤其是当我们的动画代码变得更加复杂时。 需要指出的一件事-当动画完成时，我们正在手动更新约束的值。这应该由动画师自动处理，但是显式设置它们可以修复一些边缘错误。 步骤2：添加平移手势。 为了使动画具有交互性，我们将引入第二个手势识别器，即平移手势识别器。这将允许用户通过在弹出视图上滑动来开始和中断动画。 @objc private func popupViewPanned(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animateTransitionIfNeeded(to: currentState.opposite, duration: 1.5) transitionAnimator.pauseAnimation() case .changed: let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } transitionAnimator.fractionComplete = fraction case .ended: transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 该代码与前面的示例非常相似，不同之处在于可以中断动画。我们已经将动画代码重构为一个名为的函数animateTransitionIfNeeded，该函数可以运行该popupViewTapped函数内部以前的所有代码。 步骤＃3：记录动画进度以修复中断偏移。 一个问题：当动画被中断时，它会偏离用户的触摸。这是由于平移处理程序未考虑动画的当前进度。要解决此问题，我们需要记录fractionComplete动画师的，并在计算平移偏移时将其用作基线。 我们将需要一个属性来存储动画的当前进度： private var animationProgress: CGFloat = 0 当平移手势处于其began状态时，我们记录动画的当前进度： animationProgress = transitionAnimator.fractionComplete 在平移手势的changed状态下，我们将动画进度添加到计算的分数中： transitionAnimator.fractionComplete = fraction + animationProgress 现在，平移手势可以按预期工作，并且可以更自然地跟踪用户的手指。 注意：为了对a进行子类化UIGestureRecognizer，您需要在文件顶部包含此导入： import UIKit.UIGestureRecognizerSubclass 步骤＃5：使用平移速度反转动画。 剩下的一个问题是，弹出窗口不考虑视图的“抛出”方式。如果我们点击关闭的弹出窗口，在动画中期捕获它，然后向下滑动，它将继续对打开的动画进行动画处理。 为了解决这个问题，我们可以有条件地反转动画师。这将基于以下几个因素：弹出窗口的当前状态，动画器当前是否反转以及平移手势的速度。 ended现在，平移手势处理程序的情况如下所示： let yVelocity = recognizer.velocity(in: popupView).y let shouldClose = yVelocity &gt; 0 if yVelocity == 0 { transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) break } switch currentState { case .open: if !shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } case .closed: if shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if !shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } } transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) 这种逻辑乍一看似乎很复杂，但是可以通过考虑所有可能的情况来得出。 在平移手势处理程序发生更改的情况下，我们需要尊重isReversed动画设计器的属性： let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } if transitionAnimator.isReversed { fraction *= -1 } transitionAnimator.fractionComplete = fraction + animationProgress 现在我们的动画可以反转了！如果用户希望在动画中关闭弹出窗口，则这样做很容易直观。 步骤＃6：设置拐角半径的动画。 在iOS 11中，CALayer无需设置即可设置动画人物的拐角半径CABasicAnimation。这意味着我们可以在动画块中更新视图的角半径，它就可以工作！ self.popupView.layer.cornerRadius = 20 我们还可以指定圆角。在这种情况下，我们只希望对左上角和右上角进行圆角处理。 view.layer.maskedCorners = [.layerMaxXMinYCorner, .layerMinXMinYCorner] 现在，顶部的两个角与我们的原始动画一起被动画化。 步骤＃7：使其更漂亮！ 我们的灰色弹出视图效果很好，但可以进行一些视觉上的改进。让我们添加背景图像，叠加视图，标题标签，细微阴影和一些示例评论。 本教程将不介绍这些其他视图的实现。如果您想了解它们的创建方式，请在文章底部查看完整的源代码。 好多了。 😎 步骤＃8：对标签进行动画处理。 关闭弹出窗口时，“审阅”标签看起来不错，但是当打开时，它无法从其余内容中脱颖而出。打开弹出窗口时，我们希望为标签提供更大的字体大小和更深的颜色。由于我们的弹出窗口是完全交互式且可擦除的，因此需要对标签过渡进行动画处理。 没有内置的方式来设置标签的颜色或字体样式的动画。我们的解决方案是一个简单的解决方法：交叉淡化标签。 为了使动画平滑，我们需要对每个标签的比例和平移进行动画处理，以使它们在动画的整个过程中完美重叠。 在动画块内，我们修改标签的alpha和transform： switch state { case .open: // other animations here ... self.closedTitleLabel.transform = CGAffineTransform(scaleX: 1.6, y: 1.6).concatenating(CGAffineTransform(translationX: 0, y: 15)) self.openTitleLabel.transform = .identity self.openTitleLabel.alpha = 1 self.closedTitleLabel.alpha = 0 case .closed: // other animations here ... self.closedTitleLabel.transform = .identity self.openTitleLabel.transform = CGAffineTransform(scaleX: 0.65, y: 0.65).concatenating(CGAffineTransform(translationX: 0, y: -15)) self.openTitleLabel.alpha = 0 self.closedTitleLabel.alpha = 1 } 现在，标签看起来就像它们在彼此变形一样。正确对齐后，看起来只有一个标签。 步骤＃9：重构多个动画制作者。 标签动画效果很好，但是可以改善时间以进一步平滑过渡。为了修改标签动画的时序曲线，我们需要其他动画师。AUIViewPropertyAnimator只能有一条时序曲线，因此要使用多个时序曲线，我们需要协调多个动画制作者。 我们需要稍微重构代码以支持任意数量的动画制作者。为此，我们将创建一系列动画师。 private var runningAnimators = [UIViewPropertyAnimator]() 每当我们创建新的动画师时，我们都会将其添加到正在运行的动画师数组中。 runningAnimators.append(transitionAnimator) 每当动画结束时，我们都会将其从数组中删除。为了使其余代码可与多个动画师一起使用，应用于的所有内容transitionAnimator都将应用于整个数组。 步骤＃10：为标签alpha添加新的动画师。 借助新的基础架构，我们可以创建两个新的动画师：一个为新标签制作动画，另一个为旧标签制作动画。使用多个动画制作者的好处是每个动画制作者都有自己的时序曲线。 let inTitleAnimator = UIViewPropertyAnimator(duration: duration, curve: .easeIn, animations: { switch state { case .open: self.openTitleLabel.alpha = 1 case .closed: self.closedTitleLabel.alpha = 1 } }) inTitleAnimator.scrubsLinearly = false 我们将动画师的scrubsLinearly属性设置为false，以便fractionComplete动画的映射到缓动时序曲线，而不是线性时序曲线。通常，跟随用户手指的动画应遵循线性时序曲线，这就是为什么此属性默认为true的原因。 （注意：scrubsLinearly仅在iOS 11+上可用） 两者之间的差异很小，但可以在以后进一步自定义动画。当用户完全控制动画并可以将其拖到任何位置时，正确实现此过渡非常重要。 这是我们的最终动画！用户可以通过轻击或滑动开始动画，可以中断动画，并可以反转动画。相当少量的代码，很酷。 什么时候应该使用UIViewPropertyAnimator？ iOS中有如此众多的动画API，什么时候最好使用UIViewPropertyAnimator？ 差异是可中断性。如果要在飞行过程中“捕捉”视图，进行擦洗，然后继续或反转动画，UIViewPropertyAnimator则是最佳选择。其他一些动画策略是可中断的，例如在滚动视图的contentOffset属性旁边设置视图动画，但这些动画仅限于滚动视图的时序曲线。 有时，动画可中断是没有意义的。仅当用户可以在动画过程中点击视图时，才使动画可中断。动画应具有足够长的持续时间，以使用户可以足够快地做出反应以点击它，而动画视图应具有较大的点击目标。上面的弹出动画是满足这些要求的完美示例。 链接与资源 完整的源代码可在GitHub上找到：点我传送 ","link":"https://shineyangpro.com/gou-jian-geng-hao-de-ios-app-dong-hua/"},{"title":"ThinkPHP5.0路径中去除index.php入口文件方式","content":"1、httpd.conf配置文件中加载了mod_rewrite.so模块 //在APACHE里面去配置 #LoadModule rewrite_module modules/mod_rewrite.so把前面的警号去掉,如下图: 如果没有，可以自己添加进去（我的是没有，我自己添加进去的） 2、AllowOverride None 讲None改为 All （搜索到的全部改为All就好，小写的就改成小写的all） 3、确保URL_MODEL设置为2，在项目的配置文件里写 4、.htaccess文件必须放到跟目录下（没有就新建一个，TP5.0有自带(application这个文件夹)，可以拷贝出来，Mac下按command+Shift+.可以显示隐藏文件）在里面添加如下内容： &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/IfModule&gt; ","link":"https://shineyangpro.com/thinkphp50-lu-jing-zhong-qu-chu-indexphp-ru-kou-wen-jian-fang-shi/"},{"title":"Swift NSClassFromString初始化控制器","content":"在OC中我们反射是这样的： [[NSClassFromString(@&quot;Foo&quot;) alloc] init]; 但是在Swift中这种方式是不可用的，经过查找资料，琢磨，终于找到了方法 swift中的NSClassFromString是这样的： ","link":"https://shineyangpro.com/swift-nsclassfromstring-chu-shi-hua-kong-zhi-qi/"},{"title":"Mac下使用Visual Studio Code调试C#控制台程序以及相关的配置（2）","content":"安装.NET Core 在mac上打开终端输入以下命令: ~$ brew update ~$ brew install openssl ~$ brew link --force openssl 如果不能使用brew命令，先安装homebrew，玩转Mac必备。下载.NET Core SDK：https://go.microsoft.com/fwlink/?LinkID=80912下载完成后双击pkg安装，如下图所示：一路Next完成后.Net Core就在Mac上安装好了。 新建一个.NET Core的程序 打开Mac的终端： mkdir hwapp cd hwapp 然后创建一个简单控制台程序如：dotnet new console （创建控制台应用程序） 这几个命令是新建一个叫hwapp的目录然后在该目录下初始化一个项目，类似于用VS新建一个控制台项目，如下图所示： 运行一个程序 在终端定位到hwapp目录然后执行命令： dotnet restore dotnet run 这2个命令是说还原该项目的依赖，并且编译运行，输出Hello World， 安装Visual Studio Code Mac上没有宇宙第一IDE VS 那我们怎么写代码呢？别急，微软为了.NET Core的跨平台计划已经给我们开发了一款编辑器 VS Code。虽然VS Code没发布多久，但是个人觉得已经超越了Atom，Sublime Text等Mac上以前常用的编辑器。不光可以开发C#，而且调试Nodejs也是非常顺手。 下载：https://code.visualstudio.com/b?utm_expid=101350005-21.ckupCbvGQMiML5eJsxWmxw.1&amp;utm_referrer=https%3A%2F%2Fwww.microsoft.com%2Fnet%2Fcore 装完后用VS Code打开hwapp文件夹，如下图所示： 安装VS Code的C#扩展 打开VS Code，按快捷键：Command+p，在弹出的输入框里输入ext install csharp，在搜索出来的下拉框里选第一个C# 安装完C#的扩展插件后让我们打开Program.cs这个文件编辑一下吧。这个时候已经有C#标准的代码着色，跟智能提示了，如下图所示： 调试程序 在调试之前能，我们需要配置luanch.json文件。 luanch.json是用来描述Debugger的配置的文件。 我们主要是需要修改program属性的设置，其实就是当前可执行文件的Path，注意在Mac下没有exe，编译后是dll，如下图所示： “${workspaceRoot}/bin/Debug/netcoreapp1.0/hwapp.dll”配置好后我们就可以开始正式调试程序了。 VSCode的左侧边栏有一只虫子样的图标，点击后切换到调试模式，VS Code中下断点跟VS里一样，在代码行的最左边点击一下，出现一个红点，表示下断点成功。 在绿色箭头旁边的下拉框选择.NET Core Launch (Console)控制台调试模式。点击绿色的箭头就可以开始调试啦，如果有断点的话代码就会停止在断点位置 使用方式跟VS基本一致，F5执行，F10单步跳过，F11单步调试，鼠标悬停在变量上可以查看值，监控变量等等。(Mac上可能会出现热键冲突)； ","link":"https://shineyangpro.com/mac-xia-shi-yong-visual-studio-code-diao-shi-ckong-zhi-tai-cheng-xu-yi-ji-xiang-guan-de-pei-zhi-2/"},{"title":"iOS中比较当前日期与指定日期大小","content":"1、首先获取当前日期NSDate形式，指定一个日期格式 #pragma mark -得到当前时间 +(NSDate *)getCurrentTime{ NSDateFormatter *formatter=[[NSDateFormatter alloc]init]; [formatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *dateTime=[formatter stringFromDate:[NSDate date]]; NSDate *date = [formatter dateFromString:dateTime]; NSLog(@&quot;---------- currentDate == %@&quot;,date); return date; } 2、然后将指定日期（此处以2016-09-30-00点为例）转换为同样日期格式，返回NSDate形式 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSDate *date = [dateFormatter dateFromString:@&quot;30-09-2016-000000&quot;]; 3、最后进行比较，将现在的时间与指定时间比较，如果没达到指定日期，返回-1，刚好是这一时间，返回0，否则返回1 +(int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay { NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; NSLog(@&quot;date1 : %@, date2 : %@&quot;, oneDay, anotherDay); if (result == NSOrderedDescending) { //NSLog(@&quot;Date1 is in the future&quot;); return 1; } else if (result == NSOrderedAscending){ //NSLog(@&quot;Date1 is in the past&quot;); return -1; } //NSLog(@&quot;Both dates are the same&quot;); return 0; } 4、调用 [self compareOneDay:[self getCurrentTime] withAnotherDay:date] ","link":"https://shineyangpro.com/ios-zhong-bi-jiao-dang-qian-ri-qi-yu-zhi-ding-ri-qi-da-xiao/"},{"title":"Swift 时间转换成今天、明天、昨天","content":"func dayDifference(from interval : TimeInterval) -&gt; String { let calendar = NSCalendar.current let date = Date(timeIntervalSince1970: interval) if calendar.isDateInYesterday(date) { return &quot;Yesterday&quot; } else if calendar.isDateInToday(date) { return &quot;Today&quot; } else if calendar.isDateInTomorrow(date) { return &quot;Tomorrow&quot; } else { let startOfNow = calendar.startOfDay(for: Date()) let startOfTimeStamp = calendar.startOfDay(for: date) let components = calendar.dateComponents([.day], from: startOfNow, to: startOfTimeStamp) let day = components.day! if day &lt; 1 { return &quot;\\(abs(day)) days ago&quot; } else { return &quot;In \\(day) days&quot; } } } ","link":"https://shineyangpro.com/swift-shi-jian-zhuan-huan-cheng-jin-tian-ming-tian-zuo-tian/"},{"title":"Xcode11以后新变化：SceneDelegate","content":"Xcode11后，运行旧项目，相安无事，心里捏了一把汗，终于没有跟往年那样一更新就给你一大堆报错了。刚才突发奇想，使用Xcode11新建iOS项目时,如果你跟往常一样在Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建根控制器，会崩溃报错： Appdelegate找不到设置window的方法。 然后发现Xcode自动新增了一个SceneDelegate文件，查找了一下官方文档WWDC2019：Optimizing App Launch 发现，iOS13中appdelegate的职责发现了改变： iOS13之前，Appdelegate的职责全权处理App生命周期和UI生命周期； iOS13之后，Appdelegate的职责是： 1、处理 App 生命周期 2、新的 Scene Session 生命周期 那UI的生命周期呢？交给新增的Scene Delegate处理 用图表示就是： iOS13之前： 这种模式完全没问题，因为只有一个进程，只有一个与这个进程对应的用户界面 但是iOS13之后，Appdelegate不在负责UI生命周期，所有UI生命周期交给SceneDelegate处理： 因此初始化window方法需要改变： 现在不再Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions进行初始化，转交给SceneDelegate的willConnectToSession:方法进行根控制器设置： - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions { UIWindowScene *windowScene = (UIWindowScene *)scene; self.window = [[UIWindow alloc] initWithWindowScene:windowScene]; self.window.frame = windowScene.coordinateSpace.bounds; self.window.rootViewController = [UITabBarController new]; [self.window makeKeyAndVisible]; } ","link":"https://shineyangpro.com/xcode11-yi-hou-xin-bian-hua-scenedelegate/"},{"title":"如何修改Mac自带PHP版本，php-v和phpinfo两个不同的版本","content":"find / -name php.ini 得出两个ini /usr/local/php/etc/php.ini /etc/php.ini php -i | grep php.ini 查看PHP加载的是哪个配置文件,这个获取的是系统内的php.ini 的位置。不是网页apache加载的php.ini文件 查找一下系统里的PHP目录相关的东西 find / -name php /usr/bin/php -v 再环境变量里加上要使用的PHP的路径 vim /etc/profile 在文档最后，添加: export PATH=&quot;/usr/local/php/bin:$PATH&quot; 保存，退出，然后运行： source /etc/profile 如果profile这里添加成功后不能退出，请执行这个命令： :w !sudo tee % 解释： :w – write !sudo – call shell sudo command tee – the output of write (:w) command is redirected using tee % – current file name 参考文章https://stackoverflow.com/questions/28635647/how-can-i-save-a-file-i-opened-in-vim-as-the-wrong-user ","link":"https://shineyangpro.com/ru-he-xiu-gai-mac-zi-dai-php-ban-ben-php-v-he-phpinfo-liang-ge-bu-tong-de-ban-ben/"},{"title":"Apple美区官网购买礼品兑换充值卡（iTunes Gift Card ）","content":" 第一步：购买地址 点击我购买 第二步 填写购买信息 第三步：登陆 apple ID 第四步：填写支付信息 第五步：获取礼品兑换码 可以直接点击，会直接跳转到ituens,如果没跳转，可以鼠标右键复制链接的方式来获得兑换码 复制到记事本 第六步：在手机上输入兑换码 ","link":"https://shineyangpro.com/apple-mei-qu-guan-wang-gou-mai-li-pin-dui-huan-chong-zhi-qia-itunes-gift-card/"},{"title":"Xcode11 使用终端上传ipa","content":" 升级 Xcode 11 后, Xcode 删掉了 Application loader工具，使用 Xcode自带的上传功能，太卡，经常停留在进度条不动，于是便通过终端-&gt; xcrun altool上传。 整个过程5分钟内搞定，命令不多，就两个 校验 和 上传 校验 ipa xcrun altool --validate-app -f xxxx.ipa -t ios --apiKey xxxx --apiIssuer xxxx --verbose 上传 ipa xcrun altool --upload-app -f xxxx.ipa -t ios --apiKey xxxxx --apiIssuer xxxxx--verbose 上面一个命令，区别只在于， 校验是 validate-app , 上传是 upload-appxxxx.ipa 是 ipa文件的绝对路径 (以防万一，最好写绝对)apiKey xxxx 此处的 xxxx为 apiKey的值，获取方法见下面apiIssuer xxxx 此处的 xxxx为 apiIssuer的值，获取方法见下面 获取方式 1、进入开发者后台 -&gt; 用户和访问 2、apiKey 即密钥ID 3、 apiIssuer 即 Issuer ID 上传成功 要把开发者中心的密钥文件下载到电脑上，最好是放到用户的目录下面/用户/xxx ","link":"https://shineyangpro.com/xcode11-shi-yong-zhong-duan-shang-chuan-ipa/"},{"title":"Swift 把 1234656转化成 1.23万 或1.23亿 或 1 万 ，1亿","content":"extension Float { /** 战斗力值转换 */ var combatValues: String { if (self / 10000) &gt; 1 { let temp = self / 10000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;万&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;万&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;万&quot; } return str + &quot;万&quot; } } if (self / 100000000) &gt; 1 { let temp = self / 100000000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;亿&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;亿&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;亿&quot; } return str + &quot;亿&quot; } } let decimal = String.init(self).componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;0&quot; { return decimal[0] } return String.init(self) } } 字符串扩展 extension String { func attributedString(font:CGFloat)-&gt;NSMutableAttributedString{ let attributedS = NSMutableAttributedString(string: self) if self.containsString(&quot;万&quot;) || self.containsString(&quot;亿&quot;) { let normalAttributes = [NSFontAttributeName:UIFont.systemFontOfSize(font)] attributedS.addAttributes(normalAttributes, range: NSMakeRange(self.characters.count - 1,1)) } return attributedS } } 调用：label.attributedText = Float(number).combatValues ","link":"https://shineyangpro.com/swift-ba-1234656-zhuan-hua-cheng-123-wan-huo-123-yi-huo-1-wan-1-yi/"},{"title":"macOS Catalina (macOS 10.15) 已损坏无法打开解决办法","content":"最近有很多小伙伴更新系统后，提示“已损坏无法打开”的情况，按照以往的方法，在系统的“安全与隐私”中已经允许了“任何来源”，但还是一样打不开，怎么办呢？ App 在 macOS Catalina下提示已损坏无法打开解决办法： 1、在系统的“安全与隐私”中允许“任何来源”，再打开终端。 2、输入以下命令: sudo xattr -d com.apple.quarantine /Applications/xxxx.app 注意：Applications/xxxx.app 换成你的App路径或在sudo xattr -d com.apple.quarantine 后将软件拖进去即可。 3、最后，重启App即可。 ","link":"https://shineyangpro.com/macos-catalina-macos-1015-yi-sun-pi-wu-fa-da-kai-jie-jue-ban-fa/"},{"title":"Mac下配置Go开发环境","content":"Go（又称 Golang）是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go 的语法接近 C 语言，可以进行网络编程、系统编程、并发编程、分布式编程。 下面演示如何在 Mac 电脑上搭建 Go 语言开发环境。 1，安装 Golang 的 SDK 在官网下载对应的开发工具GoLand,地址如下:https://golang.org/dl/ 2，配置环境变量 （1）在终端执行如下命令进入用户主目录： cd ~ （2）执行如下命令打开 .bash_profile 文件： vim .bash_profile （3）按下 i 进入编辑模式，在文件末尾添加如下内容（GOPATH地址是自己创建项目的地址，比如我的是在桌面的文件夹下创建的）： export GOPATH=/Users/yangchen/Desktop/ReactNatve/Go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN （4）按下 ESC 键，然后输入 :wq 保存并退出编辑。 （5）接着执行如下命令让配置生效。 source ~/.bash_profile 最后我们执行 go env 查看配置结果，可以看到 GO 的环境变量已成功配置了。 ","link":"https://shineyangpro.com/mac-xia-pei-zhi-go-kai-fa-huan-jing/"},{"title":"Swift  从子视图跳转到指定tabBar主界面","content":"从tabbar的子页面跳转到指定的tabbar主页面,话不多说直接上代码: self.navigationController?.tabBarController?.selectedIndex = 0 self.navigationController?.popViewController(animated: false) ","link":"https://shineyangpro.com/swift-cong-zi-shi-tu-tiao-zhuan-dao-zhi-ding-tabbar-zhu-jie-mian/"},{"title":"Swift UICollectionView横向分页滚动，cell左右排版","content":"废话不多说，直接上代码 自定义一个SYitemViewLayout，继承UICollectionViewFlowLayout mport UIKit //根据需求设置列跟行 let kEmotionCellNumberOfOneRow = 3 let kEmotionCellRow = 2 class SYitemViewLayout: UICollectionViewFlowLayout { // 保存所有item fileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] // MARK:- 重新布局 override func prepare() { super.prepare() let itemWH: CGFloat = (kScreenWitdh - 30) / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH - 50) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true // let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 // collectionView?.contentInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10) var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount { let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * (kScreenWitdh - 30)) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) } } override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? { var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map({ if rect.contains($0.frame) { rectAttributes.append($0) } }) return rectAttributes } } ","link":"https://shineyangpro.com/swift-uicollectionview-heng-xiang-fen-ye-gun-dong-cell-zuo-you-pai-ban/"},{"title":"Swift框架-章：1、开发一个Swift框架","content":"Swift已成为一种流行的编程语言，并且每天都在发展。 开发Swift框架具有以下优点。 隐藏您的代码实现。 由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 开发Swift框架具有以下优点。 1、隐藏您的代码实现。 2、由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 使用的工具：XCode 11.6 +，Swift 5.1+ 步骤1：-安装框架项目 1、创建新的XCode项目。 2、 创建框架 为您的项目命名，我们使用了类似于Alamofire的AlamoWater名字。 （请确保选择语言-Swift） 单击目标内的AlamoWater文件夹，然后按⌘+N。 选择文件名AlamoWater和以下子类：NSObject 在AlameWater.swift中添加以下代码**。** **注意：-**确保您的类和方法设置为Public import UIKit public protocol AlamoWaterProtocol { func didCallHello() } open class AlamoWater: NSObject { public static let shared = AlamoWater() public var delegate:AlamoWaterProtocol? open func hello(){ debugPrint(&quot;Hello from AlamoWater!&quot;) AlamoWater.shared.delegate?.didCallHello() } } 要为iOS设备和模拟器创建框架，请向您的项目添加新的Aggregate目标。 并添加[运行脚本] #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # make sure the output directory exists mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # Step 1. Build Device and Simulator versions xcodebuild -target &quot;AlamoWater&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build xcodebuild -target &quot;AlamoWater&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build # Step 2. Copy the framework structure (from iphoneos build) to the universal folder cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/&quot; # Step 3. Copy Swift modules from iphonesimulator build (if it exists) to the copied framework directory SIMULATOR_SWIFT_MODULES_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/Modules/AlamoWater.swiftmodule/.&quot; if [ -d &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; ]; then cp -R &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/Modules/AlamoWater.swiftmodule&quot; fi # Step 4. Create universal binary file using lipo and place the combined executable in the copied framework directory lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework/AlamoWater&quot; # Step 5. Convenience step to copy the framework to the project's directory cp -R &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework&quot; &quot;${PROJECT_DIR}&quot; # Step 6. Convenience step to open the project's directory in Finder open &quot;${PROJECT_DIR}&quot; 注意：AlamoWater改为自己项目的名字 通过按⌘+ B选择UniversalAlamoWater目标来构建您的第一个框架 构建完成后，您将看到Finder与其中的Framework一起打开。 注意：-如果出现以下错误， … Reason: image not found 确保在嵌入式二进制文件和链接的框架和库中都添加了框架 ","link":"https://shineyangpro.com/swift-kuang-jia-zhang-1kai-fa-yi-ge-swift-kuang-jia/"},{"title":"Go实战项目【一】Golang和Gin框架的安装和使用","content":"Golang的安装 根据所使用的电脑操作系统，下载相对应的版本Golang 下载 比如我的电脑是macOS系统，下载的是 安装完毕后配置路径 打开终端，执行: vi ~/.bash_profile .bash_profile 添加的内容如下： #Go export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 然后执行 source ~/.bash_profile 让配置生效 执行 go version 查看Golang是否安装成功，出现以下信息即为安装成功 初始化项目目录 选一个你自己喜欢的路径，创建一个文件夹，比如我的是/Users/newmac/Documents/Go-app这个文件夹下 cd /Users/newmac/Documents/Go-app mkdir api &amp;&amp; cd api go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go mod init api mkdir api &amp;&amp; cd api：创建并进入api文件夹 go env -w GO111MODULE=on：开启Go modules go env -w GOPROXY=https://goproxy.cn,direct：设置 GOPROXY 代理，也可以把GOPROXY写入.bash_profile中 go mod init [MODULE_PATH]：初始化 Go modules，它将会生成 go.mod 文件，MODULE_PATH 填写的是模块引入路径，如果想要把项目放到Github上，可以填写GitHub的项目路径，这个根据自己情况填写。 然后就会在api文件夹下出现go.mod文件 安装Gin框架 在api文件夹下，执行 go get -u github.com/gin-gonic/gin 安装完毕后，创建一个test.go文件，测试下Gin框架是否能使用test.go 我用的是GoLang开发工具，可以直接在编译器里面执行 如果用的是VS code，可以在终端运行:go run test.go 在浏览器打开127.0.0.1:8080/ping这个地址，可以看到有返回的数据，代表Gin框架安装和使用成功。 Go相关学习知识 ","link":"https://shineyangpro.com/go-shi-zhan-xiang-mu-yi-golang-he-gin-kuang-jia-de-an-zhuang-he-shi-yong/"},{"title":"清理Xcode占用的Mac硬盘空间","content":"主要是操作两个目录下的文件 ~/Library/Developer/Xcode 和 ~/Library/Developer/CoreSimulator ~/Library/Developer/Xcode 1、DerivedData 此文件夹内的每个目录是Xcode运行每个APP时生成的缓存文件，删除之后再运行APP会重新生成该APP对应的文件，只是编译时间变长了。 可保留近期运行的APP相关的文件夹，对于以前运行过近期不再使用的APP，例如网上下载的demo，建议清理。 Archives 此文件夹中的内容对应Xcode-&gt;Window-&gt;Organizer-&gt;Archives中列出的打包文件。 可保留有用的打包文件，其它删除。 iOS DeviceSupport 此文件夹存放的是Xcode对你所连接真机的版本支持，每个文件夹几乎都是几个G的大小（我个人的情况是11个目录占了26G空间），手机每升级一个版本，再次连接Xcode时，这里都会生成一个目录。 建议保留你手机当前版本的文件夹。全部删除也没关系，手机再次连接Xcode时会重新生成。 2. ~/Library/Developer/CoreSimulator Devices 此文件夹下的目录是以模拟器的UDID命名的，运行模拟器时每安装一个新的APP，相应的文件夹内容也会增大，就像手机上安装应用会占用手机空间一样。 可删除全部文件夹。再次运行模拟器，会重新生成。 删除后开启Xcode运行模拟器，可能会出现下面的错误，不要惊慌，重启Xcode就好了。 建议在退出Xcode后进行清理，清理后重启电脑 ","link":"https://shineyangpro.com/qing-li-xcode-zhan-yong-de-mac-ying-pan-kong-jian/"},{"title":"iOS 13：Swift以编程方式设置应用程序根视图控制器不起作用","content":"在iOS以后直接使用window?.makeKeyAndVisible()是不起作用的，正确用法是: static func redirectToMainNavRVC(currentVC: UIViewController){ let appDelegate = UIApplication.shared.delegate as! AppDelegate let vc = UIStoryboard(name: appDelegate.storyBoardName, bundle: nil).instantiateViewController(withIdentifier: &quot;MainNavigationViewController&quot;) as! MainNavigationViewController if #available(iOS 13.0, *){ if let scene = UIApplication.shared.connectedScenes.first{ guard let windowScene = (scene as? UIWindowScene) else { return } print(&quot;&gt;&gt;&gt; windowScene: \\(windowScene)&quot;) let window: UIWindow = UIWindow(frame: windowScene.coordinateSpace.bounds) window.windowScene = windowScene //Make sure to do this window.rootViewController = vc window.makeKeyAndVisible() appDelegate.window = window } } else { appDelegate.window?.rootViewController = vc appDelegate.window?.makeKeyAndVisible() } } ","link":"https://shineyangpro.com/ios-13swift-yi-bian-cheng-fang-shi-she-zhi-ying-yong-cheng-xu-gen-shi-tu-kong-zhi-qi-bu-qi-zuo-yong/"}]}