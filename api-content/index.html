{"posts":[{"title":"Swift NSClassFromString初始化控制器","content":"在OC中我们反射是这样的： [[NSClassFromString(@&quot;Foo&quot;) alloc] init]; 但是在Swift中这种方式是不可用的，经过查找资料，琢磨，终于找到了方法 swift中的NSClassFromString是这样的： ","link":"https://shineyangpro.com/post/swift-nsclassfromstring-chu-shi-hua-kong-zhi-qi/"},{"title":"Mac下使用Visual Studio Code调试C#控制台程序以及相关的配置（2）","content":"安装.NET Core 在mac上打开终端输入以下命令: ~$ brew update ~$ brew install openssl ~$ brew link --force openssl 如果不能使用brew命令，先安装homebrew，玩转Mac必备。下载.NET Core SDK：https://go.microsoft.com/fwlink/?LinkID=80912下载完成后双击pkg安装，如下图所示：一路Next完成后.Net Core就在Mac上安装好了。 新建一个.NET Core的程序 打开Mac的终端： mkdir hwapp cd hwapp 然后创建一个简单控制台程序如：dotnet new console （创建控制台应用程序） 这几个命令是新建一个叫hwapp的目录然后在该目录下初始化一个项目，类似于用VS新建一个控制台项目，如下图所示： 运行一个程序 在终端定位到hwapp目录然后执行命令： dotnet restore dotnet run 这2个命令是说还原该项目的依赖，并且编译运行，输出Hello World， 安装Visual Studio Code Mac上没有宇宙第一IDE VS 那我们怎么写代码呢？别急，微软为了.NET Core的跨平台计划已经给我们开发了一款编辑器 VS Code。虽然VS Code没发布多久，但是个人觉得已经超越了Atom，Sublime Text等Mac上以前常用的编辑器。不光可以开发C#，而且调试Nodejs也是非常顺手。 下载：https://code.visualstudio.com/b?utm_expid=101350005-21.ckupCbvGQMiML5eJsxWmxw.1&amp;utm_referrer=https%3A%2F%2Fwww.microsoft.com%2Fnet%2Fcore 装完后用VS Code打开hwapp文件夹，如下图所示： 安装VS Code的C#扩展 打开VS Code，按快捷键：Command+p，在弹出的输入框里输入ext install csharp，在搜索出来的下拉框里选第一个C# 安装完C#的扩展插件后让我们打开Program.cs这个文件编辑一下吧。这个时候已经有C#标准的代码着色，跟智能提示了，如下图所示： 调试程序 在调试之前能，我们需要配置luanch.json文件。 luanch.json是用来描述Debugger的配置的文件。 我们主要是需要修改program属性的设置，其实就是当前可执行文件的Path，注意在Mac下没有exe，编译后是dll，如下图所示： “${workspaceRoot}/bin/Debug/netcoreapp1.0/hwapp.dll”配置好后我们就可以开始正式调试程序了。 VSCode的左侧边栏有一只虫子样的图标，点击后切换到调试模式，VS Code中下断点跟VS里一样，在代码行的最左边点击一下，出现一个红点，表示下断点成功。 在绿色箭头旁边的下拉框选择.NET Core Launch (Console)控制台调试模式。点击绿色的箭头就可以开始调试啦，如果有断点的话代码就会停止在断点位置 使用方式跟VS基本一致，F5执行，F10单步跳过，F11单步调试，鼠标悬停在变量上可以查看值，监控变量等等。(Mac上可能会出现热键冲突)； ","link":"https://shineyangpro.com/post/mac-xia-shi-yong-visual-studio-code-diao-shi-ckong-zhi-tai-cheng-xu-yi-ji-xiang-guan-de-pei-zhi-2/"},{"title":"iOS中比较当前日期与指定日期大小","content":"1、首先获取当前日期NSDate形式，指定一个日期格式 #pragma mark -得到当前时间 +(NSDate *)getCurrentTime{ NSDateFormatter *formatter=[[NSDateFormatter alloc]init]; [formatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *dateTime=[formatter stringFromDate:[NSDate date]]; NSDate *date = [formatter dateFromString:dateTime]; NSLog(@&quot;---------- currentDate == %@&quot;,date); return date; } 2、然后将指定日期（此处以2016-09-30-00点为例）转换为同样日期格式，返回NSDate形式 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSDate *date = [dateFormatter dateFromString:@&quot;30-09-2016-000000&quot;]; 3、最后进行比较，将现在的时间与指定时间比较，如果没达到指定日期，返回-1，刚好是这一时间，返回0，否则返回1 +(int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay { NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; NSLog(@&quot;date1 : %@, date2 : %@&quot;, oneDay, anotherDay); if (result == NSOrderedDescending) { //NSLog(@&quot;Date1 is in the future&quot;); return 1; } else if (result == NSOrderedAscending){ //NSLog(@&quot;Date1 is in the past&quot;); return -1; } //NSLog(@&quot;Both dates are the same&quot;); return 0; } 4、调用 [self compareOneDay:[self getCurrentTime] withAnotherDay:date] ","link":"https://shineyangpro.com/post/ios-zhong-bi-jiao-dang-qian-ri-qi-yu-zhi-ding-ri-qi-da-xiao/"},{"title":"Swift 时间转换成今天、明天、昨天","content":"func dayDifference(from interval : TimeInterval) -&gt; String { let calendar = NSCalendar.current let date = Date(timeIntervalSince1970: interval) if calendar.isDateInYesterday(date) { return &quot;Yesterday&quot; } else if calendar.isDateInToday(date) { return &quot;Today&quot; } else if calendar.isDateInTomorrow(date) { return &quot;Tomorrow&quot; } else { let startOfNow = calendar.startOfDay(for: Date()) let startOfTimeStamp = calendar.startOfDay(for: date) let components = calendar.dateComponents([.day], from: startOfNow, to: startOfTimeStamp) let day = components.day! if day &lt; 1 { return &quot;\\(abs(day)) days ago&quot; } else { return &quot;In \\(day) days&quot; } } } ","link":"https://shineyangpro.com/post/swift-shi-jian-zhuan-huan-cheng-jin-tian-ming-tian-zuo-tian/"},{"title":"Xcode11以后新变化：SceneDelegate","content":"Xcode11后，运行旧项目，相安无事，心里捏了一把汗，终于没有跟往年那样一更新就给你一大堆报错了。刚才突发奇想，使用Xcode11新建iOS项目时,如果你跟往常一样在Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建根控制器，会崩溃报错： Appdelegate找不到设置window的方法。 然后发现Xcode自动新增了一个SceneDelegate文件，查找了一下官方文档WWDC2019：Optimizing App Launch 发现，iOS13中appdelegate的职责发现了改变： iOS13之前，Appdelegate的职责全权处理App生命周期和UI生命周期； iOS13之后，Appdelegate的职责是： 1、处理 App 生命周期 2、新的 Scene Session 生命周期 那UI的生命周期呢？交给新增的Scene Delegate处理 用图表示就是： iOS13之前： 这种模式完全没问题，因为只有一个进程，只有一个与这个进程对应的用户界面 但是iOS13之后，Appdelegate不在负责UI生命周期，所有UI生命周期交给SceneDelegate处理： 因此初始化window方法需要改变： 现在不再Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions进行初始化，转交给SceneDelegate的willConnectToSession:方法进行根控制器设置： - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions { UIWindowScene *windowScene = (UIWindowScene *)scene; self.window = [[UIWindow alloc] initWithWindowScene:windowScene]; self.window.frame = windowScene.coordinateSpace.bounds; self.window.rootViewController = [UITabBarController new]; [self.window makeKeyAndVisible]; } ","link":"https://shineyangpro.com/post/xcode11-yi-hou-xin-bian-hua-scenedelegate/"},{"title":"如何修改Mac自带PHP版本，php-v和phpinfo两个不同的版本","content":"find / -name php.ini 得出两个ini /usr/local/php/etc/php.ini /etc/php.ini php -i | grep php.ini 查看PHP加载的是哪个配置文件,这个获取的是系统内的php.ini 的位置。不是网页apache加载的php.ini文件 查找一下系统里的PHP目录相关的东西 find / -name php /usr/bin/php -v 再环境变量里加上要使用的PHP的路径 vim /etc/profile 在文档最后，添加: export PATH=&quot;/usr/local/php/bin:$PATH&quot; 保存，退出，然后运行： source /etc/profile 如果profile这里添加成功后不能退出，请执行这个命令： :w !sudo tee % 解释： :w – write !sudo – call shell sudo command tee – the output of write (:w) command is redirected using tee % – current file name 参考文章https://stackoverflow.com/questions/28635647/how-can-i-save-a-file-i-opened-in-vim-as-the-wrong-user ","link":"https://shineyangpro.com/post/ru-he-xiu-gai-mac-zi-dai-php-ban-ben-php-v-he-phpinfo-liang-ge-bu-tong-de-ban-ben/"},{"title":"Apple美区官网购买礼品兑换充值卡（iTunes Gift Card ）","content":" 第一步：购买地址 点击我购买 第二步 填写购买信息 第三步：登陆 apple ID 第四步：填写支付信息 第五步：获取礼品兑换码 可以直接点击，会直接跳转到ituens,如果没跳转，可以鼠标右键复制链接的方式来获得兑换码 复制到记事本 第六步：在手机上输入兑换码 ","link":"https://shineyangpro.com/post/apple-mei-qu-guan-wang-gou-mai-li-pin-dui-huan-chong-zhi-qia-itunes-gift-card/"},{"title":"Xcode11 使用终端上传ipa","content":" 升级 Xcode 11 后, Xcode 删掉了 Application loader工具，使用 Xcode自带的上传功能，太卡，经常停留在进度条不动，于是便通过终端-&gt; xcrun altool上传。 整个过程5分钟内搞定，命令不多，就两个 校验 和 上传 校验 ipa xcrun altool --validate-app -f xxxx.ipa -t ios --apiKey xxxx --apiIssuer xxxx --verbose 上传 ipa xcrun altool --upload-app -f xxxx.ipa -t ios --apiKey xxxxx --apiIssuer xxxxx--verbose 上面一个命令，区别只在于， 校验是 validate-app , 上传是 upload-appxxxx.ipa 是 ipa文件的绝对路径 (以防万一，最好写绝对)apiKey xxxx 此处的 xxxx为 apiKey的值，获取方法见下面apiIssuer xxxx 此处的 xxxx为 apiIssuer的值，获取方法见下面 获取方式 1、进入开发者后台 -&gt; 用户和访问 2、apiKey 即密钥ID 3、 apiIssuer 即 Issuer ID 上传成功 要把开发者中心的密钥文件下载到电脑上，最好是放到用户的目录下面/用户/xxx ","link":"https://shineyangpro.com/post/xcode11-shi-yong-zhong-duan-shang-chuan-ipa/"},{"title":"Swift 把 1234656转化成 1.23万 或1.23亿 或 1 万 ，1亿","content":"extension Float { /** 战斗力值转换 */ var combatValues: String { if (self / 10000) &gt; 1 { let temp = self / 10000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;万&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;万&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;万&quot; } return str + &quot;万&quot; } } if (self / 100000000) &gt; 1 { let temp = self / 100000000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;亿&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;亿&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;亿&quot; } return str + &quot;亿&quot; } } let decimal = String.init(self).componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;0&quot; { return decimal[0] } return String.init(self) } } 字符串扩展 extension String { func attributedString(font:CGFloat)-&gt;NSMutableAttributedString{ let attributedS = NSMutableAttributedString(string: self) if self.containsString(&quot;万&quot;) || self.containsString(&quot;亿&quot;) { let normalAttributes = [NSFontAttributeName:UIFont.systemFontOfSize(font)] attributedS.addAttributes(normalAttributes, range: NSMakeRange(self.characters.count - 1,1)) } return attributedS } } 调用：label.attributedText = Float(number).combatValues ","link":"https://shineyangpro.com/post/swift-ba-1234656-zhuan-hua-cheng-123-wan-huo-123-yi-huo-1-wan-1-yi/"},{"title":"macOS Catalina (macOS 10.15) 已损坏无法打开解决办法","content":"最近有很多小伙伴更新系统后，提示“已损坏无法打开”的情况，按照以往的方法，在系统的“安全与隐私”中已经允许了“任何来源”，但还是一样打不开，怎么办呢？ App 在 macOS Catalina下提示已损坏无法打开解决办法： 1、在系统的“安全与隐私”中允许“任何来源”，再打开终端。 2、输入以下命令: sudo xattr -d com.apple.quarantine /Applications/xxxx.app 注意：Applications/xxxx.app 换成你的App路径或在sudo xattr -d com.apple.quarantine 后将软件拖进去即可。 3、最后，重启App即可。 ","link":"https://shineyangpro.com/post/macos-catalina-macos-1015-yi-sun-pi-wu-fa-da-kai-jie-jue-ban-fa/"},{"title":"Mac下配置Go开发环境","content":"Go（又称 Golang）是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go 的语法接近 C 语言，可以进行网络编程、系统编程、并发编程、分布式编程。 下面演示如何在 Mac 电脑上搭建 Go 语言开发环境。 1，安装 Golang 的 SDK 在官网下载对应的开发工具GoLand,地址如下:https://golang.org/dl/ 2，配置环境变量 （1）在终端执行如下命令进入用户主目录： cd ~ （2）执行如下命令打开 .bash_profile 文件： vim .bash_profile （3）按下 i 进入编辑模式，在文件末尾添加如下内容（GOPATH地址是自己创建项目的地址，比如我的是在桌面的文件夹下创建的）： export GOPATH=/Users/yangchen/Desktop/ReactNatve/Go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN （4）按下 ESC 键，然后输入 :wq 保存并退出编辑。 （5）接着执行如下命令让配置生效。 source ~/.bash_profile 最后我们执行 go env 查看配置结果，可以看到 GO 的环境变量已成功配置了。 ","link":"https://shineyangpro.com/post/mac-xia-pei-zhi-go-kai-fa-huan-jing/"},{"title":"Swift  从子视图跳转到指定tabBar主界面","content":"从tabbar的子页面跳转到指定的tabbar主页面,话不多说直接上代码: self.navigationController?.tabBarController?.selectedIndex = 0 self.navigationController?.popViewController(animated: false) ","link":"https://shineyangpro.com/post/swift-cong-zi-shi-tu-tiao-zhuan-dao-zhi-ding-tabbar-zhu-jie-mian/"},{"title":"Swift UICollectionView横向分页滚动，cell左右排版","content":"废话不多说，直接上代码 自定义一个SYitemViewLayout，继承UICollectionViewFlowLayout mport UIKit //根据需求设置列跟行 let kEmotionCellNumberOfOneRow = 3 let kEmotionCellRow = 2 class SYitemViewLayout: UICollectionViewFlowLayout { // 保存所有item fileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] // MARK:- 重新布局 override func prepare() { super.prepare() let itemWH: CGFloat = (kScreenWitdh - 30) / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH - 50) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true // let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 // collectionView?.contentInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10) var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount { let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * (kScreenWitdh - 30)) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) } } override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? { var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map({ if rect.contains($0.frame) { rectAttributes.append($0) } }) return rectAttributes } } ","link":"https://shineyangpro.com/post/swift-uicollectionview-heng-xiang-fen-ye-gun-dong-cell-zuo-you-pai-ban/"},{"title":"Swift框架-章：1、开发一个Swift框架","content":"Swift已成为一种流行的编程语言，并且每天都在发展。 开发Swift框架具有以下优点。 隐藏您的代码实现。 由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 开发Swift框架具有以下优点。 1、隐藏您的代码实现。 2、由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 使用的工具：XCode 11.6 +，Swift 5.1+ 步骤1：-安装框架项目 1、创建新的XCode项目。 2、 创建框架 为您的项目命名，我们使用了类似于Alamofire的AlamoWater名字。 （请确保选择语言-Swift） 单击目标内的AlamoWater文件夹，然后按⌘+N。 选择文件名AlamoWater和以下子类：NSObject 在AlameWater.swift中添加以下代码**。** **注意：-**确保您的类和方法设置为Public import UIKit public protocol AlamoWaterProtocol { func didCallHello() } open class AlamoWater: NSObject { public static let shared = AlamoWater() public var delegate:AlamoWaterProtocol? open func hello(){ debugPrint(&quot;Hello from AlamoWater!&quot;) AlamoWater.shared.delegate?.didCallHello() } } 要为iOS设备和模拟器创建框架，请向您的项目添加新的Aggregate目标。 并添加[运行脚本] #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # make sure the output directory exists mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # Step 1. Build Device and Simulator versions xcodebuild -target &quot;AlamoWater&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build xcodebuild -target &quot;AlamoWater&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build # Step 2. Copy the framework structure (from iphoneos build) to the universal folder cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/&quot; # Step 3. Copy Swift modules from iphonesimulator build (if it exists) to the copied framework directory SIMULATOR_SWIFT_MODULES_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/Modules/AlamoWater.swiftmodule/.&quot; if [ -d &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; ]; then cp -R &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/Modules/AlamoWater.swiftmodule&quot; fi # Step 4. Create universal binary file using lipo and place the combined executable in the copied framework directory lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework/AlamoWater&quot; # Step 5. Convenience step to copy the framework to the project's directory cp -R &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework&quot; &quot;${PROJECT_DIR}&quot; # Step 6. Convenience step to open the project's directory in Finder open &quot;${PROJECT_DIR}&quot; 注意：AlamoWater改为自己项目的名字 通过按⌘+ B选择UniversalAlamoWater目标来构建您的第一个框架 构建完成后，您将看到Finder与其中的Framework一起打开。 注意：-如果出现以下错误， … Reason: image not found 确保在嵌入式二进制文件和链接的框架和库中都添加了框架 ","link":"https://shineyangpro.com/post/swift-kuang-jia-zhang-1kai-fa-yi-ge-swift-kuang-jia/"},{"title":"Go实战项目【一】Golang和Gin框架的安装和使用","content":"Golang的安装 根据所使用的电脑操作系统，下载相对应的版本Golang 下载 比如我的电脑是macOS系统，下载的是 安装完毕后配置路径 打开终端，执行: vi ~/.bash_profile .bash_profile 添加的内容如下： #Go export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 然后执行 source ~/.bash_profile 让配置生效 执行 go version 查看Golang是否安装成功，出现以下信息即为安装成功 初始化项目目录 选一个你自己喜欢的路径，创建一个文件夹，比如我的是/Users/newmac/Documents/Go-app这个文件夹下 cd /Users/newmac/Documents/Go-app mkdir api &amp;&amp; cd api go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go mod init api mkdir api &amp;&amp; cd api：创建并进入api文件夹 go env -w GO111MODULE=on：开启Go modules go env -w GOPROXY=https://goproxy.cn,direct：设置 GOPROXY 代理，也可以把GOPROXY写入.bash_profile中 go mod init [MODULE_PATH]：初始化 Go modules，它将会生成 go.mod 文件，MODULE_PATH 填写的是模块引入路径，如果想要把项目放到Github上，可以填写GitHub的项目路径，这个根据自己情况填写。 然后就会在api文件夹下出现go.mod文件 安装Gin框架 在api文件夹下，执行 go get -u github.com/gin-gonic/gin 安装完毕后，创建一个test.go文件，测试下Gin框架是否能使用test.go 我用的是GoLang开发工具，可以直接在编译器里面执行 如果用的是VS code，可以在终端运行:go run test.go 在浏览器打开127.0.0.1:8080/ping这个地址，可以看到有返回的数据，代表Gin框架安装和使用成功。 Go相关学习知识 ","link":"https://shineyangpro.com/post/go-shi-zhan-xiang-mu-yi-golang-he-gin-kuang-jia-de-an-zhuang-he-shi-yong/"},{"title":"清理Xcode占用的Mac硬盘空间","content":"主要是操作两个目录下的文件 ~/Library/Developer/Xcode 和 ~/Library/Developer/CoreSimulator ~/Library/Developer/Xcode 1、DerivedData 此文件夹内的每个目录是Xcode运行每个APP时生成的缓存文件，删除之后再运行APP会重新生成该APP对应的文件，只是编译时间变长了。 可保留近期运行的APP相关的文件夹，对于以前运行过近期不再使用的APP，例如网上下载的demo，建议清理。 Archives 此文件夹中的内容对应Xcode-&gt;Window-&gt;Organizer-&gt;Archives中列出的打包文件。 可保留有用的打包文件，其它删除。 iOS DeviceSupport 此文件夹存放的是Xcode对你所连接真机的版本支持，每个文件夹几乎都是几个G的大小（我个人的情况是11个目录占了26G空间），手机每升级一个版本，再次连接Xcode时，这里都会生成一个目录。 建议保留你手机当前版本的文件夹。全部删除也没关系，手机再次连接Xcode时会重新生成。 2. ~/Library/Developer/CoreSimulator Devices 此文件夹下的目录是以模拟器的UDID命名的，运行模拟器时每安装一个新的APP，相应的文件夹内容也会增大，就像手机上安装应用会占用手机空间一样。 可删除全部文件夹。再次运行模拟器，会重新生成。 删除后开启Xcode运行模拟器，可能会出现下面的错误，不要惊慌，重启Xcode就好了。 建议在退出Xcode后进行清理，清理后重启电脑 ","link":"https://shineyangpro.com/post/qing-li-xcode-zhan-yong-de-mac-ying-pan-kong-jian/"},{"title":"iOS 13：Swift以编程方式设置应用程序根视图控制器不起作用","content":"在iOS以后直接使用window?.makeKeyAndVisible()是不起作用的，正确用法是: static func redirectToMainNavRVC(currentVC: UIViewController){ let appDelegate = UIApplication.shared.delegate as! AppDelegate let vc = UIStoryboard(name: appDelegate.storyBoardName, bundle: nil).instantiateViewController(withIdentifier: &quot;MainNavigationViewController&quot;) as! MainNavigationViewController if #available(iOS 13.0, *){ if let scene = UIApplication.shared.connectedScenes.first{ guard let windowScene = (scene as? UIWindowScene) else { return } print(&quot;&gt;&gt;&gt; windowScene: \\(windowScene)&quot;) let window: UIWindow = UIWindow(frame: windowScene.coordinateSpace.bounds) window.windowScene = windowScene //Make sure to do this window.rootViewController = vc window.makeKeyAndVisible() appDelegate.window = window } } else { appDelegate.window?.rootViewController = vc appDelegate.window?.makeKeyAndVisible() } } ","link":"https://shineyangpro.com/post/ios-13swift-yi-bian-cheng-fang-shi-she-zhi-ying-yong-cheng-xu-gen-shi-tu-kong-zhi-qi-bu-qi-zuo-yong/"}]}