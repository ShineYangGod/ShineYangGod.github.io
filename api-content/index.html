{"posts":[{"title":"Navicat Premium 15.0.22 强大的数据库管理工具(Big Sur 可用)","content":" Navicat Premium是一个可多重连接的数据库管理工具，Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器的新手来说又相当容易学习。它可让你以单一程序同時连接到目前世面上所有版本的主流数据库并进行管理和操作，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL。让管理不同类型的数据库更加方便。 应用介绍 Navicat Premium 结合了其他 Navicat 成员的功能。有了不同数据库类型的连接能力，Navicat Premium 支持在 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 之间传输数据。包括存储过程，事件，触发器，函数，视图等。 Navicat Premium 适用于三种平台 - Microsoft Windows、Mac OS X 及 Linux。它可以让用户连接本机或远程服务器、提供一些实用的数据库工具如数据模型工具、数据同步、结构同步、导入、导出、备份、还原及报表以协助管理数据。 下载 点我传送 推荐 如果上面的打不开，可以使用百度网盘下载点我下载 提取码:pdt8 ","link":"https://shineyangpro.com/navicat-premium-15022-qiang-da-de-shu-ju-ku-guan-li-gong-ju-big-sur-ke-yong/"},{"title":"Swift-如何实现Cell可收起和展开","content":"这是一个简单的iOS swift项目，旨在介绍如何实现可收起和展开的table section，并且，项目不需要main storyboard, XIB, 注册nib等，只需要纯的Swfit代码！ 项目源代码 如果你希望获得Swift 3.0的代码，可以在migrate-to-swift-3.0分支里找到, 最终将会汇入master分支。 效果 如何实现可收起和展开的Table Section? 第一步. 准备数据 假设我们有如下的数据，它已经按照不同的section进行组织和整理，每个section都是一个Section结构（或对象）： struct Section { var name: String! var items: [String]! var collapsed: Bool! init(name: String, items: [String], collapsed: Bool = false) { self.name = name self.items = items self.collapsed = collapsed } } var sections = [Section]() sections = [ Section(name: &quot;Mac&quot;, items: [&quot;MacBook&quot;, &quot;MacBook Air&quot;, &quot;MacBook Pro&quot;, &quot;iMac&quot;, &quot;Mac Pro&quot;, &quot;Mac mini&quot;, &quot;Accessories&quot;, &quot;OS X El Capitan&quot;]), Section(name: &quot;iPad&quot;, items: [&quot;iPad Pro&quot;, &quot;iPad Air 2&quot;, &quot;iPad mini 4&quot;, &quot;Accessories&quot;]), Section(name: &quot;iPhone&quot;, items: [&quot;iPhone 6s&quot;, &quot;iPhone 6&quot;, &quot;iPhone SE&quot;, &quot;Accessories&quot;]) ] collapsed表示当前的section是否被收起或展开，默认下是false，即展开。 第二步. Section Header 根据苹果 API reference, 我们应该使用UITableViewHeaderFooterView. 让我们创建一个section header的类来继承它，我们把这个section header类起名为CollapsibleTableViewHeader: class CollapsibleTableViewHeader: UITableViewHeaderFooterView { let titleLabel = UILabel() let arrowLabel = UILabel() override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) contentView.addSubview(titleLabel) contentView.addSubview(arrowLabel) } required init?(coder aDecoder: NSCoder) { fatalError(&quot;init(coder:) has not been implemented&quot;) } } 当用户点击section header的时候我们需要收起或者展开这个section，为了实现这样的效果，让我们借用一下UITapGestureRecognizer. 同时我们需要将这个tap事件通知给table view并让它来更新section的collapsed值。 protocol CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) } class CollapsibleTableViewHeader: UITableViewHeaderFooterView { var delegate: CollapsibleTableViewHeaderDelegate? var section: Int = 0 ... override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) ... addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(CollapsibleTableViewHeader.tapHeader(_:)))) } ... func tapHeader(gestureRecognizer: UITapGestureRecognizer) { guard let cell = gestureRecognizer.view as? CollapsibleTableViewHeader else { return } delegate?.toggleSection(self, section: cell.section) } func setCollapsed(collapsed: Bool) { // Animate the arrow rotation (see Extensions.swf) arrowLabel.rotate(collapsed ? 0.0 : CGFloat(M_PI_2)) } } 既然我们不用任何storyboard或者XIB，如何实现自动布局呢？答案是运用NSLayoutConstraint的constraintsWithVisualFormat函数。 override init(reuseIdentifier: String?) { ... // arrowLabel must have fixed width and height arrowLabel.widthAnchor.constraintEqualToConstant(12).active = true arrowLabel.heightAnchor.constraintEqualToConstant(12).active = true titleLabel.translatesAutoresizingMaskIntoConstraints = false arrowLabel.translatesAutoresizingMaskIntoConstraints = false } override func layoutSubviews() { super.layoutSubviews() ... let views = [ &quot;titleLabel&quot; : titleLabel, &quot;arrowLabel&quot; : arrowLabel, ] contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;H:|-20-[titleLabel]-[arrowLabel]-20-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[titleLabel]-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[arrowLabel]-|&quot;, options: [], metrics: nil, views: views )) } 第三步. UITableView DataSource 以及 Delegate 首先，sections的数量为sections.count: override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return sections.count } 每个section里面cell的数量为: override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return sections[section].items.count } 接下来使用tableView的viewForHeaderInSection函数来渲染我们的section header: override func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { let header = tableView.dequeueReusableHeaderFooterViewWithIdentifier(&quot;header&quot;) as? CollapsibleTableViewHeader ?? CollapsibleTableViewHeader(reuseIdentifier: &quot;header&quot;) header.titleLabel.text = sections[section].name header.arrowLabel.text = &quot;&gt;&quot; header.setCollapsed(sections[section].collapsed) header.section = section header.delegate = self return header } 普通的cell就很简单了，没什么好说的： override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) as UITableViewCell? ?? UITableViewCell(style: .Default, reuseIdentifier: &quot;cell&quot;) cell.textLabel?.text = sections[indexPath.section].items[indexPath.row] return cell } 最后一步. 如何收起和展开？ 思路超级简单！如果该section的collapsed值为true, 我们就将这个section里所有cell的高度都设为0, 否则为 44.0! override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat { return sections[indexPath.section].collapsed! ? 0 : 44.0 } 切换收起和展开的函数如下: extension CollapsibleTableViewController: CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) { let collapsed = !sections[section].collapsed // Toggle collapse sections[section].collapsed = collapsed header.setCollapsed(collapsed) // Adjust the height of the rows inside the section tableView.beginUpdates() for i in 0 ..&lt; sections[section].items.count { tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: i, inSection: section)], withRowAnimation: .Automatic) } tableView.endUpdates() } } 注意到我们不是简单的重绘整个section，实际上我们只需要重绘section里的所有cell就好, 这样做的好处是避免了section header因重绘时闪烁的效果, 最重要是的可以让我们更平滑地处理我们想要的动画效果, 例如旋转那个箭头，改变背景颜色等等。 好了就这么多吧，如果你很感兴趣，请参考源码。 更多的关于table section收起和展开的项目 有时候你可能想要在grouped-style的table里实现section的收起和展开, 我写了另外一个Dome 实现的方法其实很类似。 ","link":"https://shineyangpro.com/swift-ru-he-shi-xian-cell-ke-shou-qi-he-zhan-kai/"},{"title":"构建更好的iOS App动画","content":" 动画是高质量用户体验的关键。它们具有多种用途，包括引导用户的注意力并将用户的操作与屏幕上的结果联系起来。 动画使您的应用程序体验独具特色-它们可以使其他媒体无法实现的响应性和交互性达到一定水平。为了制作更好的动画，他们需要传达一种更好的用户交互和视觉变化之间的直接联系感。实现此目的的一种方法是使动画完全互动。 为什么要创建互动动画？ 自从iPhone推出以来，互动动画就已经出现。世界上首次看到原始iPhone的是经典的“滑动解锁”屏幕，用户可以在其中直接移动滑块以解锁设备。对于以前从未使用过多点触摸设备的用户而言，此交互式动画立即直观。 交互式动画使用户可以更好地控制用户界面。直接操纵是自然的交互模型，尤其是在移动设备上。它将他们的动作连接到屏幕上的动画，并让他们完全控制其动作的完成或取消。 他们看起来也很棒。用户通常将应用程序的外观与应用程序的性能相关联，因此，如果应用程序看起来不错，则他们更有可能原谅其他缺点。 在本教程中，我们将使用来在Swift中构建一个交互式弹出动画UIViewPropertyAnimator。 UIViewPropertyAnimator简介 UIViewPropertyAnimator 已在iOS 10中添加到UIKit，并在iOS 11中进行了一些改进。它提供了UIView级别的面向对象的API来创建动画。 使用传统UIView动画，您可以编写如下内容： UIView.animate(withDuration: 1, delay: 0, options: [.curveEaseOut], animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }, completion: nil) 使用new UIViewPropertyAnimator，您可以编写以下代码： let animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut, animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }) animator.startAnimations() 代码非常相似。使用UIViewPropertyAnimator，您首先创建一个动画设计器对象，然后调用startAnimation()而不是在UIView类上调用静态方法。 随着动画复杂性的增加，UIViewPropertyAnimator变得更加有用。让我们看一个更复杂的动画。 该动画在平移视图时开始，可以在任一方向上进行擦洗，并且在平移完成后会动画到其最终位置。 在查看代码之前，了解状态机支持很重要UIViewPropertyAnimator。 动画师可以处于三种可能的状态之一：不活动，活动和停止。动画器初始化为非活动状态，但在启动或暂停时会移动到活动状态。动画完成后，它将返回到非活动状态。如果动画已开始且已暂停，则动画将保持活动状态，并且不会进行状态转换。 让我们看看如何使用UIPanGestureRecognizer旁边的UIViewPropertyAnimator来创建上面的动画。 var animator = UIViewPropertyAnimator() private func handlePan(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animator = UIViewPropertyAnimator(duration: 3, curve: .easeOut, animations: { myView.transform = CGAffineTransform(translationX: 275, y: 0) myView.alpha = 0 }) animator.startAnimation() animator.pauseAnimation() case .changed: animator.fractionComplete = recognizer.translation(in: myView).x / 275 case .ended: animator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 请注意，pauseAnimation()在之后立即调用startAnimation()。因为我们的动画是从平移手势开始的，所以用户最有可能先松开动画，然后再释放其点击。动画暂停时，设置fractionComplete属性以将视图与用户的触摸一起移动。 如果我们尝试使用标准UIView动画执行此操作，则将需要比上面示例中列出的逻辑更多的逻辑。UIView动画无法提供直接控制动画完成百分比的简便方法，也无法让我们轻松地暂停并继续动画直到完成。 让我们建立一个弹出菜单！ 我们将分十步构建一个完全交互式，可中断，可擦除和可逆的弹出菜单。（如果您希望从最终代码开始进行反向操作，则可以在本文末尾找到指向最终存储库的链接。） 为了简单起见，所有视图都将在代码中创建和修改（而不是在故事板中，尽管此代码与在故事板上创建的视图同样适用）。同样，所有代码都将放置在ViewController.swift文件中。 步骤＃1：点击以打开和关闭。 首先，让我们的弹出视图在打开状态和关闭状态之间进行动画处理。这里没有花哨的技巧，只是UIViewPropertyAnimator我们之前学习的基础知识。 private enum State { case closed case open } extension State { var opposite: State { switch self { case .open: return .closed case .closed: return .open } } } class ViewController: UIViewController { private lazy var popupView: UIView = { let view = UIView() view.backgroundColor = .gray return view }() override func viewDidLoad() { super.viewDidLoad() layout() popupView.addGestureRecognizer(tapRecognizer) } private var bottomConstraint = NSLayoutConstraint() private func layout() { popupView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(popupView) popupView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true popupView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true bottomConstraint = popupView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: 440) bottomConstraint.isActive = true popupView.heightAnchor.constraint(equalToConstant: 500).isActive = true } private var currentState: State = .closed private lazy var tapRecognizer: UITapGestureRecognizer = { let recognizer = UITapGestureRecognizer() recognizer.addTarget(self, action: #selector(popupViewTapped(recognizer:))) return recognizer }() @objc private func popupViewTapped(recognizer: UITapGestureRecognizer) { let state = currentState.opposite let transitionAnimator = UIViewPropertyAnimator(duration: 1, dampingRatio: 1, animations: { switch state { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } self.view.layoutIfNeeded() }) transitionAnimator.addCompletion { position in switch position { case .start: self.currentState = state.opposite case .end: self.currentState = state case .current: () } switch self.currentState { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } } transitionAnimator.startAnimation() } } popupViewTapped函数中有相关的动画代码，在点击视图时会调用该动画。我们只需创建一个动画师，设置其动画以修改约束的值，然后启动动画师。 我们引入一个State枚举来指示弹出窗口是打开还是关闭。它还具有计算opposite属性，该属性返回与当前状态相反的状态。我们本来可以用布尔标志来实现，但这更容易推论，尤其是当我们的动画代码变得更加复杂时。 需要指出的一件事-当动画完成时，我们正在手动更新约束的值。这应该由动画师自动处理，但是显式设置它们可以修复一些边缘错误。 步骤2：添加平移手势。 为了使动画具有交互性，我们将引入第二个手势识别器，即平移手势识别器。这将允许用户通过在弹出视图上滑动来开始和中断动画。 @objc private func popupViewPanned(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animateTransitionIfNeeded(to: currentState.opposite, duration: 1.5) transitionAnimator.pauseAnimation() case .changed: let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } transitionAnimator.fractionComplete = fraction case .ended: transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 该代码与前面的示例非常相似，不同之处在于可以中断动画。我们已经将动画代码重构为一个名为的函数animateTransitionIfNeeded，该函数可以运行该popupViewTapped函数内部以前的所有代码。 步骤＃3：记录动画进度以修复中断偏移。 一个问题：当动画被中断时，它会偏离用户的触摸。这是由于平移处理程序未考虑动画的当前进度。要解决此问题，我们需要记录fractionComplete动画师的，并在计算平移偏移时将其用作基线。 我们将需要一个属性来存储动画的当前进度： private var animationProgress: CGFloat = 0 当平移手势处于其began状态时，我们记录动画的当前进度： animationProgress = transitionAnimator.fractionComplete 在平移手势的changed状态下，我们将动画进度添加到计算的分数中： transitionAnimator.fractionComplete = fraction + animationProgress 现在，平移手势可以按预期工作，并且可以更自然地跟踪用户的手指。 注意：为了对a进行子类化UIGestureRecognizer，您需要在文件顶部包含此导入： import UIKit.UIGestureRecognizerSubclass 步骤＃5：使用平移速度反转动画。 剩下的一个问题是，弹出窗口不考虑视图的“抛出”方式。如果我们点击关闭的弹出窗口，在动画中期捕获它，然后向下滑动，它将继续对打开的动画进行动画处理。 为了解决这个问题，我们可以有条件地反转动画师。这将基于以下几个因素：弹出窗口的当前状态，动画器当前是否反转以及平移手势的速度。 ended现在，平移手势处理程序的情况如下所示： let yVelocity = recognizer.velocity(in: popupView).y let shouldClose = yVelocity &gt; 0 if yVelocity == 0 { transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) break } switch currentState { case .open: if !shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } case .closed: if shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if !shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } } transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) 这种逻辑乍一看似乎很复杂，但是可以通过考虑所有可能的情况来得出。 在平移手势处理程序发生更改的情况下，我们需要尊重isReversed动画设计器的属性： let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } if transitionAnimator.isReversed { fraction *= -1 } transitionAnimator.fractionComplete = fraction + animationProgress 现在我们的动画可以反转了！如果用户希望在动画中关闭弹出窗口，则这样做很容易直观。 步骤＃6：设置拐角半径的动画。 在iOS 11中，CALayer无需设置即可设置动画人物的拐角半径CABasicAnimation。这意味着我们可以在动画块中更新视图的角半径，它就可以工作！ self.popupView.layer.cornerRadius = 20 我们还可以指定圆角。在这种情况下，我们只希望对左上角和右上角进行圆角处理。 view.layer.maskedCorners = [.layerMaxXMinYCorner, .layerMinXMinYCorner] 现在，顶部的两个角与我们的原始动画一起被动画化。 步骤＃7：使其更漂亮！ 我们的灰色弹出视图效果很好，但可以进行一些视觉上的改进。让我们添加背景图像，叠加视图，标题标签，细微阴影和一些示例评论。 本教程将不介绍这些其他视图的实现。如果您想了解它们的创建方式，请在文章底部查看完整的源代码。 好多了。 😎 步骤＃8：对标签进行动画处理。 关闭弹出窗口时，“审阅”标签看起来不错，但是当打开时，它无法从其余内容中脱颖而出。打开弹出窗口时，我们希望为标签提供更大的字体大小和更深的颜色。由于我们的弹出窗口是完全交互式且可擦除的，因此需要对标签过渡进行动画处理。 没有内置的方式来设置标签的颜色或字体样式的动画。我们的解决方案是一个简单的解决方法：交叉淡化标签。 为了使动画平滑，我们需要对每个标签的比例和平移进行动画处理，以使它们在动画的整个过程中完美重叠。 在动画块内，我们修改标签的alpha和transform： switch state { case .open: // other animations here ... self.closedTitleLabel.transform = CGAffineTransform(scaleX: 1.6, y: 1.6).concatenating(CGAffineTransform(translationX: 0, y: 15)) self.openTitleLabel.transform = .identity self.openTitleLabel.alpha = 1 self.closedTitleLabel.alpha = 0 case .closed: // other animations here ... self.closedTitleLabel.transform = .identity self.openTitleLabel.transform = CGAffineTransform(scaleX: 0.65, y: 0.65).concatenating(CGAffineTransform(translationX: 0, y: -15)) self.openTitleLabel.alpha = 0 self.closedTitleLabel.alpha = 1 } 现在，标签看起来就像它们在彼此变形一样。正确对齐后，看起来只有一个标签。 步骤＃9：重构多个动画制作者。 标签动画效果很好，但是可以改善时间以进一步平滑过渡。为了修改标签动画的时序曲线，我们需要其他动画师。AUIViewPropertyAnimator只能有一条时序曲线，因此要使用多个时序曲线，我们需要协调多个动画制作者。 我们需要稍微重构代码以支持任意数量的动画制作者。为此，我们将创建一系列动画师。 private var runningAnimators = [UIViewPropertyAnimator]() 每当我们创建新的动画师时，我们都会将其添加到正在运行的动画师数组中。 runningAnimators.append(transitionAnimator) 每当动画结束时，我们都会将其从数组中删除。为了使其余代码可与多个动画师一起使用，应用于的所有内容transitionAnimator都将应用于整个数组。 步骤＃10：为标签alpha添加新的动画师。 借助新的基础架构，我们可以创建两个新的动画师：一个为新标签制作动画，另一个为旧标签制作动画。使用多个动画制作者的好处是每个动画制作者都有自己的时序曲线。 let inTitleAnimator = UIViewPropertyAnimator(duration: duration, curve: .easeIn, animations: { switch state { case .open: self.openTitleLabel.alpha = 1 case .closed: self.closedTitleLabel.alpha = 1 } }) inTitleAnimator.scrubsLinearly = false 我们将动画师的scrubsLinearly属性设置为false，以便fractionComplete动画的映射到缓动时序曲线，而不是线性时序曲线。通常，跟随用户手指的动画应遵循线性时序曲线，这就是为什么此属性默认为true的原因。 （注意：scrubsLinearly仅在iOS 11+上可用） 两者之间的差异很小，但可以在以后进一步自定义动画。当用户完全控制动画并可以将其拖到任何位置时，正确实现此过渡非常重要。 这是我们的最终动画！用户可以通过轻击或滑动开始动画，可以中断动画，并可以反转动画。相当少量的代码，很酷。 什么时候应该使用UIViewPropertyAnimator？ iOS中有如此众多的动画API，什么时候最好使用UIViewPropertyAnimator？ 差异是可中断性。如果要在飞行过程中“捕捉”视图，进行擦洗，然后继续或反转动画，UIViewPropertyAnimator则是最佳选择。其他一些动画策略是可中断的，例如在滚动视图的contentOffset属性旁边设置视图动画，但这些动画仅限于滚动视图的时序曲线。 有时，动画可中断是没有意义的。仅当用户可以在动画过程中点击视图时，才使动画可中断。动画应具有足够长的持续时间，以使用户可以足够快地做出反应以点击它，而动画视图应具有较大的点击目标。上面的弹出动画是满足这些要求的完美示例。 链接与资源 完整的源代码可在GitHub上找到：点我传送 ","link":"https://shineyangpro.com/gou-jian-geng-hao-de-ios-app-dong-hua/"},{"title":"ThinkPHP5.0路径中去除index.php入口文件方式","content":"1、httpd.conf配置文件中加载了mod_rewrite.so模块 //在APACHE里面去配置 #LoadModule rewrite_module modules/mod_rewrite.so把前面的警号去掉,如下图: 如果没有，可以自己添加进去（我的是没有，我自己添加进去的） 2、AllowOverride None 讲None改为 All （搜索到的全部改为All就好，小写的就改成小写的all） 3、确保URL_MODEL设置为2，在项目的配置文件里写 4、.htaccess文件必须放到跟目录下（没有就新建一个，TP5.0有自带(application这个文件夹)，可以拷贝出来，Mac下按command+Shift+.可以显示隐藏文件）在里面添加如下内容： &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/IfModule&gt; ","link":"https://shineyangpro.com/thinkphp50-lu-jing-zhong-qu-chu-indexphp-ru-kou-wen-jian-fang-shi/"},{"title":"Swift NSClassFromString初始化控制器","content":"在OC中我们反射是这样的： [[NSClassFromString(@&quot;Foo&quot;) alloc] init]; 但是在Swift中这种方式是不可用的，经过查找资料，琢磨，终于找到了方法 swift中的NSClassFromString是这样的： ","link":"https://shineyangpro.com/swift-nsclassfromstring-chu-shi-hua-kong-zhi-qi/"},{"title":"Mac下使用Visual Studio Code调试C#控制台程序以及相关的配置（2）","content":"安装.NET Core 在mac上打开终端输入以下命令: ~$ brew update ~$ brew install openssl ~$ brew link --force openssl 如果不能使用brew命令，先安装homebrew，玩转Mac必备。下载.NET Core SDK：https://go.microsoft.com/fwlink/?LinkID=80912下载完成后双击pkg安装，如下图所示：一路Next完成后.Net Core就在Mac上安装好了。 新建一个.NET Core的程序 打开Mac的终端： mkdir hwapp cd hwapp 然后创建一个简单控制台程序如：dotnet new console （创建控制台应用程序） 这几个命令是新建一个叫hwapp的目录然后在该目录下初始化一个项目，类似于用VS新建一个控制台项目，如下图所示： 运行一个程序 在终端定位到hwapp目录然后执行命令： dotnet restore dotnet run 这2个命令是说还原该项目的依赖，并且编译运行，输出Hello World， 安装Visual Studio Code Mac上没有宇宙第一IDE VS 那我们怎么写代码呢？别急，微软为了.NET Core的跨平台计划已经给我们开发了一款编辑器 VS Code。虽然VS Code没发布多久，但是个人觉得已经超越了Atom，Sublime Text等Mac上以前常用的编辑器。不光可以开发C#，而且调试Nodejs也是非常顺手。 下载：https://code.visualstudio.com/b?utm_expid=101350005-21.ckupCbvGQMiML5eJsxWmxw.1&amp;utm_referrer=https%3A%2F%2Fwww.microsoft.com%2Fnet%2Fcore 装完后用VS Code打开hwapp文件夹，如下图所示： 安装VS Code的C#扩展 打开VS Code，按快捷键：Command+p，在弹出的输入框里输入ext install csharp，在搜索出来的下拉框里选第一个C# 安装完C#的扩展插件后让我们打开Program.cs这个文件编辑一下吧。这个时候已经有C#标准的代码着色，跟智能提示了，如下图所示： 调试程序 在调试之前能，我们需要配置luanch.json文件。 luanch.json是用来描述Debugger的配置的文件。 我们主要是需要修改program属性的设置，其实就是当前可执行文件的Path，注意在Mac下没有exe，编译后是dll，如下图所示： “${workspaceRoot}/bin/Debug/netcoreapp1.0/hwapp.dll”配置好后我们就可以开始正式调试程序了。 VSCode的左侧边栏有一只虫子样的图标，点击后切换到调试模式，VS Code中下断点跟VS里一样，在代码行的最左边点击一下，出现一个红点，表示下断点成功。 在绿色箭头旁边的下拉框选择.NET Core Launch (Console)控制台调试模式。点击绿色的箭头就可以开始调试啦，如果有断点的话代码就会停止在断点位置 使用方式跟VS基本一致，F5执行，F10单步跳过，F11单步调试，鼠标悬停在变量上可以查看值，监控变量等等。(Mac上可能会出现热键冲突)； ","link":"https://shineyangpro.com/mac-xia-shi-yong-visual-studio-code-diao-shi-ckong-zhi-tai-cheng-xu-yi-ji-xiang-guan-de-pei-zhi-2/"},{"title":"iOS中比较当前日期与指定日期大小","content":"1、首先获取当前日期NSDate形式，指定一个日期格式 #pragma mark -得到当前时间 +(NSDate *)getCurrentTime{ NSDateFormatter *formatter=[[NSDateFormatter alloc]init]; [formatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *dateTime=[formatter stringFromDate:[NSDate date]]; NSDate *date = [formatter dateFromString:dateTime]; NSLog(@&quot;---------- currentDate == %@&quot;,date); return date; } 2、然后将指定日期（此处以2016-09-30-00点为例）转换为同样日期格式，返回NSDate形式 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSDate *date = [dateFormatter dateFromString:@&quot;30-09-2016-000000&quot;]; 3、最后进行比较，将现在的时间与指定时间比较，如果没达到指定日期，返回-1，刚好是这一时间，返回0，否则返回1 +(int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay { NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; NSLog(@&quot;date1 : %@, date2 : %@&quot;, oneDay, anotherDay); if (result == NSOrderedDescending) { //NSLog(@&quot;Date1 is in the future&quot;); return 1; } else if (result == NSOrderedAscending){ //NSLog(@&quot;Date1 is in the past&quot;); return -1; } //NSLog(@&quot;Both dates are the same&quot;); return 0; } 4、调用 [self compareOneDay:[self getCurrentTime] withAnotherDay:date] ","link":"https://shineyangpro.com/ios-zhong-bi-jiao-dang-qian-ri-qi-yu-zhi-ding-ri-qi-da-xiao/"},{"title":"Swift 时间转换成今天、明天、昨天","content":"func dayDifference(from interval : TimeInterval) -&gt; String { let calendar = NSCalendar.current let date = Date(timeIntervalSince1970: interval) if calendar.isDateInYesterday(date) { return &quot;Yesterday&quot; } else if calendar.isDateInToday(date) { return &quot;Today&quot; } else if calendar.isDateInTomorrow(date) { return &quot;Tomorrow&quot; } else { let startOfNow = calendar.startOfDay(for: Date()) let startOfTimeStamp = calendar.startOfDay(for: date) let components = calendar.dateComponents([.day], from: startOfNow, to: startOfTimeStamp) let day = components.day! if day &lt; 1 { return &quot;\\(abs(day)) days ago&quot; } else { return &quot;In \\(day) days&quot; } } } ","link":"https://shineyangpro.com/swift-shi-jian-zhuan-huan-cheng-jin-tian-ming-tian-zuo-tian/"},{"title":"Xcode11以后新变化：SceneDelegate","content":"Xcode11后，运行旧项目，相安无事，心里捏了一把汗，终于没有跟往年那样一更新就给你一大堆报错了。刚才突发奇想，使用Xcode11新建iOS项目时,如果你跟往常一样在Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建根控制器，会崩溃报错： Appdelegate找不到设置window的方法。 然后发现Xcode自动新增了一个SceneDelegate文件，查找了一下官方文档WWDC2019：Optimizing App Launch 发现，iOS13中appdelegate的职责发现了改变： iOS13之前，Appdelegate的职责全权处理App生命周期和UI生命周期； iOS13之后，Appdelegate的职责是： 1、处理 App 生命周期 2、新的 Scene Session 生命周期 那UI的生命周期呢？交给新增的Scene Delegate处理 用图表示就是： iOS13之前： 这种模式完全没问题，因为只有一个进程，只有一个与这个进程对应的用户界面 但是iOS13之后，Appdelegate不在负责UI生命周期，所有UI生命周期交给SceneDelegate处理： 因此初始化window方法需要改变： 现在不再Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions进行初始化，转交给SceneDelegate的willConnectToSession:方法进行根控制器设置： - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions { UIWindowScene *windowScene = (UIWindowScene *)scene; self.window = [[UIWindow alloc] initWithWindowScene:windowScene]; self.window.frame = windowScene.coordinateSpace.bounds; self.window.rootViewController = [UITabBarController new]; [self.window makeKeyAndVisible]; } ","link":"https://shineyangpro.com/xcode11-yi-hou-xin-bian-hua-scenedelegate/"},{"title":"如何修改Mac自带PHP版本，php-v和phpinfo两个不同的版本","content":"find / -name php.ini 得出两个ini /usr/local/php/etc/php.ini /etc/php.ini php -i | grep php.ini 查看PHP加载的是哪个配置文件,这个获取的是系统内的php.ini 的位置。不是网页apache加载的php.ini文件 查找一下系统里的PHP目录相关的东西 find / -name php /usr/bin/php -v 再环境变量里加上要使用的PHP的路径 vim /etc/profile 在文档最后，添加: export PATH=&quot;/usr/local/php/bin:$PATH&quot; 保存，退出，然后运行： source /etc/profile 如果profile这里添加成功后不能退出，请执行这个命令： :w !sudo tee % 解释： :w – write !sudo – call shell sudo command tee – the output of write (:w) command is redirected using tee % – current file name 参考文章https://stackoverflow.com/questions/28635647/how-can-i-save-a-file-i-opened-in-vim-as-the-wrong-user ","link":"https://shineyangpro.com/ru-he-xiu-gai-mac-zi-dai-php-ban-ben-php-v-he-phpinfo-liang-ge-bu-tong-de-ban-ben/"},{"title":"Apple美区官网购买礼品兑换充值卡（iTunes Gift Card ）","content":" 第一步：购买地址 点击我购买 第二步 填写购买信息 第三步：登陆 apple ID 第四步：填写支付信息 第五步：获取礼品兑换码 可以直接点击，会直接跳转到ituens,如果没跳转，可以鼠标右键复制链接的方式来获得兑换码 复制到记事本 第六步：在手机上输入兑换码 ","link":"https://shineyangpro.com/apple-mei-qu-guan-wang-gou-mai-li-pin-dui-huan-chong-zhi-qia-itunes-gift-card/"},{"title":"Xcode11 使用终端上传ipa","content":" 升级 Xcode 11 后, Xcode 删掉了 Application loader工具，使用 Xcode自带的上传功能，太卡，经常停留在进度条不动，于是便通过终端-&gt; xcrun altool上传。 整个过程5分钟内搞定，命令不多，就两个 校验 和 上传 校验 ipa xcrun altool --validate-app -f xxxx.ipa -t ios --apiKey xxxx --apiIssuer xxxx --verbose 上传 ipa xcrun altool --upload-app -f xxxx.ipa -t ios --apiKey xxxxx --apiIssuer xxxxx--verbose 上面一个命令，区别只在于， 校验是 validate-app , 上传是 upload-appxxxx.ipa 是 ipa文件的绝对路径 (以防万一，最好写绝对)apiKey xxxx 此处的 xxxx为 apiKey的值，获取方法见下面apiIssuer xxxx 此处的 xxxx为 apiIssuer的值，获取方法见下面 获取方式 1、进入开发者后台 -&gt; 用户和访问 2、apiKey 即密钥ID 3、 apiIssuer 即 Issuer ID 上传成功 要把开发者中心的密钥文件下载到电脑上，最好是放到用户的目录下面/用户/xxx ","link":"https://shineyangpro.com/xcode11-shi-yong-zhong-duan-shang-chuan-ipa/"},{"title":"Swift 把 1234656转化成 1.23万 或1.23亿 或 1 万 ，1亿","content":"extension Float { /** 战斗力值转换 */ var combatValues: String { if (self / 10000) &gt; 1 { let temp = self / 10000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;万&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;万&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;万&quot; } return str + &quot;万&quot; } } if (self / 100000000) &gt; 1 { let temp = self / 100000000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;亿&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;亿&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;亿&quot; } return str + &quot;亿&quot; } } let decimal = String.init(self).componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;0&quot; { return decimal[0] } return String.init(self) } } 字符串扩展 extension String { func attributedString(font:CGFloat)-&gt;NSMutableAttributedString{ let attributedS = NSMutableAttributedString(string: self) if self.containsString(&quot;万&quot;) || self.containsString(&quot;亿&quot;) { let normalAttributes = [NSFontAttributeName:UIFont.systemFontOfSize(font)] attributedS.addAttributes(normalAttributes, range: NSMakeRange(self.characters.count - 1,1)) } return attributedS } } 调用：label.attributedText = Float(number).combatValues ","link":"https://shineyangpro.com/swift-ba-1234656-zhuan-hua-cheng-123-wan-huo-123-yi-huo-1-wan-1-yi/"},{"title":"macOS Catalina (macOS 10.15) 已损坏无法打开解决办法","content":"最近有很多小伙伴更新系统后，提示“已损坏无法打开”的情况，按照以往的方法，在系统的“安全与隐私”中已经允许了“任何来源”，但还是一样打不开，怎么办呢？ App 在 macOS Catalina下提示已损坏无法打开解决办法： 1、在系统的“安全与隐私”中允许“任何来源”，再打开终端。 2、输入以下命令: sudo xattr -d com.apple.quarantine /Applications/xxxx.app 注意：Applications/xxxx.app 换成你的App路径或在sudo xattr -d com.apple.quarantine 后将软件拖进去即可。 3、最后，重启App即可。 ","link":"https://shineyangpro.com/macos-catalina-macos-1015-yi-sun-pi-wu-fa-da-kai-jie-jue-ban-fa/"},{"title":"Mac下配置Go开发环境","content":"Go（又称 Golang）是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go 的语法接近 C 语言，可以进行网络编程、系统编程、并发编程、分布式编程。 下面演示如何在 Mac 电脑上搭建 Go 语言开发环境。 1，安装 Golang 的 SDK 在官网下载对应的开发工具GoLand,地址如下:https://golang.org/dl/ 2，配置环境变量 （1）在终端执行如下命令进入用户主目录： cd ~ （2）执行如下命令打开 .bash_profile 文件： vim .bash_profile （3）按下 i 进入编辑模式，在文件末尾添加如下内容（GOPATH地址是自己创建项目的地址，比如我的是在桌面的文件夹下创建的）： export GOPATH=/Users/yangchen/Desktop/ReactNatve/Go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN （4）按下 ESC 键，然后输入 :wq 保存并退出编辑。 （5）接着执行如下命令让配置生效。 source ~/.bash_profile 最后我们执行 go env 查看配置结果，可以看到 GO 的环境变量已成功配置了。 ","link":"https://shineyangpro.com/mac-xia-pei-zhi-go-kai-fa-huan-jing/"},{"title":"Swift  从子视图跳转到指定tabBar主界面","content":"从tabbar的子页面跳转到指定的tabbar主页面,话不多说直接上代码: self.navigationController?.tabBarController?.selectedIndex = 0 self.navigationController?.popViewController(animated: false) ","link":"https://shineyangpro.com/swift-cong-zi-shi-tu-tiao-zhuan-dao-zhi-ding-tabbar-zhu-jie-mian/"},{"title":"Swift UICollectionView横向分页滚动，cell左右排版","content":"废话不多说，直接上代码 自定义一个SYitemViewLayout，继承UICollectionViewFlowLayout mport UIKit //根据需求设置列跟行 let kEmotionCellNumberOfOneRow = 3 let kEmotionCellRow = 2 class SYitemViewLayout: UICollectionViewFlowLayout { // 保存所有item fileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] // MARK:- 重新布局 override func prepare() { super.prepare() let itemWH: CGFloat = (kScreenWitdh - 30) / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH - 50) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true // let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 // collectionView?.contentInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10) var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount { let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * (kScreenWitdh - 30)) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) } } override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? { var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map({ if rect.contains($0.frame) { rectAttributes.append($0) } }) return rectAttributes } } ","link":"https://shineyangpro.com/swift-uicollectionview-heng-xiang-fen-ye-gun-dong-cell-zuo-you-pai-ban/"},{"title":"Swift框架-章：1、开发一个Swift框架","content":"Swift已成为一种流行的编程语言，并且每天都在发展。 开发Swift框架具有以下优点。 隐藏您的代码实现。 由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 开发Swift框架具有以下优点。 1、隐藏您的代码实现。 2、由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 使用的工具：XCode 11.6 +，Swift 5.1+ 步骤1：-安装框架项目 1、创建新的XCode项目。 2、 创建框架 为您的项目命名，我们使用了类似于Alamofire的AlamoWater名字。 （请确保选择语言-Swift） 单击目标内的AlamoWater文件夹，然后按⌘+N。 选择文件名AlamoWater和以下子类：NSObject 在AlameWater.swift中添加以下代码**。** **注意：-**确保您的类和方法设置为Public import UIKit public protocol AlamoWaterProtocol { func didCallHello() } open class AlamoWater: NSObject { public static let shared = AlamoWater() public var delegate:AlamoWaterProtocol? open func hello(){ debugPrint(&quot;Hello from AlamoWater!&quot;) AlamoWater.shared.delegate?.didCallHello() } } 要为iOS设备和模拟器创建框架，请向您的项目添加新的Aggregate目标。 并添加[运行脚本] #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # make sure the output directory exists mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # Step 1. Build Device and Simulator versions xcodebuild -target &quot;AlamoWater&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build xcodebuild -target &quot;AlamoWater&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build # Step 2. Copy the framework structure (from iphoneos build) to the universal folder cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/&quot; # Step 3. Copy Swift modules from iphonesimulator build (if it exists) to the copied framework directory SIMULATOR_SWIFT_MODULES_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/Modules/AlamoWater.swiftmodule/.&quot; if [ -d &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; ]; then cp -R &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/Modules/AlamoWater.swiftmodule&quot; fi # Step 4. Create universal binary file using lipo and place the combined executable in the copied framework directory lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework/AlamoWater&quot; # Step 5. Convenience step to copy the framework to the project's directory cp -R &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework&quot; &quot;${PROJECT_DIR}&quot; # Step 6. Convenience step to open the project's directory in Finder open &quot;${PROJECT_DIR}&quot; 注意：AlamoWater改为自己项目的名字 通过按⌘+ B选择UniversalAlamoWater目标来构建您的第一个框架 构建完成后，您将看到Finder与其中的Framework一起打开。 注意：-如果出现以下错误， … Reason: image not found 确保在嵌入式二进制文件和链接的框架和库中都添加了框架 ","link":"https://shineyangpro.com/swift-kuang-jia-zhang-1kai-fa-yi-ge-swift-kuang-jia/"},{"title":"Go实战项目【一】Golang和Gin框架的安装和使用","content":"Golang的安装 根据所使用的电脑操作系统，下载相对应的版本Golang 下载 比如我的电脑是macOS系统，下载的是 安装完毕后配置路径 打开终端，执行: vi ~/.bash_profile .bash_profile 添加的内容如下： #Go export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 然后执行 source ~/.bash_profile 让配置生效 执行 go version 查看Golang是否安装成功，出现以下信息即为安装成功 初始化项目目录 选一个你自己喜欢的路径，创建一个文件夹，比如我的是/Users/newmac/Documents/Go-app这个文件夹下 cd /Users/newmac/Documents/Go-app mkdir api &amp;&amp; cd api go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go mod init api mkdir api &amp;&amp; cd api：创建并进入api文件夹 go env -w GO111MODULE=on：开启Go modules go env -w GOPROXY=https://goproxy.cn,direct：设置 GOPROXY 代理，也可以把GOPROXY写入.bash_profile中 go mod init [MODULE_PATH]：初始化 Go modules，它将会生成 go.mod 文件，MODULE_PATH 填写的是模块引入路径，如果想要把项目放到Github上，可以填写GitHub的项目路径，这个根据自己情况填写。 然后就会在api文件夹下出现go.mod文件 安装Gin框架 在api文件夹下，执行 go get -u github.com/gin-gonic/gin 安装完毕后，创建一个test.go文件，测试下Gin框架是否能使用test.go 我用的是GoLang开发工具，可以直接在编译器里面执行 如果用的是VS code，可以在终端运行:go run test.go 在浏览器打开127.0.0.1:8080/ping这个地址，可以看到有返回的数据，代表Gin框架安装和使用成功。 Go相关学习知识 ","link":"https://shineyangpro.com/go-shi-zhan-xiang-mu-yi-golang-he-gin-kuang-jia-de-an-zhuang-he-shi-yong/"},{"title":"清理Xcode占用的Mac硬盘空间","content":"主要是操作两个目录下的文件 ~/Library/Developer/Xcode 和 ~/Library/Developer/CoreSimulator ~/Library/Developer/Xcode 1、DerivedData 此文件夹内的每个目录是Xcode运行每个APP时生成的缓存文件，删除之后再运行APP会重新生成该APP对应的文件，只是编译时间变长了。 可保留近期运行的APP相关的文件夹，对于以前运行过近期不再使用的APP，例如网上下载的demo，建议清理。 Archives 此文件夹中的内容对应Xcode-&gt;Window-&gt;Organizer-&gt;Archives中列出的打包文件。 可保留有用的打包文件，其它删除。 iOS DeviceSupport 此文件夹存放的是Xcode对你所连接真机的版本支持，每个文件夹几乎都是几个G的大小（我个人的情况是11个目录占了26G空间），手机每升级一个版本，再次连接Xcode时，这里都会生成一个目录。 建议保留你手机当前版本的文件夹。全部删除也没关系，手机再次连接Xcode时会重新生成。 2. ~/Library/Developer/CoreSimulator Devices 此文件夹下的目录是以模拟器的UDID命名的，运行模拟器时每安装一个新的APP，相应的文件夹内容也会增大，就像手机上安装应用会占用手机空间一样。 可删除全部文件夹。再次运行模拟器，会重新生成。 删除后开启Xcode运行模拟器，可能会出现下面的错误，不要惊慌，重启Xcode就好了。 建议在退出Xcode后进行清理，清理后重启电脑 ","link":"https://shineyangpro.com/qing-li-xcode-zhan-yong-de-mac-ying-pan-kong-jian/"},{"title":"iOS 13：Swift以编程方式设置应用程序根视图控制器不起作用","content":"在iOS以后直接使用window?.makeKeyAndVisible()是不起作用的，正确用法是: static func redirectToMainNavRVC(currentVC: UIViewController){ let appDelegate = UIApplication.shared.delegate as! AppDelegate let vc = UIStoryboard(name: appDelegate.storyBoardName, bundle: nil).instantiateViewController(withIdentifier: &quot;MainNavigationViewController&quot;) as! MainNavigationViewController if #available(iOS 13.0, *){ if let scene = UIApplication.shared.connectedScenes.first{ guard let windowScene = (scene as? UIWindowScene) else { return } print(&quot;&gt;&gt;&gt; windowScene: \\(windowScene)&quot;) let window: UIWindow = UIWindow(frame: windowScene.coordinateSpace.bounds) window.windowScene = windowScene //Make sure to do this window.rootViewController = vc window.makeKeyAndVisible() appDelegate.window = window } } else { appDelegate.window?.rootViewController = vc appDelegate.window?.makeKeyAndVisible() } } ","link":"https://shineyangpro.com/ios-13swift-yi-bian-cheng-fang-shi-she-zhi-ying-yong-cheng-xu-gen-shi-tu-kong-zhi-qi-bu-qi-zuo-yong/"}]}