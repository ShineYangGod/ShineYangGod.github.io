{"posts":[{"title":"Mac OS 打开软件提示【XXX.app 已损坏，打不开。您应该将它移到废纸篓】解决方法：","content":"1、先打开软件任何来源 sudo spctl –master-disable 2、打开终端，输入：sudo xattr -r -d com.apple.quarantine ，然后命令后面输入个空格。(注意:命令后面输入一个空格) 3、命令粘贴后，把应用程序里面的APP拖拽到命令后面回车，输入开机密码，密码不会显示，回车即可搞定，(如果您安装别的软件提示损坏亦可如此操作)。 4、完成后，APP 会自动运行。 ","link":"https://shineyangpro.com/mac-os-da-kai-ruan-jian-ti-shi-xxxapp-yi-sun-pi-da-bu-kai-nin-ying-gai-jiang-ta-yi-dao-fei-zhi-lou-jie-jue-fang-fa/"},{"title":"JS 使用地理位置定位","content":"地理位置API允许用户向Web应用程序提供他们的位置。出于关注考虑，报告位置前会先请求用户许可。 geolocation对象 地理位置API通过navigator.geolocation提供。 如果该对象存在，那么地理位置服务可用。 if (&quot;geolocation&quot; in navigator) { /* 地理位置服务可用 */ } else { /* 地理位置服务不可用 */ } 在Firefox 24和之前的浏览器中，即使API被禁止，代码&quot;geolocation&quot; in navigator也总是会得到true。这在Firefox 25中已经被修复（bug 884921）。 获取当前定位 您可以调用getCurrentPosition()函数获取用户当前定位位置。这会异步地请求获取用户位置，并查询定位硬件来获取最新信息。当定位被确定后，定义的某些函数就会被执行。您可以选择性地提供第第二个参数函数，当有错误时会被执行。第三个参数也是可选的，您可以通过该对象参数设置最大化替换的定位返回时间，等待请求的时间和是否获取高精度定位。 至少在情况下，getCurrentPosition()会尽快返回一个低精度结果，这在您不关心准确度只关心快速获取结果的情况下很有用。有GPS的设备可能需要一分钟较长久来获取GPS定位，在这种情况下getCurrentPosition()会返回低精度数据（基于IP的定位或Wi-Fi定位）。 navigator.geolocation.getCurrentPosition(function(position) { do_something(position.coords.latitude, position.coords.longitude); }); 上述示例中，当获取位置后do_something()函数会被执行。 监视定位 您可以设定一个参数函数来响应定位数据发生的变化（设备发生了移动，或获取到更精确的位置信息）。您可以通过watchPosition()函数实现该功能。它与getCurrentPosition()接受相同的参数，但较少函数会被调用多次。错误原因函数与getCurrentPosition()中一样是可选的，也会被多次调用。 注意：您可以直接调用watchPosition()函数，不需要先调用getCurrentPosition()函数。 var watchID = navigator.geolocation.watchPosition(function(position) { do_something(position.coords.latitude, position.coords.longitude); }); watchPosition()函数会返回一个ID，唯一地标记该位置监视器。您可以将这个ID传给clearWatch()函数来停止监视用户位置。 navigator.geolocation.clearWatch(watchID); 处理返回结果 getCurrentPosition()和watchPosition()都接受一个成功替代，一个任选的失败以及和一个任选的PositionOptions对象。 对watchPosition的调用某种这样的： function geo_success(position) { do_something(position.coords.latitude, position.coords.longitude); } function geo_error() { alert(&quot;Sorry, no position available.&quot;); } var geo_options = { enableHighAccuracy: true, maximumAge : 30000, timeout : 27000 }; var wpid = navigator.geolocation.watchPosition(geo_success, geo_error, geo_options); watchPosition实际使用示例：[点我传送](http : //www.thedotproduct.org/experiments/geo/) 描述位置 用户的位置由一个包含Coordinates对象的Position对象描述。 处理错误 getCurrentPosition()或watchPosition()的错误回调函数以PositionError为第一个参数。 function errorCallback(error) { alert('ERROR(' + error.code + '): ' + error.message); }; 地理位置示例 HTML &lt;p&gt;&lt;button onclick=&quot;geoFindMe()&quot;&gt;Show my location&lt;/button&gt;&lt;/p&gt; &lt;div id=&quot;out&quot;&gt;&lt;/div&gt; JavaScript function geoFindMe() { var output = document.getElementById(&quot;out&quot;); if (!navigator.geolocation){ output.innerHTML = &quot;&lt;p&gt;您的浏览器不支持地理位置&lt;/p&gt;&quot;; return; } function success(position) { var latitude = position.coords.latitude; var longitude = position.coords.longitude; output.innerHTML = '&lt;p&gt;Latitude is ' + latitude + '° &lt;br&gt;Longitude is ' + longitude + '°&lt;/p&gt;'; var img = new Image(); img.src = &quot;http://maps.googleapis.com/maps/api/staticmap?center=&quot; + latitude + &quot;,&quot; + longitude + &quot;&amp;zoom=13&amp;size=300x300&amp;sensor=false&quot;; output.appendChild(img); }; function error() { output.innerHTML = &quot;无法获取您的位置&quot;; }; output.innerHTML = &quot;&lt;p&gt;Locating…&lt;/p&gt;&quot;; navigator.geolocation.getCurrentPosition(success, error); } 授权请求 所有addons.mozilla.org上需要使用位置的插件必须在使用API​​前显式地请求权限。用户的响应将存储在pref参数指定的替代设置中。callback参数指定的函数会被调用并包含一个代表用户响应的boolean参数。如果为true，代表插件可以访问定位数据。 function prompt(window, pref, message, callback) { let branch = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;] .getService(Components.interfaces.nsIPrefBranch); if (branch.getPrefType(pref) === branch.PREF_STRING) { switch (branch.getCharPref(pref)) { case &quot;always&quot;: return callback(true); case &quot;never&quot;: return callback(false); } } let done = false; function remember(value, result) { return function() { done = true; branch.setCharPref(pref, value); callback(result); } } let self = window.PopupNotifications.show( window.gBrowser.selectedBrowser, &quot;geolocation&quot;, message, &quot;geo-notification-icon&quot;, { label: &quot;Share Location&quot;, accessKey: &quot;S&quot;, callback: function(notification) { done = true; callback(true); } }, [ { label: &quot;Always Share&quot;, accessKey: &quot;A&quot;, callback: remember(&quot;always&quot;, true) }, { label: &quot;Never Share&quot;, accessKey: &quot;N&quot;, callback: remember(&quot;never&quot;, false) } ], { eventCallback: function(event) { if (event === &quot;dismissed&quot;) { if (!done) callback(false); done = true; window.PopupNotifications.remove(self); } }, persistWhileVisible: true }); } prompt(window, &quot;extensions.foo-addon.allowGeolocation&quot;, &quot;Foo Add-on wants to know your location.&quot;, function callback(allowed) { alert(allowed); }); ","link":"https://shineyangpro.com/js-shi-yong-di-li-wei-zhi-ding-wei/"},{"title":"Swift — 7种强大的动画可改善您的应用程序用户界面","content":"在最近的几个月中，我一直在努力开发一款具有深色调和恐怖气氛的新应用程序。我在Sketch中制作了所有图形和内容，经过几天的调整，我将所有内容都放在Xcode上并最终运行了我的项目。 但不幸的是，我很快注意到我的应用与我每天使用的其他应用不同。它缺少使它充满活力的过渡和动画。 因此，我开始学习有关动画的更多信息，并且发现了一个隐藏的世界，使我仅需几行代码即可创建令人惊叹的效果。您可以在下面找到一些示例，可以在Playground上对其进行自定义，然后再用于您的项目。 Pop In 我们从可用于按钮和视图的基本动画开始。此动画通常也用于弹出消息和警告。 let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 375.0, height: 667.0)) // Create the square and add it to container let square = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 200.0)) square.center = containerView.center square.layer.cornerRadius = 20.0 square.backgroundColor = UIColor.white containerView.addSubview(square) // make the square not visible and scale it to 0.5x square.alpha = 0 square.transform = CGAffineTransform(scaleX: 0.5, y: 0.5) // Finally the animation! UIView.animate( withDuration: 0.5, delay: 1, usingSpringWithDamping: 0.55, initialSpringVelocity: 3, options: .curveEaseOut, animations: { square.transform = .identity square.alpha = 1 }, completion: nil) Pop Out 此动画产生与前一个相反的效果。通常，这用于关闭视图/弹出窗口。 // Create the container let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let square = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 200.0)) square.center = containerView.center square.layer.cornerRadius = 20.0 square.backgroundColor = UIColor.blue containerView.addSubview(square) // Finally the animation! UIView.animate( withDuration: 0.5, delay: 1, usingSpringWithDamping: 0.55, initialSpringVelocity: 3, options: .curveEaseOut, animations: { square.alpha = 0 square.transform = CGAffineTransform(scaleX: 0.5, y: 0.5) }, completion: nil) Drop From Top 该动画可用于游戏或应用中以显示设置或过滤视图。 // Create the container let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let squareBlue = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 200.0)) squareBlue.center = containerView.center squareBlue.layer.cornerRadius = 20.0 squareBlue.backgroundColor = UIColor.blue containerView.addSubview(squareBlue) // Finally the animation! let offset = CGPoint(x: 0, y: -containerView.frame.maxY) let x: CGFloat = 0, y: CGFloat = 0 squareBlue.transform = CGAffineTransform(translationX: offset.x + x, y: offset.y + y) squareBlue.isHidden = false UIView.animate( withDuration: 1, delay: 1, usingSpringWithDamping: 0.47, initialSpringVelocity: 3, options: .curveEaseOut, animations: { squareBlue.transform = .identity squareBlue.alpha = 1 }) Coming From Left 这是一个真正的动态动画，当我们在两个控制器之间进行选择时可以使用。您可以将其添加viewDidLoad到第二个控制器上的事件中，以表示移动和继续。 // Create the container let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let squareBlue = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 100.0, height: 100.0)) squareBlue.center = containerView.center squareBlue.layer.cornerRadius = 20.0 squareBlue.backgroundColor = UIColor.blue containerView.addSubview(squareBlue) // Finally the animation! let offset = CGPoint(x: -containerView.frame.maxX, y: 0) let x: CGFloat = 0, y: CGFloat = 0 squareBlue.transform = CGAffineTransform(translationX: offset.x + x, y: offset.y + y) squareBlue.isHidden = false UIView.animate( withDuration: 1, delay: 1, usingSpringWithDamping: 0.47, initialSpringVelocity: 3, options: .curveEaseOut, animations: { squareBlue.transform = .identity squareBlue.alpha = 1 }) Fade In 与弹出动画类似，它可以用于按钮和视图创建。 let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let squareBlue = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 100.0, height: 100.0)) squareBlue.center = containerView.center squareBlue.layer.cornerRadius = 20.0 squareBlue.backgroundColor = UIColor.blue containerView.addSubview(squareBlue) // Finally the animation! squareBlue.alpha = 0.0 UIView.animate(withDuration: 0.5, delay: 1.0, options: UIView.AnimationOptions.curveEaseIn, animations: { squareBlue.alpha = 1 }, completion: nil) Fade Out 与弹出动画类似，它可用于按钮和视图的创建和消失。 // Create the container let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let squareBlue = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 100.0, height: 100.0)) squareBlue.center = containerView.center squareBlue.layer.cornerRadius = 20.0 squareBlue.backgroundColor = UIColor.blue containerView.addSubview(squareBlue) // Finally the animation! squareBlue.alpha = 1 UIView.animate(withDuration: 0.5, delay: 1.0, options: UIView.AnimationOptions.curveEaseIn, animations: { squareBlue.alpha = 0.0 }, completion: nil) Card Flip 如果您使用的卡/信用卡/文档有两个部分（例如，正面和背面），这是一个非常酷的动画。 let containerView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 250, height: 400)) containerView.backgroundColor = UIColor.white // Create the square and add it to container let squareBlue = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 100.0, height: 100.0)) squareBlue.center = containerView.center squareBlue.layer.cornerRadius = 20.0 squareBlue.backgroundColor = UIColor.blue containerView.addSubview(squareBlue) // Finally the animation! UIView.animate(withDuration: 0.5, delay: 0.0, options: .curveEaseInOut, animations: { squareBlue.transform = CGAffineTransform(scaleX: -1, y: 1) }, completion: nil) ","link":"https://shineyangpro.com/swift-7-chong-qiang-da-de-dong-hua-ke-gai-shan-nin-de-ying-yong-cheng-xu-yong-hu-jie-mian/"},{"title":"iOS- 如何在部分中不重复设置UITableViewCell背景颜色？","content":"let row = (0..&lt;indexPath.section).reduce(indexPath.row) { $0 + tableView.numberOfRows(inSection: $1) } cell.backgroundColor = row % 2 == 0 ? UIColor.gray : UIColor.white ","link":"https://shineyangpro.com/ios-ru-he-zai-bu-fen-zhong-bu-chong-fu-she-zhi-uitableviewcell-bei-jing-yan-se/"},{"title":"iOS Siri 配置","content":"登录苹果开发者账号 1.1 登录Apple Member Center，选择Certificates, IDs &amp;Profiles 选项，如下图所示： 新建 App Groups （注意：若 App Groups 已存在并且 Group id 等于&quot;group.「包名」&quot;，可忽略此步骤，可直接进行下一步，将主 App ID 开启 siri 功能） App 需要新增 siri 功能，首先要为已有的 App（在以下操作中称为：主 App）创建一个 App 组（即 App Groups） 2.1 点击左侧菜单Identifiers，然后点击+，选择App Gourps，然后点击右上角Continue； 2.2 信息填写： Description：为这个 App 组创建一个名称； ID：填写主 App 包名，格式为「group.App 包名」（包名格式：com.xxx.xxx)，然后点击Continue： 2.3 确认 App Groups 的信息，信息有误可以点击Back回到上一页修改；没有问题可以点击Register到下一步； 2.4 此时 App Group 已创建完成； 主 App ID 开启 siri 功能 3.1 点击右侧App Groups菜单，选择App IDs； 3.2 找到 App 的主 Appid，点击进入配置页面； 3.3 确认下是否有开启App Groups功能，如无开启，请勾选 ☑️ 开启该功能；点击右边Congigure勾选已创建的群主； 然后页面下拉，确认下是否有开启SiriKit功能，如无开启，请勾选 ☑️ 开启该功能；点击右上角Save; 新建 siri App ID 4.1 点击左侧菜单Identifiers，然后点击+，选择App IDs，然后点击右上角Continue； 4.2 信息填写： Name：填写 siri 的名称 Bundle ID：填写 siri 的包名，格式为「主 App 包名.SceneIntent」 必须勾选 ☑️ App Groups功能，然后点击Continue 4.3 点击创建好的 AppIDs，点击右边Congigure勾选这个 siri App ID，关联 App 组; 新建 siri UI App ID 5.1 点击左侧菜单Identifiers，然后点击+，选择App IDs，然后点击右上角Continue； 5.2 信息填写： Name：填写 siri UI 的名称 Bundle ID：填写 siri UI 的包名，格式为「主 App 包名.SceneIntentUI」 必须勾选 ☑️ App Groups功能，然后点击Continue 5.3 点击创建好的 AppIDs，点击右边Congigure勾选这个 siri App ID，关联 App 组; 重新生成主 App mobileprovision 文件 由于主 App 新增了 siri 功能，修改了原配置项，所以需要重新生成 mobileprovision 文件 6.1 点击左侧菜单Profiles，点击主 App 信息点击后进入进行修改； 6.2 Certificates:重新选择发布证书，此处有可能会出现多个相同的发布证书，先根据名称下方的到期时间来推算当时制作证书的时间选择；如无法确认时间，建议选择最后一个证书，然后点击Save； 6.3 此时主 App 的 mobileprovision 文件已配置完成，点击Download将文件下载后发送给相关的工作人员。 生成 siri mobileprovision 文件 7.1 点击左侧菜单Profiles，然后点击+号； 7.2 选择App Store，点击continue； 7.3 在App ID处一定要选择到对应的 App ID，主要格式为「主 App 包名.SceneIntent」，然后点击Continue 7.4 选择主 App 对应的发布证书，检查第六步操作，选择同一个证书，然后点击Continue; 7.5 Provisioning Profile Name：填写 siri mobileprovision 文件的名称 7.6 此时 siri mobileprovision 文件已配置完成，点击Download将文件下载后发送给相关的工作人员。 生成 siri UI mobileprovision 文件 8.1 点击左侧菜单Profiles，然后点击+号； 8.2 选择App Store，点击continue； 8.3 在App ID处一定要选择到对应的 App ID，主要格式为「主 App 包名.SceneIntentUI」，然后点击Continue 8.4 选择主 App 对应的发布证书，检查第六步操作，选择同一个证书，然后点击Continue 8.5 Provisioning Profile Name：填写 siri mobileprovision 文件的名称 8.6 此时 siri Ui mobileprovision 文件已配置完成，点击Download将文件下载后发送给相关工作人员。 ","link":"https://shineyangpro.com/ios-siri-pei-zhi/"},{"title":"如何为Go服务器应用程序设置Let's Encrypt","content":"package main import ( &quot;crypto/tls&quot; &quot;log&quot; &quot;net/http&quot; &quot;golang.org/x/crypto/acme/autocert&quot; ) func main() { certManager := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(&quot;example.com&quot;), //Your domain here Cache: autocert.DirCache(&quot;certs&quot;), //Folder for storing certificates } http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&quot;Hello world&quot;)) }) server := &amp;http.Server{ Addr: &quot;:https&quot;, TLSConfig: &amp;tls.Config{ GetCertificate: certManager.GetCertificate, }, } go http.ListenAndServe(&quot;:http&quot;, certManager.HTTPHandler(nil)) log.Fatal(server.ListenAndServeTLS(&quot;&quot;, &quot;&quot;)) //Key and cert are coming from Let's Encrypt } 有关autocert的相关信息可以参考这里autocert ","link":"https://shineyangpro.com/ru-he-wei-go-fu-wu-qi-ying-yong-cheng-xu-she-zhi-lets-encrypt/"},{"title":"Go的免费和自动SSL / TLS证书(Go设置HTTPS)","content":"如今，HTTPS已成为必需。不仅出于安全目的，而且还因为像Google这样的搜索引擎比基于纯HTTP的网站对基于安全协议运行的网站的排名更高。 到了2017年，我们可以以价格为借口而不使用我们的网站进行HTTPS的日子已经一去不复返了。 在这篇文章中，我将解释如何创建一个Go Web应用程序，该应用程序会自动生成SSL / TLS证书，并使用它们在HTTPS上运行。最好的部分是：它是免费的！ 如果您希望按照此演示并自己尝试，请确保符合以下要求。 您需要Go编译器； 公开可用的服务器。如果您没有，我建议在Digital Ocean上使用VM 。如果您将其运行24小时，则只需支付0.15美元； 域名并访问其DNS设置。如果您的云提供了公共共享名称，则不需要此名称，例如：yourvm0001.yourcloud.net。 让我们加密和ACME协议 Let's Encrypt是一个非常知名且受信任的SSL / TLS证书颁发者，它提供了免费且自动的生成过程。无需任何注册过程或付款即可在不到一秒钟的时间内颁发证书。 Autocert是Go软件包，它实现ACME协议的客户端，该客户端用于在Let's Encrypt上生成证书。这是您唯一需要的软件包依赖项，不需要其他安装或软件包。 您可以像其他任何Go软件包一样获得它。 go get golang.org/x/crypto/acme/autocert 下面是代码: package main import ( &quot;crypto/tls&quot; &quot;fmt&quot; &quot;net/http&quot; &quot;golang.org/x/crypto/acme/autocert&quot; ) func main() { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &quot;Hello Secure World&quot;) }) certManager := autocert.Manager{ Prompt: autocert.AcceptTOS, Cache: autocert.DirCache(&quot;certs&quot;), } server := &amp;http.Server{ Addr: &quot;:443&quot;, Handler: mux, TLSConfig: &amp;tls.Config{ GetCertificate: certManager.GetCertificate, }, } go http.ListenAndServe(&quot;:80&quot;, certManager.HTTPHandler(nil)) server.ListenAndServeTLS(&quot;&quot;, &quot;&quot;) } 代码详解: 我们main通过mux在path上创建一个带有简单Hello World消息的函数来启动该功能/。在此示例中，我们使用Go的默认Mux，但可以轻松地用任何其他第三方路由器替换它。 下一步，我们将创建一个实例autocert.Manager。该结构负责与Let's Encrypt通信并获取SSL / TLS证书。该Cache字段是一个接口，定义了autocert.Manager应如何以及在何处存储和加载证书。在此示例中，我们将autocert.DirCache证书存储在本地文件夹中。这是最简单的入门方法，但对于托管在多台服务器上的网站而言，可能不是最佳方法，因为每台服务器都具有自己的缓存。 最后一步是创建一个http.Server侦听端口443并使用我们的mux实例的对象。然后，我们创建tls.Config对象并将其分配给服务器。现在是“魔术”发生的地方。GetCertificate这是一种方法，我们可以在启动新的HTTPS请求时告诉服务器将证书加载到何处。这种方法使我们有机会选择要使用的证书，而不是像大多数应用程序一样为每个请求返回特定证书。然后certManager.GetCertificate，我们使用它将首先尝试从缓存中获取匹配的证书，如果没有匹配的证书，则使用ACME协议从Let's Encrypt获取新的证书。 2018年初，由于安全原因，让我们加密禁用的TLS-SNI挑战。建议使用HTTP质询，我们通过certManager.HTTPHandler(nil)在端口80上使用并附加一个新的http侦听器来实现。 之后，我们要做的就是使用来启动服务器server.ListenAndServeTLS(&quot;&quot;, &quot;&quot;)。如果您以前在Go上使用HTTPS服务器，则可能还记得这两个参数是Certificate和和Privatey Key。使用时autocert，我们不需要这些，因此我们传递一个空字符串。 值得一提的是，使用时certManager.HTTPHandler(nil)，所有传入HTTP的流量都会自动重定向到HTTPS。您可以通过传递http.Handler而不是nil作为第一个参数来覆盖此行为。 让我们运行它！ 您可以像运行其他任何Go Web应用程序一样运行它，但是如果在本地计算机上运行它将会失败。原因是“让我们加密”要求该网站可以通过已知的DNS名称公开获得。在本地运行时，“让我们加密”无法为验证目的而对您的域执行ping操作，但失败。 在浏览器中输入你的域名，你会看到 您可能会注意到，加载第一个请求可能需要几秒钟的时间。这是因为SSL / TLS证书生成过程是在后台进行的。由于证书已被缓存，因此连续请求应该很快。 重要说明和建议： 对于同一域可以生成多少证书有限制。在撰写本文时，限制为每周20张证书。看起来可能很多，但是如果您无法正确管理缓存，则很容易达到此限制。有关“让我们加密”限制的更多信息，请查看官方文档https://letsencrypt.org/docs/rate-limits/。 由您决定存储证书的位置和方式。如果只有几台服务器，则临时本地存储将非常有用。群集增长后，此方法可能不适合您，因为每个服务器都将获取一个新证书。记住上面解释的限制。 Let's Encrypt生成的所有证书的有效期仅为90天。幸运的是，autocert自动处理续订，因此我们无需执行任何操作。但是，在接近到期日期时始终保持关注是一个好主意。 尝试在多租户应用程序上使用它，其中每个租户都有自己的子域，否则您将失败。我学到了很难的方法。限制是按域名（不包括子域）进行的，因此您每周只能为20个租户生成证书。 由于您无法在本地使用autocert，因此您需要以一种可以在HTTP或HTTPS上运行之间进行选择的方式来构建应用，以便可以在开发过程中轻松使用HTTP。 ","link":"https://shineyangpro.com/go-de-mian-fei-he-zi-dong-ssl-tls-zheng-shu-go-she-zhi-https/"},{"title":"CentOS 7下安装Let's Encrypt的通配符证书","content":"Let's Encrypt的通配符证书（Wildcard Certificate）于2018年3月中旬上线，可以免费申请，安装和使用，本次记录一下基本的步骤。 申请通配符证书需要ACME v2协议的客户端，官方推荐使用Certbot。 安装Certbot 先安装EPEL仓库（因为certbot在这个源里，目前还没在重置的源里） sudo yum install epel-release 安装certbot sudo yum install certbot 查看certbot版本，因为ACME v2要在certbot 0.20.0以后的版本支持。 certbot --version 申请证书 申请通配符证书命令如下： sudo certbot certonly -d yourdomain.com -d *.yourdomain.com --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 主要参数说明： certonly是certbot众多插件之一，您可以选择其他插件。 -d为那些主机申请证书，如果是通配符，输入* .yourdomain.com 注意：本文还申请了 yourdomain.com 这是为了避免通配符证书不匹配。。 –preferred-challenges dns，使用DNS方式重置域名所有权 注意：通配符证书只能使用 dns-01 这种方式申请。 输出如下：(可能会不同，根据自己的版本为准) Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator manual, Installer None Enter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): admin@yourdomain.com ------------------------------------------------------------------------------- Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must agree in order to register with the ACME server at https://acme-v02.api.letsencrypt.org/directory ------------------------------------------------------------------------------- (A)gree/(C)ancel: A Plugins selected: Authenticator manual, Installer None Obtaining a new certificate Performing the following challenges: dns-01 challenge for yourdomain.com ------------------------------------------------------------------------------- NOTE: The IP of this machine will be publicly logged as having requested this certificate. If you're running certbot in manual mode on a machine that is not your server, please ensure you're okay with that. Are you OK with your IP being logged? ------------------------------------------------------------------------------- (Y)es/(N)o: y ------------------------------------------------------------------------------- Please deploy a DNS TXT record under the name _acme-challenge.yourdomain.com with the following value: hkh6BT7jERHEDzPORxBQ*************4ebhA Before continuing, verify the record is deployed. ------------------------------------------------------------------------------- Press Enter to Continue 互动提示： 输入邮箱地址，以备紧急更新或安全提醒的通知。 同意许可协议。 同意域名和IP绑定。 绑定DNS的TXT记录值，验证域名的所有权。 然后去DNS服务商那里，配置_acme-challenge.yourdomain.com类型为TXT的记录。在没有确认TXT记录执行之前不要回车执行。 注意：要输入当时提示的值，本例为 hkh6BT7jERHEDzPORxBQ*************4ebhA 新打开一个ssh窗口，输入以下命令确认TXT记录是否生效： $ dig -t txt _acme-challenge.yourdomain.com @8.8.8.8 ... ... ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;_acme-challenge.yourdomain.com. IN TXT ;; ANSWER SECTION: _acme-challenge.yourdomain.com. 599 IN TXT &quot;hkh6BT7jERHEDzPORxBQ*************4ebhA&quot; ... ... 可以看到，配置已经生效，可以退出新打开的这个ssh窗口。 回到原来的ssh窗口，点击回车。 Waiting for verification... Cleaning up challenges IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/yourdomain.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/yourdomain.com/privkey.pem Your cert will expire on 2019-07-22. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 至此，证书申请成功。 查看证书 证书申请成功后，交替存放在/etc/letsencrypt目录下： cd /etc/letsencrypt/ ls 输出: accounts archive csr keys live renewal renewal-hooks 可以验证一下证书信息： sudo openssl x509 -in /etc/letsencrypt/live/yourdomain.com/cert.pem -noout -text Certificate: Data: Version: 3 (0x2) Serial Number: ... ... Authority Information Access: OCSP - URI:http://ocsp.int-x3.letsencrypt.org CA Issuers - URI:http://cert.int-x3.letsencrypt.org/ X509v3 Subject Alternative Name: DNS:*.yourdomain.com, DNS:yourdomain.com X509v3 Certificate Policies: ... ... 可以看到证书的SAN扩展里包含了*.yourdomain.com，说明申请的证书的匹配范围。 证书更新 certbot-auto renew certbot默认离过期30个月可以续订。普通的证书可以使用 普通的证书可以使用certbot自带命令，配合corn表达式，定时执行作业。 通配符证书更新可以重新执行一次申请的命令，如果域名服务商支持API方式，也可以使用脚本自动执行，但是不在此范围内。 ","link":"https://shineyangpro.com/centos-7-xia-an-zhuang-lets-encrypt-de-tong-pei-fu-zheng-shu/"},{"title":"CentOS 7下安装Let's Encrypt的通配符证书，出现No package certbot available","content":"一、先执行 yum remove epel-release yum clean all 二、然后在安装 sudo yum -y install yum-utils sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm sudo yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional sudo yum install certbot 三、然后在安装 yum install certbot ","link":"https://shineyangpro.com/centos-7-xia-an-zhuang-lets-encrypt-de-tong-pei-fu-zheng-shu-chu-xian-no-package-certbot-available/"},{"title":"DNS服务器搭建与配置（学习记录）","content":"DNS服务简介： DNS(Domain Name System–域名系统),是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。是一个应用层的协议DNS使用TCP和UDP端口53。 DNS是一个分布式数据库,命名系统采用层次的逻辑结构,如同一颗倒置的树,这个逻辑的树形结构称为域名空间,由于DNS划分了域名空间,所以各机构可以使用自己的域名空间创建DNS信息. 注:DNS域名空间中,树的最大深度不得超过127层,树中每个节点最长可以存储63个字符. DNS名词解释： 域和域名 DNS树的每个节点代表一个域.通过这些节点,对整个域名空间进行划分,成为一个层次结构. 域名空间的每个域的名字,通过域名进行表示. 域名:通常由一个完全合格域名（FQDN）标识.FQDN能准确表示出其相对于DNS 域树根的位置,也就是节点到DNS 树根的完整表述方式,从节点到树根采用反向书写,并将每个节点用“.”分隔,对于DNS 域google 来说,其完全正式域名（FQDN）为google.com. 例如：google为com域的子域,其表示方法为google.com，而www为google域中的子域,可以使用www.google.com表示 注意:通常,FQDN 有严格的命名限制,长度不能超过256 字节,只允许使用字符a-z,0-9,A-Z和减号（-）.点号（.）只允许在域名标志之间（例如“google.com”）或者FQDN 的结尾使用. 域名不区分大小. 由最顶层到下层,可以分成:根域、顶级域、二级域、子域. Internet 域名空间的最顶层是根域（root）,其记录着Internet 的重要DNS 信息,由Internet域名注册授权机构管理,该机构把域名空间各部分的管理责任分配给连接到Internet 的各个组织. “.”全球有13个根(root)服务器 DNS 根域下面是顶级域,也由Internet 域名注册授权机构管理.共有3 种类型的顶级域. 组织域:采用3 个字符的代号,表示DNS 域中所包含的组织的主要功能或活动.比如com 为商业机构组织,edu 为教育机构组织,gov 为政府机构组织,mil 为军事机构组织,net 为网络机构组织,org 为非营利机构组织,int 为国际机构组织. 地址域:采用两个字符的国家或地区代号.如cn 为中国,kr 为韩国,us 为美国. 反向域:这是个特殊域,名字为in-addr.arpa,用于将IP 地址映射到名字（反向查询）. 对于顶级域的下级域,Internet 域名注册授权机构授权给Internet 的各种组织.当一个组织获得了对域名空间某一部分的授权后,该组织就负责命名所分配的域及其子域,包括域中的计算机和其他设备,并管理分配域中主机名与IP 地址的映射信息. 区（Zone）： 区是DNS 名称空间的一部分,其包含了一组存储在DNS 服务器上的资源记录. 使用区的概念,DNS 服务器回答关于自己区中主机的查询,每个区都有自己的授权服务器. 主域名服务器和辅助域名服务器： 当区的辅助服务器启动时,它与该区的主控服务器进行连接并启动一次区传输,区辅助服务器定期与区主控服务器通信,查看区数据是否改变.如果改变了,它就启动一次数据更新传输.每个区必须有主服务器,另外每个区至少要有一台辅助服务器,否则如果该区的主服务器崩溃了,就无法解析该区的名称. 辅助服务器的优点: 容错能力 配置辅助服务器后,在该区主服务器崩溃的情况下,客户机仍能解析该区的名称.一般把区的主服务器和区的辅助服务器安装在不同子网上,这样如果到一个子网的连接中断,DNS 客户机还能直接查询另一个子网上的名称服务器. 减少广域链路的通信量 如果某个区在远程有大量客户机,用户就可以在远程添加该区的辅助服务器,并把远程的客户机配置成先查询这些服务器,这样就能防止远程客户机通过慢速链路通信来进行DNS 查询. 减轻主服务器的负载 辅助服务器能回答该区的查询,从而减少该区主服务器必须回答的查询数. DNS相关概念： DNS服务器： 运行DNS 服务器程序的计算机,储存DNS 数据库信息.DNS 服务器会尝试解析客户机的查询请求. 在解答查询时,如果DNS 服务器能提供所请求的信息,就直接回应解析结果,如果该DNS 服务器没有相应的域名信息,则为客户机提供另一个能帮助解析查询的服务器地址,如果以上两种方法均失败,则回应客户机没有所请求的信息或请求的信息不存在. DNS缓存： 运行DNS 服务器程序的计算机,储存DNS 数据库信息.DNS 服务器会尝试解析客户机的查询请求. 在解答查询时,如果DNS 服务器能提供所请求的信息,就直接回应解析结果,如果该DNS 服务器没有相应的域名信息,则为客户机提供另一个能帮助解析查询的服务器地址,如果以上两种方法均失败,则回应客户机没有所请求的信息或请求的信息不存在. DNS两种查询方式： 递归查询： 递归查询是一种DNS 服务器的查询模式,在该模式下DNS 服务器接收到客户机请求,必须使用一个准确的查询结果回复客户机.如果DNS 服务器本地没有存储查询DNS 信息,那么该服务器会询问其他服务器,并将返回的查询结果提交给客户机. 迭代查询： DNS 服务器另外一种查询方式为迭代查询,当客户机发送查询请求时,DNS 服务器并不直接回复查询结果,而是告诉客户机另一台DNS 服务器地址,客户机再向这台DNS 服务器提交请求,依次循环直到返回查询的结果为止. 正向解析和方向解析： 正向解析：是指域名到IP地址的解析过程。 反向解析：是指IP地址到域名的解析过程。 DNS资源记录： SOA 资源记录(全区唯一) 每个区在区的开始处都包含了一个起始授权记录（Start of Authority Record）,简称SOA 记录. SOA 定义了域的全局参数,进行整个域的管理设置.一个区域文件只允许存在唯一的SOA 记录. NS 资源记录: NS（Name Server）记录是域名服务器记录,用来指定该域名由哪个DNS服务器来进行解析.每个区在区根处至少包含一个NS 记录. A 资源记录 地址（A）资源记录把FQDN 映射到IP 地址. 因为有此记录,所以DNS服务器能解析FQDN域名对应的IP 地址. A ：是IPv4地址。 AAAA是IPv6主机地址。 PTR 资源记录 相对于A 资源记录,指针（PTR）记录把IP地址映射到FQDN. 用于反向查询,通过IP地址,找到域名. CNAME 资源记录 别名记录（CNAME）资源记录创建特定FQDN 的别名.用户可以使用CNAME 记录来隐藏用户网络的实现细节,使连接的客户机无法知道真正的域名. 例:ping百度时,解析到了百度的别名服务器.百度有个cname=www.a.shifen.com.的别名 MX 资源记录 邮件交换（MX）资源记录,为DNS 域名指定邮件交换服务器. 邮件交换服务器是为DNS 域名处理或转发邮件的主机.处理邮件指把邮件投递到目的地或转交另一不同类型的邮件传送者.转发邮件指把邮件发送到最终目的服务器,用简单邮件传输协议SMTP 把邮件发送给离最终目的地最近的邮件交换服务器,或使邮件经过一定时间的排队. DNS工作原理：查询过程 递归查询： 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 hosts文件：以静态映射的方式提供IP地址与主机名的对照表，类似ARP表 域：abc.com是一个域，它可以划分为多个区域，如abc.com和xyz.abc.com 第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找 第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的DNS服务器查询 第四步：‘根DNS服务器’根据查询域名中的‘xyz.com’，再向xyz.com的区域服务器查询 第五步：www.xyz.abc.com的DNS服务器直接解析该域名，将查询到的ip再原路返回给请求查询的主机 迭代查询 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 第二步：上一步无法找到，在DNS本地服务器（即域服务器）查找所有本层次的区域服务器 第三步：本地DNS服务器查不到就查询上一层次的所有区域服务器，以此类推直至根域名DNS服务器‘.’ 第四步：到达根域名服务器后又向下查询，直至查到结果为止。 迭代查询与递归查询结合 递归查询需要经过逐层查询才能获得查询结果，当查询具有许多层次的DNS结构时效率很低，所以一般采用两者相结合的查询方式。 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找 第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的根DNS服务器查询 第四步：根DNS服务器直接将其区域DNS服务器的ip地址返回给本地服务器，而不用再向xyz.com的区域服务器查询。 第五步：本地DNS服务器将结果返回给请求的主机 Linux下DNS服务器安装 BIND简介： BIND（Berkeley Internet Name Domain，伯克利因特网名称域）服务是全球范围内使用最广泛、最安全可靠且高效的域名解析服务程序。DNS域名解析服务作为互联网基础设施服务，其责任之重可想而知，因此建议大家在生产环境中安装部署bind服务程序时加上chroot（俗称牢笼机制）扩展包，以便有效地限制bind服务程序仅能对自身的配置文件进行操作，以确保整个服务器的安全。 安装bind服务和启动步骤： [root@localhost ~]# yum install -y bind* #安装bind组件 [root@localhost ~]# systemctl start named #启动dns服务 [root@localhost ~]# systemctl enable named #设置dns服务开机启动 Created symlink from /etc/systemd/system/multi-user.target.wants/named.service to /usr/lib/systemd/system/named.service. DNS配置的主要文件组： /etc/hosts 主机的一个文件列表 添加记录如:111.13.100.92 www.baidu.com 对于简单的主机名解析（点分表示法），默认在请求DNS或NIS网络域名服务器前，/etc/named.conf 通常会告诉程序先查看此文件。 /etc/resolv.conf 转换程序配置文件 在配置程序请求BIND域名查询服务查询主机名时，必须告诉程序使用哪个域名服务器和IP地址来完成这个任务 /etc/named.conf BIND主文件 设置一般的name参数，指向该服务器使用的域数据库的信息源 /var/named/named.ca 根域名配置服务器指向文件 指向根域名配置服务器，用于告诉缓存服务器初始化 /var/named/localhost.zone localhost区正向域名解析文件 用于将本地IP地址（127.0.0.1）转换为本地回送IP地址（127.0.0.1） /var/named/name.local localhost区反向域名解析文件 用于将localhost名字转换为本地回送IP地址（127.0.0.1） /etc/named.rfc1912.zones 区块设置文件 name.conf文件的主要配置信息： acl 定义ip地址的访问控制清单 control 定义rndc使用的控制通道 include 把其他的文件包含到配置文件中 key 定义授权的安全密钥 logging 定义日志内容和位置 options 定义全局配置选项和默认值 server 定义远程服务的特征 zone 定义一个区 DNS的资源记录（Resource Record, RR）格式： DNS域名数据库有资源记录和区文件指令组成，由SOA（Start Of Authority起始授权机构记录，SOA 记录说明了在众多NS记录里那一台才是主名称服务器。 RR开始，同时包括NS RR； 正向解析文件包括A internet Address，作用，FQDN --&gt; IP） MX （Mail eXchanger，邮件交换器） CNAME（Canonical NAME 别名） 反向解析文件包括PTR（PTR: PoinTeR，IP --&gt; FQDN） RR 语法：name [TTL] IN type value （字段之间由空格和制表符隔开） 注意： (1) TTL可从全局继承 (2) @可用于引用当前区域的名字 (3) 同一个名字可以通过多条记录定义多个不同的值；此时 DNS服务器会以轮询方式响应 (4) 同一个值也可能有多个不同的定义名字；通过多个不同的 名字指向同一个值进行定义；此仅表示通过多个不同的名字 可以找到同一个主机 SOA记录：name: 当前区域的名字，例如“heiye.com.” value: 有多部分组成 (1) 当前区域的主DNS服务器的FQDN，也可以使用当前区域的名字； (2) 当前区域管理员的邮箱地址；地址中不能使用@符号，一般用.替换 如linuxedu.heiye.com (3) 主从服务区域传输相关定义以及否定的答案的统一的TTL 例如： heiye.com. 86400 IN SOA ns.heiye.com. nsadmin.heiye.com. ( 2015042201 ; 序列号 2H ; 刷新时间 10M ; 重试时间 1W ; 过期时间 1D ; 否定答案的TTL值 ) NS记录：name: 当前区域的名字 value: 当前区域的某DNS服务器的名字，例如 ns.heiye.com. 注意：一个区域可以有多个NS记录 例如：heiye.com. IN NS ns1.heiye.com. heiye.com. IN NS ns2.heiye.com. 注意： (1) 相邻的两个资源记录的name相同时，后续的可省略 (2) 对NS记录而言，任何一个ns记录后面的服务器名字 ，都应该在后续有一个A记录 MX记录（Mail eXchanger）：name: 当前区域的名字 value: 当前区域的某邮件服务器(smtp服务器)的主机名 ， 一个区域内，MX记录可有多个； 但每个记录的value之前应 该有一个数字(0-99)，表示此服务器的优先级；数字越小优 先级越高 例如： heiye.com. IN MX 10 mx1.heiye.com. IN MX 20 mx2.heiye.com. 注意： (1) 对MX记录而言，任何一个MX记录后面的服务器名字 ，都应该在后续有一个A记录 A记录（Addrss）:name: 某主机的FQDN，例如www.heiye.com. value: 主机名对应主机的IP地址 例如： www.heiye.com. IN A 1.1.1.1 www.heiye.com. IN A 2.2.2.2 mx1.heiye.com. IN A 3.3.3.3 mx2.heiye.com. IN A 4.4.4.4 *.heiye.com. IN A 5.5.5.5 heiye.com. IN A 6.6.6.6 避免用户写错名称时给错误答案，可通过泛域名解析进行解 析至某特定地址 其他记录：AAAA: name: FQDN value: IPv6 PTR: name: IP，有特定格式，把IP地址反过来写，1.2.3.4，要写 作4.3.2.1；而有特定后缀：in-addr.arpa.，所以完整写法为 ： 4.3.2.1.in-addr.arpa. value: FQDN 例如： 4.3.2.1. in-addr.arpa. IN PTR www.heiye.com. 如1.2.3为网络地址，可简写成： 4 IN PTR www.heiye.com. 注意：网络地址及后缀可省略；主机地址依然需要反着写 别名记录:name: 别名的FQDN value: 真正名字的FQDN 例如： www.heiye.com. IN CNAME websrv.heiye.com. named字段： （1）根域以” . “结束，并且只有一个，没有上级域。而在Internet中，根域一般不需要表现出来。 （2）@：默认域，文件使用$ORIGIN domain 来说明默认域。 （3）ttl 全称”Time to Live “，以秒为单位记录该资源记录中存放高速缓存中的时间长度。通常此处设为空，表示采用SOA的最小ttl值。 （4）IN：将该记录标志为一个Internet DNS资源记录。 type字段: (1)A记录：主机名对应的IP地址记录，用户可将该域名下网站服务器指向自己的Web服务器，同时也可设置域名的二级域名。 (2)MX记录：邮件交换记录可将该域下所有邮件服务器 指向自己的邮件服务器，只需在线填写服务器的IP地址。 (3)CNAME记录：别名记录，可允许多个名字映射到同一计算机，通常用于同时提供Web和邮件服务器的计算机。 (4)SOA记录：一个授权区的开始，配置文件的第一个记录必须是SOA的开始。 (5)PTR记录：用于地址到主机名的映射。 (6)HINFO记录：由一组描述主机的信息文件组成，通常包括硬件名称和操作系统名称。 value字段： （1）A :存放IP地址。 （2）CNAME：设置主机别名。 （3）HINFO：通常为两行，分别对应Hareware（计算机硬件名称）和OS-type（操作系统名称）。 （4）NS：域名服务器的名称。 （5）PTR:主机真实名称。 测试检查配置文件错误的工具：nslookup、dig、named-checkzone、host、named-checkconf及dlint。 Linux下DNS服务器配置实验 配置DNS正向解析： 在配置Bind服务时，主要用到以下三个配置文件： 主配置文件（/etc/named.conf）：用来定义bind服务程序的运行。 区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。 数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。 第一步：修改主配置文件/etc/named.conf。将监听地址和运行查询的地址都改为 any，分别表示服务器上的所有IP地址均可提供DNS域名解析服务，以及允许所有人对本服务器发送DNS查询请求。 第二步：修改区域配置文件（/etc/named.rfc1912.zones）。用来保存域名和IP地址对应关系的所在位置。在这个文件中，定义了域名与IP地址解析规则保存的文件位置以及服务类型等内容，而没有包含具体的域名、IP地址对应关系等信息。服务类型有三种，分别为hint（根区域）、master（主区域）、slave（辅助区域），其中常用的master和slave指的就是主服务器和从服务器。 zone &quot;example.com&quot; IN { type master; file &quot;example.com.zone&quot;; DNS默认端口是53的TCP和UPD,UDP是供用户查询的，主从复制用TCP和UDP的53端口都用。 BIND的ACL：bind有四个内置的acl: none: 没有一个主机 any: 任意主机 localhost: 本机 localnet: 本机的IP同掩码运算后得到的网络地址段 注意：只能先定义，后使用；因此一般定义在配置文件中， 处于options的前面，当然也可自定义如下 acl lan｛ 192.168.25.0/24 } ; 访问控制： 访问控制的指令： allow-query {}： 允许查询的主机；白名单 allow-transfer {}：允许区域传送的主机；（白名单，一般用于主从） allow-recursion {}: 允许递归的主机,建议全局使用 allow-update {}: 允许更新区域数据库中的内容 第三步：编辑数据配置文件。**从/var/named目录中复制一份正向解析的模板文件（named.localhost），然后把域名和IP地址的对应数据填写数据配置文件中并保存。在复制时记得加上-a参数，这可以保留原始文件的所有者、所属组、权限属性等信息，以便让bind服务程序顺利读取文件内容： [root@localhost named]# cp -a named.localhost example.com [root@localhost named]# vim example.com.zone $TTL 1D @ IN SOA @ example.com. ( #授权信息开始: #DNS区域的地址,在域地址后面还可以加管理员邮箱，不能加@，用.代替。 20181001 ; serial #更新序列号 1D ; refresh #更新时间 1H ; retry #重试时间 1W ; expire #失效时间 3H ) ; minimum #无效解析记录的缓存时间 NS ns.example.com. #DNS区域的地址 ns A 192.168.245.128 #地址记录 www A 192.168.245.128 #www站点记录 mail A 192.168.245.129 #地址记录 MX 10 mail.example.com. #邮箱交换记录 example.com. A 192.168.245.200 # 即使不写主机名，DNS也能解析到另外一个指定的地址 $GENERATE 1-245 server$ A 1.1.1.$ #如果服务器过多，对应主机名也很多，则可以这样写.例如： #server1.example.com对应地址为：1.1.1.1 #server100.exmaple.com对应地址为：1.1.1.50 bbs CNAME www #别名记录 * A 192.168.245.128 #“*”代表所有，即便主机www写错，DNS也能正确解析出来。这就是泛域名解析 第四步：检查配置,重启服务和测试。 检查和重启服务： [root@localhost ~]# named-checkconf #检查主配置文件语法 [root@localhost ~]# named-checkzone eample.com /var/named/example.com.zone #检查区域配置文件语法 /var/named/example.com.zone:13: ignoring out-of-zone data (example.com) zone eample.com/IN: loaded serial 20181001 [root@localhost ~]# vi /etc/resolv.conf #进入该配置文件，指定使用的域名解析服务器。 # Generated by NetworkManager nameserver 192.168.245.128 search 192.168.245.128 [root@localhost ~]# systemctl restart named #重启服务 测试： 配置DNS反向解析： 在DNS域名解析服务中，反向解析的作用是将用户提交的IP地址解析为对应的域名信息，它一般用于对某个IP地址上绑定的所有域名进行整体屏蔽，屏蔽由某些域名发送的垃圾邮件。它也可以针对某个IP地址进行反向解析，大致判断出有多少个网站运行在上面。当购买虚拟主机时，可以使用这一功能验证虚拟主机提供商是否有严重的超售问题。 第一步：配置区域文件。 反向解析是把IP地址解析成域名格式，因此在定义zone（区域）时应该要把IP地址反写，比如原来是192.168.10.0，反写后应该就是10.168.192，而且只需写出IP地址的网络位即可。 [root@localhost ~]# vim /etc/named.rfc1912.zones #在中添加反向数据文件的记录 zone &quot;245.168.192.in-addr.arpa&quot; IN { type master; file &quot;245.168.192.arpa&quot;; }; 第二步：编辑数据配置文件。 反向解析是把IP地址解析成域名格式，因此在定义zone（区域）时应该要把IP地址反写，比如原来是192.168.10.0，反写后应该就是10.168.192，而且只需写出IP地址的网络位即可。 [root@localhost ~]# cp -a /var/named/named.loopback /var/named/245.168.192.arpa [root@localhost ~]# vi /var/named/245.168.192.arpa #编辑反正配置文件即可，和正向解析格式类似 #PTR为指针记录，仅用于反向解析中。 第三步：检查配置文件，重启服务，测试。 [root@localhost ~]# named-checkconf [root@localhost ~]# named-checkzone 245.168.192 /var/named/245.168.192.arpa zone 245.168.192/IN: loaded serial 20181001 OK [root@localhost ~]# systemctl restart named 搭建DNS主从服务器： 从而起到备份解析记录与负载均衡的作用，因此通过部署从服务器可以减轻主服务器的负载压力，还可以提升用户的查询效率。 第一步：在主服务器的区域配置文件中允许该从服务器的更新请求，即修改allow-update {允许更新区域信息的主机地址;};参数，然后重启主服务器的DNS服务程序。 [root@localhost ~]# vi /etc/named.rfc191 zone &quot;example.com&quot; IN { type master; file &quot;example.com.zone&quot;; allow-update { 192.168.245.129; }; }; zone &quot;245.168.192.in-addr.arpa&quot; IN { type master; file &quot;245.168.192.arpa&quot;; allow-update { 192.168.245.129; }; }; [root@localhost ~]# systemctl restart named 第二步： 在从服务器中填写主服务器的IP地址与要抓取的区域信息，然后重启服务。注意此时的服务类型应该是slave（从），而不再是master（主）。masters参数后面应该为主服务器的IP地址，而且file参数后面定义的是同步数据配置文件后要保存到的位置，稍后可以在该目录内看到同步的文件。 [root@localhost ~]# vi /etc/named.conf options { listen-on port 53 { any; }; #改为any， listen-on-v6 port 53 { ::1; }; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { any; }; #改为any，允许所有主机查询 [root@localhost ~]# vi /etc/named.rfc191 zone &quot;example.com&quot; IN { type master; file &quot;example.com.zone&quot;; allow-update { 192.168.245.129; }; }; zone &quot;245.168.192.in-addr.arpa&quot; IN { type master; file &quot;245.168.192.arpa&quot;; allow-update { 192.168.245.129; }; }; [root@localhost ~]# vi /etc/named.conf^C [root@localhost ~]# iptables -F #关闭防火墙 [root@localhost ~]# setenforce 0 setenforce: SELinux is disabled [root@localhost ~]# systemctl restart named [root@localhost ~]# systemctl enable named 重启以后，成功的话会在/var/named/slaves/下看见同步的文件。 [root@localhost named]# ls /var/named/slaves/ 245.168.192.arpa example.com.zone 第三步：测试。可将从服务的DNS地址改为自己，进行地址解析。 [root@localhost named]# dig www.example.com ; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-37.el7 &lt;&lt;&gt;&gt; www.example.com ;; global options: +cmd ;; Got answer: ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9870 ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;www.example.com. IN A ;; ANSWER SECTION: www.example.com. 86400 IN A 192.168.245.128 ;; AUTHORITY SECTION: example.com. 86400 IN NS ns.example.com. ;; ADDITIONAL SECTION: ns.example.com. 86400 IN A 192.168.245.128 ;; Query time: 1 msec ;; SERVER: 192.168.245.129#53(192.168.245.129) ;; WHEN: Tue Oct 16 11:19:04 CST 2018 ;; MSG SIZE rcvd: 93 这种情况下，证明DNS主从服务器搭建成功。一旦主DNS发生故障，将自动利用DNS从服务器进行解析，实现了某种程度上的容错。 配置DNS安全的加密传输： TSIG主要是利用了密码编码的方式来保护区域信息的传输（Zone Transfer），即TSIG加密机制保证了DNS服务器之间传输域名区域信息的安全性。 第一步：在主服务上生产密钥。dnssec-keygen命令用于生成安全的DNS服务密钥，其格式为“dnssec-keygen [参数]”，常用的参数以及作用如下： 参数 作用 -a 指定加密算法，包括RSAMD5（RSA）、RSASHA1、DSA、NSEC3RSASHA1、NSEC3DSA等 -b 密钥长度（HMAC-MD5的密钥长度在1~512位之间） -c 密钥的类型（HOST表示与主机相关） 使用下述命令生成一个主机名称为master-slave的128位HMAC-MD5算法的密钥文件。在执行该命令后默认会在当前目录中生成公钥和私钥文件，在传输配置文件中会用到该秘钥。 [root@localhost ~]# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST master-slave Kmaster-slave.+157+15811 [root@localhost ~]# cat Kmaster-slave.+157+47396.key master-slave. IN KEY 512 3 157 9+m1PlQOAF7xnMLClzNmXw== [root@localhost ~]# cat Kmaster-slave.+157+47396.private Private-key-format: v1.3 Algorithm: 157 (HMAC_MD5) Key: 9+m1PlQOAF7xnMLClzNmXw== Bits: AAA= Created: 20181016033058 Publish: 20181016033058 Activate: 20181016033058 第二步：在主服务器中创建验证秘钥文件。 进入bind服务程序用于保存配置文件的目录，把刚刚生成的密钥名称、加密算法和私钥加密字符串按照下面格式写入到tansfer.key传输配置文件中。为了安全起见，我们需要将文件的所属组修改成named，并将文件权限设置得要小一点，然后把该文件做一个硬链接到/etc目录中。 [root@localhost ~]# vim /var/named/chroot/etc/transfer.key key &quot;master-slave&quot; { algorithm hmac-md5; secret &quot;9+m1PlQOAF7xnMLClzNmXw==&quot;; }; [root@localhost ~]# chown root:named/var/named/chroot/etc/transfer.key [root@localhost ~]# ln /var/named/chroot/etc/transfer.key /etc/transfer.key 第三步：开启主服务器密钥验证功能： 开启并加载Bind服务的密钥验证功能。首先需要在主服务器的主配置文件中加载密钥验证文件，然后进行设置，使得只允许带有master-slave密钥认证的DNS服务器同步数据配置文件： include &quot;/etc/transfer.key&quot;; //在主服务器中添加此条 options { listen-on port 53 { any; }; listen-on-v6 port 53 { ::1; }; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { any; }; allow-transfer { key master-slave; }; 至此，DNS主服务器的TSIG密钥加密传输功能就已经配置完成。此时清空DNS从服务器同步目录中所有的数据配置文件，然后再次重启bind服务程序，这时就已经获取不到主服务器的配置文件了。 第四步：配置从服务器支持秘钥验证： [root@localhost ~]# scp /var/named/chroot/etc/transfer.key root@192.168.245.128:/var/named/chroot/etc/transfer.key root@192.168.245.128's password: transfer.key 100% 79 0.1KB/s 00:00 [root@localhost ~]# chown root:named /var/named/chroot/etc/transfer.key [root@localhost ~]# ln /var/named/chroot/etc/transfer.key /etc/transfer.key 第五步：配置从服务器配置文件： [root@localhost ~]# vi /etc/named.conf include &quot;/etc/transfer.key&quot;; #在此添加秘钥文件 options { listen-on port 53 { any; }; listen-on-v6 port 53 { ::1; }; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; allow-query { any; }; /* recursion. reduce such attack surface */ recursion yes; dnssec-enable yes; dnssec-validation yes; /* Path to ISC DLV key */ bindkeys-file &quot;/etc/named.iscdlv.key&quot;; managed-keys-directory &quot;/var/named/dynamic&quot;; pid-file &quot;/run/named/named.pid&quot;; session-keyfile &quot;/run/named/session.key&quot;; }; #在此添加主服务器地址，位置不能太靠前，否则bind服务程序会因为没有加载完预设参数而报错： server 192.168.245.128 { keys { master-slave; }; }; logging { channel default_debug { file &quot;data/named.run&quot;; severity dynamic; }; }; zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; include &quot;/etc/named.rfc1912.zones&quot;; include &quot;/etc/named.root.key&quot;; 至此，主从服务器配置完成，重启服务后，可在/var/named/slaves/目录下看到同步过来的文件。 [root@localhost ~]# systemctl restart named [root@localhost ~]# ls /var/named/slaves/ 245.168.192.arpa example.com.zone 配置DNS缓存服务器： DNS缓存服务器（Caching DNS Server）是一种不负责域名数据维护的DNS服务器。简单来说，缓存服务器就是把用户经常使用到的域名与IP地址的解析记录保存在主机本地，从而提升下次解析的效率。DNS缓存服务器一般用于经常访问某些固定站点而且对这些网站的访问速度有较高要求的企业内网中，但实际的应用并不广泛。而且，缓存服务器是否可以成功解析还与指定的上级DNS服务器的允许策略有关。 [root@localhost ~]# vim /etc/named.conf options { 10 listen-on port 53 { any; }; 11 listen-on-v6 port 53 { ::1; }; 12 directory &quot;/var/named&quot;; 13 dump-file &quot;/var/named/data/cache_dump.db&quot;; 14 statistics-file &quot;/var/named/data/named_stats.txt&quot;; 15 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; 16 allow-query { any; }; 17 forwarders { 目标地址; }; #在此处添加转发地址即可 ...... ","link":"https://shineyangpro.com/dns-fu-wu-qi-da-jian-yu-pei-zhi-xue-xi-ji-lu/"},{"title":"Golang项目如何部署到linux服务器","content":"方法比较简单，如下: 把服务器上配置成本地一样的环境，包括项目里面所依赖的包； 项目源码拷贝到服务器，在服务器上进行编译 go build main.go 编译后会在同级目录生成可执行文件main。 最后执行 ./main 就行了。 如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。 执行完nohup ./main &amp; 后会出现一个程序编号： [1]29643 如果想 关闭程序，可以是用kill命令来关闭,如果不记得程序的id,可以是用如下命令来查看: ps aux | grep 进程名 ","link":"https://shineyangpro.com/golang-xiang-mu-ru-he-bu-shu-dao-linux-fu-wu-qi/"},{"title":"Golang Gin 实战（四）| URL查询参数的获取和原理分析","content":"查询参数(query parames) Querystring parameters ，翻译成中文我只能叫查询参数了，不过觉得挺别捏的。其实这种参数我们并不陌生，比如： https://www.flysnow.org/search?q=golang&amp;sitesearch=https%3A%2F%2Fwww.flysnow.org URL查询参数，或者也可以简称为URL参数，是存在于我们请求的URL中，以?为起点，后面的k=v&amp;k1=v1&amp;k2=v2这样的字符串就是查询参数，比如我上面示例中的： ?q=golang&amp;sitesearch=https%3A%2F%2Fwww.flysnow.org 这个示例中有两个查询参数键值对: q=golang sitesearch=https%3A%2F%2Fwww.flysnow.org 第一个key是q，对应的值是golang。第二个key是sitesearch,对应的值是https%3A%2F%2Fwww.flysnow.org，它们通过&amp;相连。在URL中，多个查询参数键值对通过&amp;相连。 Gin获取查询参数 在Gin中，为我们提供了简便的方法来获取查询参数的值，我们只需要知道查询参数的key（参数名）就可以了。 func main() { r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) { c.String(200, c.Query(&quot;wechat&quot;)) }) r.Run(&quot;:8080&quot;) } 我们运行这段代码，打开浏览器访问http://localhost:8080/?wechat=flysnow_org,就可以看到flysnow_org文字。这表示我们通过c.Query(&quot;wechat&quot;)获取到了查询参数wechat的值是flysnow_org。 Query方法为我们提供了获取对应key的值的能力，如果该key不存在，则返回&quot;&quot;字符串。如果对于一些数字参数，比如id如果返回为空的话，我们进行字符串转数字的时候会报错，这时候，我们就可以通过DefaultQuery方法指定一个默认值： c.DefaultQuery(&quot;wechat&quot;, &quot;flysnow_org&quot;) c.DefaultQuery(&quot;id&quot;, &quot;0&quot;) 比如这样，尤其是第二个例子，默认为0，让我们字符串转数字很方便。 func (c *Context) Query(key string) string { value, _ := c.GetQuery(key) return value } func (c *Context) DefaultQuery(key, defaultValue string) string { if value, ok := c.GetQuery(key); ok { return value } return defaultValue } 看下这两个函数的源代码实现，它们都是调用的GetQuery方法获取对应的值，唯一不同的是DefaultQuery会判断对应的key是否存在，如果不存在的话，则返回默认defaultValue值。 原理解析 从以上两个获取查询参数值的方法可以看到，他们调用的都是GetQuery，这也是gin.Context的一个方法，它和Query唯一不同的是，它返回两个值，可以告诉我们要获取的key是否存在。 value, ok := c.GetQuery(&quot;id&quot;) 如果我们自己的业务中，需要这类功能，可以用GetQuery来代替Query方法。 GetQuery方法的底层实现其实是c.Request.URL.Query().Get(key)，通过url.URL.Query()来获取所有的参数键值对。 本质上是调用的GetQueryArray，取的数组中第一个值 func (c *Context) GetQuery(key string) (string, bool) { if values, ok := c.GetQueryArray(key); ok { return values[0], ok } return &quot;&quot;, false } func (c *Context) GetQueryArray(key string) ([]string, bool) { c.getQueryCache() //缓存所有的键值对 if values, ok := c.queryCache[key]; ok &amp;&amp; len(values) &gt; 0 { return values, true } return []string{}, false } func (c *Context) getQueryCache() { if c.queryCache == nil { c.queryCache = c.Request.URL.Query() } } 从以上的实现代码中，可以看到最终的实现都在GetQueryArray方法中，找到对应的key就返回对应的[]string，返回就返回空数组。 这里Gin进行了优化，通过缓存所有的键值对，提升代码的查询效率。这里缓存的queryCache本质上是url.Values，也是一个map[string][]string。 type Values map[string][]string 其中c.Request.URL.Query()这个方法就是把?k=v&amp;k1=v1&amp;k2=v2这类查询键值对转换为map[string][]string，所以还是很耗性能的，这里Gin采用了缓存的做法提高了性能挺好，这也是Gin成为性能最快的Golang Web 框架的原因之一吧。 ","link":"https://shineyangpro.com/golang-gin-shi-zhan-si-or-url-cha-xun-can-shu-de-huo-qu-he-yuan-li-fen-xi/"},{"title":"Golang-Gin框架的安装和使用","content":"Golang的安装 根据所使用的电脑操作系统，下载相对应的版本Golang下载 比如我的电脑是macOS系统，下载的是： 选择自己需要的版本安装 安装完成后打开终端，执行以下命令: vi ~/.bash_profile .bash_profile添加的内容如下： export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 然后让配置文件生效: source ~/.bash_profile 查看GoLang是否安装成功，执行命令: go version 初始化项目目录 选一个你自己喜欢的路径，创建一个文件夹，比如我的是/Users/yangchen/Desktop/Go这个文件夹下进 1、进入文件: cd /Users/yangchen/Desktop/Go 2、创建一个项目文件并进入: mkdir api &amp;&amp; cd api 3、开启Go modules go env -w GO111MODULE=on 4、设置 GOPROXY 代理，也可以把GOPROXY写入.bash_profile中 go env -w GOPROXY=https://goproxy.cn,direct 5、初始化 Go modules（它将会生成 go.mod 文件，MODULE_PATH 填写的是模块引入路径，如果想要把项目放到Github上，可以填写GitHub的项目路径，这个根据自己情况填写。） go mod init api 安装Gin框架 在api文件夹下，执行 go get -u github.com/gin-gonic/gin 安装完毕后，创建一个main.go文件，测试下Gin框架是否能使用main.go，写入以下代码: package main import &quot;github.com/gin-gonic/gin&quot; func main() { r := gin.Default() r.GET(&quot;/ping&quot;, func(context *gin.Context) { context.JSON(200,gin.H{ &quot;data&quot;:&quot;success&quot;, }) }) r.Run() } 然后终端执行： go run test.go 在浏览器打开127.0.0.1:8080/ping这个地址，可以看到有返回的数据，代表Gin框架安装和使用成功。 Gin相关的使用，可以参考点我传送 ","link":"https://shineyangpro.com/golang-gin-kuang-jia-de-an-zhuang-he-shi-yong/"},{"title":"Centos7 安装Go环境","content":"下载最新版的SDK压缩包，传送门： 点击下载Linux版本 使用WinScp软件将安装包上传到/opt/目录下， 使用解压命令解压刚上传的压缩文件到/usr/loacl/下：tar -zxvf go1.13.7.linux-amd64.tar.gz -C /usr/local/，解压完之后进去该目录即可看到一个目录：go。 指定Go项目的存放路径，在/usr/loacl/下，键入命令：mkdir gocode即可。 配置环境 修改配置文件，键入命令：vim /etc/profile，在正常模式下，键入大写字母G，立刻返回到文件尾，键入小写i进入编辑模式，在末尾追加如下代码： export GOROOT=/usr/local/go export GOPATH=/usr/local/gocode //自己项目的目录 export PATH=$GOPATH/bin:$GOROOT/bin:$PATH source /etc/profile使配置文件立即生效，继而输入go version（查看版本号）和go env（查看go环境的配置信息），如下则表示配置成功！ 到这里Go环境基本上就配置完成了 ","link":"https://shineyangpro.com/centos7-an-zhuang-go-huan-jing/"},{"title":"安装MySQL CentOS","content":"要在CentOS 7上安装MySQL 8，请执行以下步骤： 步骤1.设置Yum存储库 执行以下命令以在CentOS上启用MySQL yum存储库： rpm -Uvh https://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm 步骤2.安装MySQL 8 Community Server 由于MySQL yum存储库具有用于多个MySQL版本的多个存储库配置，因此您需要禁用mysql repo文件中的所有存储库 sed -i 's/enabled=1/enabled=0/' /etc/yum.repos.d/mysql-community.repo 并执行以下命令来安装MySQL 8： yum --enablerepo=mysql80-community install mysql-community-server 步骤3.启动MySQL服务 使用以下命令启动mysql服务： service mysqld start 步骤4.显示root用户的默认密码 当您安装MySQL 8.0时，将为root用户帐户授予一个临时密码。要显示root用户帐户的密码，请使用以下命令： grep &quot;A temporary password&quot; /var/log/mysqld.log 这是输出： [Note] A temporary password is generated for root@localhost: hjkygMukj5+t783 == 请注意，您的临时密码将有所不同。您需要此密码来更改root用户帐户的密码。== 步骤5. MySQL安全安装 执行命令mysql_secure_installation以保护MySQL服务器： mysql_secure_installation 它将提示您输入根帐户的当前密码： Enter password for user root: 在上方输入临时密码，然后按Enter。将显示以下消息： The existing password for the user account root has expired. Please set a new password. New password: Re-enter new password: 您需要为root帐户输入两次新密码。它将提示您一些问题，建议键入是（y）： Remove anonymous users? (Press y|Y for Yes, any other key for No) : y Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y 步骤6.重新启动并启用MySQL服务 使用以下命令重新启动mysql服务： service mysqld restart 并在系统启动时自动启动mysql服务： chkconfig mysqld on 步骤7.连接到MySQL 使用以下命令连接到MySQL服务器： mysql -u root -p 它将提示您输入root用户密码。您输入密码，然后按Enter： 输入密码： 它将显示mysql命令： mysql&gt; 使用SHOW DATABASES显示当前服务器中的所有数据库： mysql&gt; show databases; 这是输出： +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.05 sec) ","link":"https://shineyangpro.com/an-zhuang-mysql-centos/"},{"title":"远程连接数据库出现：主机“ xxx.xx.xxx.xxx”不允许连接到该MySQL服务器","content":"遇到这种问题，只需要创建个用户就好了 CREATE USER 'username'@'%' IDENTIFIED BY 'password'; GRANT ALL PRIVILEGES ON . TO 'username'@'%' WITH GRANT OPTION; FLUSH PRIVILEGES; ","link":"https://shineyangpro.com/yuan-cheng-lian-jie-shu-ju-ku-chu-xian-zhu-ji-xxxxxxxxxxxbu-yun-xu-lian-jie-dao-gai-mysql-fu-wu-qi/"},{"title":"Google Cloud开启SSH及设置root密码","content":"设置root密码 1、先选择从浏览器打开ssh连接服务器 2、切换到root账号 sudo -i 3、设置root密码 passwd 然后会要求输入新密码，然后再重复一次密码，输入密码的时候不会显示出来，所以直接输入密码，然后回车，再然后重复输入密码回车 开启SSH权限 方法一 1、修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 2、然后再输”i”进入编辑模式 i 3、找到以下内容并修改 PermitRootLogin yes //默认为no，需要开启root用户访问改为yes PasswordAuthentication yes //默认为no，改为yes开启密码登陆 4、修改完成后，再下按 esc 键，然后再输入(Mac用户的话直接lshift + Z,Z连续按两下) :wq 5、重启SSH服务 service sshd restart 方法二 CentOS和Debian通用，输入以下两条命令 sed -i 's/PermitRootLogin no/PermitRootLogin yes/g' /etc/ssh/sshd_config sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config Ubuntu系统，输入以下两条命令 sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config 重启服务器 reboot ","link":"https://shineyangpro.com/google-cloud-kai-qi-ssh-ji-she-zhi-root-mi-ma/"},{"title":"CentOS 7命令行安装GNOME、KDE图形界面","content":"安装 X 窗口系统 1、首先安装X(X Window System)，命令为： yum groupinstall &quot;X Window System&quot; //注意有引号 如果没用权限，在前面添加sudo 然后系统会自动寻找最近的网络进行相关文件的下载 选择 y ，然后开始下载需要的 package 选择 y，开始进行安装 当出现 Complete！说明这里安装成功了。 在这里我们可以检查一下我们已经安装的软件以及可以安装的软件，命令为： yum grouplist 安装图形界面软件 GNOME 然后我们开始安装我们需要的图形界面软件，GNOME(GNOME Desktop) 特别注意！！！！一定要注意名称必须对应，否则会出现No packages in any requested group available to install or update 的错误。这是因为不同版本的CentOS的软件名可能不同（其他 Linux 系统也是类似的） 如上图，安装命令为： yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; 选择 y 开始下载需要安装的 package 到这里就安装完成了。 这时，我们可以通过命令 startx 进入图形界面，第一次进入会比较慢，请耐心等待。（可能需要重启，命令为reboot） ps： 如果安装完成后，虚拟机无法打开，我们需要调整虚拟机分配内存大小（注意不是磁盘大小），1024M基本够用。 如果安装完成后，虚拟机报错0x0000005c，请关闭虚拟机的3D加速功能（取消勾选） 更新系统的默认运行级别 经过上面的操作，系统启动默认还是命令行页面的，需要我们进行切换。如果想要使系统启动即为图形化窗口，需要执行下面的命令： ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 解决办法: 1、如果出现 No packages in any requested group available to install or update When I install the “X Window System” [root@localhost ~]# yum groupinstall &quot;X Window System&quot; Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: centos.01link.hk * extras: centos.01link.hk * updates: centos.01link.hk Maybe run: yum groups mark install (see man yum) No packages in any requested group available to install or update 出现这种错误，说明你已经安装了，不能再安装，查看隐藏的列表命令: yum group list hidden 2、如果出现no screens found(EE),如下 xauth: file /root/.serverauth.25989 does not exist X.Org X Server 1.20.1 X Protocol Version 11, Revision 0 Build Operating System: 3.10.0-957.1.3.el7.x86_64 Current Operating System: Linux centos7.cs1cloud.internal 3.10.0-957.12.2.el7.x86_64 #1 SMP Tue May 14 21:24:32 UTC 2019 x86_64 Kernel command line: BOOT_IMAGE=/boot/vmlinuz-3.10.0-957.12.2.el7.x86_64 root=UUID=dadd7363-eae7-4b4b-85a2-ed94705b1bed ro nomodeset crashkernel=auto rhgb quiet LANG=en_US.UTF-8 Build Date: 14 March 2019 10:37:36AM Build ID: xorg-x11-server 1.20.1-5.3.el7_6 Current version of pixman: 0.34.0 Before reporting problems, check http://wiki.x.org to make sure that you have the latest version. Markers: (--) probed, (**) from config file, (==) default setting, (++) from command line, (!!) notice, (II) informational, (WW) warning, (EE) error, (NI) not implemented, (??) unknown. (==) Log file: &quot;/var/log/Xorg.0.log&quot;, Time: Thu May 30 08:54:16 2019 (==) Using system config directory &quot;/usr/share/X11/xorg.conf.d&quot; (EE) Fatal server error: (EE) no screens found(EE) (EE) Please consult the The X.Org Foundation support at http://wiki.x.org for help. (EE) Please also check the log file at &quot;/var/log/Xorg.0.log&quot; for additional information. (EE) (EE) Server terminated with error (1). Closing log file. xinit: giving up xinit: unable to connect to X server: Connection refused xinit: server error 解决办法: 加载显示驱动程序时出现问题，因此需要创建一个新的配置文件并更改显示驱动程序： 您可以使用以下命令检查当前的VGA： lspci | grep -e VGA -e 3D 现在编辑驱动程序： cd /root X -configure nano /root/xorg.conf.new 更改： Driver &quot;modesetting&quot; 为 Driver &quot;dummy&quot; 保存并运行： X -config /root/xorg.conf.new &amp; ","link":"https://shineyangpro.com/centos-7-ming-ling-xing-an-zhuang-gnomekde-tu-xing-jie-mian/"},{"title":"iOS KVO和NotificationCenter有什么区别？","content":"基础概念 KVO(Key-Value Observing)，俗称键值监听。它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了 通知中心(NSNotificationCenter)实际是在程序内部提供了一种广播机制。把接收到的消息，根据内部的消息转发表，将消息转发给需要的对象。这句话其实已经很明显的告诉我们要如何使用通知了。第一步：在需要的地方注册要观察的通知，第二步：在某地方发送通知。 从概念上讲，键值观察（KVO）是一种模式，其中一个对象可以观察另一个对象的属性值以了解更改。同时，通知中心是一个单例对象，允许将发生的事件通知给对象。 主要区别 KVO仅可用于观察对象的属性。而NSNotification可以更广泛地用于观察任意对象的变化。 KVO通常用于跟踪对象的特定更改（即“文本”属性），而NSNotifications用于跟踪通用的“事件”（例如用户完成注册流程）。KVO将自动为您提供有用的信息，例如属性的先前值和发生的更改的类型；NSNotifications仅发出您明确指定的任何其他元数据。 您可以使用NSNotifications编写一个KVO风格的系统，每次您执行类似[[object setText：@“ new value”]]之类的操作时，都会发出特定的NSNotification。但是，KVO的要点在于，它不需要您必须为此类系统编写的粘合代码。 在内部，KVO不使用NSNotificationCenter，而是使用一些运行时技巧来避免所述胶合代码； ","link":"https://shineyangpro.com/ios-kvo-he-notificationcenter-you-shi-me-qu-bie/"},{"title":"iOS 进程和线程的区别(初版)","content":"基本概念 线程 1、线程是CPU调度的最小单元； 2、线程的作用：执行app的代码； 3、一个进程（App）至少有一个线程，这个进程叫做主线程； 进程 1、在iOS 中 一个进程就是一个正在运行的一个应用程序; 比如 QQ.app ，而且一个app只能有一个进程 不像安卓支持多个进程。 2、每一个进度都是独立的，每一个进程均在专门且手保护的内存空间内; 3、iOS中是一个非常封闭的系统，每一个App（一个进程）都有自己独特的内存和磁盘空间，别的App（进程）是不允许访问的（越狱不在讨论范围）； 4、进程 是系统资源分配和调度的一个独立单位，简单的理解就是用来帮程序占据一定的存储空间等的资源。进程拥有自己独立的位置空间，在没有经过进程本身允许的情况下，其他进程不能访问改进程的地址空间 进程 &amp;&amp; 线程的区别 1、地址空间:同一进程的线程共享本进程的地址空间,而进程之间则是独立的地址空间. 2、资源拥有:同一进程内的线程共享本进程的资源如内存,I/O,CPU等,但是进程之间的资源是独立的 3、一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉.所以多进程要比多线程健壮. 4、进程切换时,消耗的资源大,效率低.所以设计到频繁的切换时,使用线程要高于进程.同样如果要求同时进行又要共享某些变量的并发操作,只能用线程不能用进程 5、执行过程:每个独立的进程有一个程序运行的入口,顺序执行序列.但是线程不能独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制. 6、线程是处理器调度的基本单元,但是进程不是. 7、多线程需要控制线程之间的同步，而多进程则需要控制和主进程之间的交互. 8、如果两个进程之间要相互传输大量的数据，会相当影响性能，多进程适合小数据量传输，密集运算. ","link":"https://shineyangpro.com/ios-jin-cheng-he-xian-cheng-de-qu-bie-chu-ban/"},{"title":"TCP与UDP的区别(记录)","content":"TCP/IP网络模型 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。 TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机。 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。 UDP UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 它有以下几个特点： 1 面向无连接 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 2 有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 3 UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 4 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 5 头部开销小，传输数据报文时是很高效的。 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 TCP TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 1 TCP连接过程 如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）: 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 2 TCP断开链接 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 3 TCP协议的特点 面向连接 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞 TCP提供全双工通信 TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS） TCP和UDP的比较 总结 1、TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 2、虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 3、对数据准确性要求高，速度可以相对较慢的，可以选用TCP ","link":"https://shineyangpro.com/tcp-yu-udp-de-qu-bie-ji-lu/"},{"title":"NSTimer和CADisplayLink","content":"NSTimer或只是Timer在Swift世界中是一种经常使用的间隔执行方法。例如，倒数计时器就是一个很好的例子。 还有另一种是CADisplayLink-一种特殊的计时器，与设备屏幕刷新率相关。通常，每秒60帧，但是在新的iPad中，每秒120帧。 什么是（NS）计时器？ 借助Timer，您将来可以排定一项或多项任务。您可以指定计时器是否需要重复。 let timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in print(&quot;1 second passed&quot;) } 在上面的示例中，计时器将无限期地每1秒触发一次 要停止计时器，您需要使其无效。 timer.invalidate() 在主线程上触发计时器。如果应用是用户界面，则繁琐的计时器不会触发。要解决此问题，您可以： 附加到非默认RunLoop模式（如普通模式）-即使UI（主线程）忙，它也将允许计时器触发 RunLoop.current.add(timer, forMode: .common) OR 您可以使用CADisplayLink与屏幕更新同步。 什么是CADisplayLink？ CADisplayLink是Timer的一种特殊形式，它使您的应用在屏幕刷新后每次都可以运行一段代码。通常，它是每秒60帧，但在新iPad等选择性设备中，它是每秒120帧。 这是创建平滑动画并计算下一帧的好方法。这样，您就可以在帧之间拥有完美的定时，这与经典的计时器不同，经典的计时器不能保证在刷新屏幕的确切时间触发。 class DisplayLink { @objc func displayRefreshed(displayLink: CADisplayLink) { print(displayLink.timestamp) } init() { let displayLink = CADisplayLink(target: self, selector: #selector(displayRefreshed(displayLink:))) displayLink.add(to: .main, forMode: .default) } } 创建DisplayLink时，应将其链接到对象并指定objc函数作为选择器。在屏幕上重绘时，将立即触发此功能。我们可以通过打印出时间戳来查看它。 93095.013681187 93095.11224511401 93095.12891178101 93095.145578448 93095.162245115 93095.178911782 93095.19557844901 93095.21224511601 CADisplayLink具有preferredFramesPerSecond属性，可让您指定以每秒帧数计算的回调速率。 这意味着您可以在希望计时器触发时指定刷新率。 如果您不需要在每次屏幕刷新时都执行代码，这是一种很好的方法。 Timer vs CADisplayLink Timer和CADisplayLink都是以一定间隔触发一段代码的方法。这两种方法是不同的。 如果您只想每隔5秒执行一次而不将其与屏幕重绘相关联，则Timer很有用。 CADisplayLink与每秒60或120帧的屏幕刷新率相关。 屏幕重绘后立即触发，并且您有最大的时间在下一次屏幕刷新之前执行代码。 如果您需要创建无缝的动画，或者在无法避免屏幕刷新的游戏开发中很有用，则这种方法非常有用。 外部资料 NSTimer official documentation CADisplayLink official documentation Timer tutorial ","link":"https://shineyangpro.com/nstimer-he-cadisplaylink/"},{"title":"IOS block在栈上，还是堆上？","content":"Block存储区域 首先，需要引入三个名词： 全局块(_NSConcreteGlobalBlock) 栈块(_NSConcreteStackBlock) 堆块(_NSConcreteMallocBlock) 正如它们名字显示得一样，表明了block的三种存储方式：栈、全局、堆。获取block对象中的isa的值，可以得到上面其中一个，下面开始说明哪种block存储在栈、堆、全局。 这三种block各自的存储域如下图： 全局块存在于全局内存中, 相当于单例. 栈块存在于栈内存中, 超出其作用域则马上被销毁 堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存 简而言之，存储在栈中的Block就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块。 遇到一个Block，我们怎么这个Block的存储位置呢？ （1）Block不访问外界变量（包括栈中和堆中的变量） Block 既不在栈又不在堆中，在代码段中，ARC和MRC下都是如此。此时为全局块。 （2）Block访问外界变量 MRC 环境下：访问外界变量的 Block 默认存储栈中。 ARC 环境下：访问外界变量的 Block 默认存储在堆中（实际是放在栈区，然后ARC情况下自动又拷贝到堆区），自动释放。 ARC下，访问外界变量的 Block为什么要自动从栈区拷贝到堆区呢？ 栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，如同一般的自动变量。当然，Block中的__block变量也同时被废弃。如下图： 如下图: 例如下面一个返回值为Block类型的函数： typedef int (^blk_t)(int); blk_t func(int rate) { return ^(int count) { return rate * count; }; } 分析可知：上面的函数返回的Block是配置在栈上的，所以返回函数调用方时，Block变量作用域就结束了，Block会被废弃。但在ARC有效，这种情况编译器会自动完成复制。 在非ARC情况下则需要开发者调用copy方法手动复制，由于开发中几乎都是ARC模式，所以手动复制内容不再过多研究。 将Block从栈上复制到堆上相当消耗CPU，所以当Block设置在栈上也能够使用时，就不要复制了，因为此时的复制只是在浪费CPU资源。 Block的复制操作执行的是copy实例方法。不同类型的Block使用copy方法的效果如下表： 根据表得知，Block在堆中copy会造成引用计数增加，这与其他Objective-C对象是一样的。虽然Block在栈中也是以对象的身份存在，但是栈块没有引用计数，因为不需要，我们都知道栈区的内存由编译器自动分配释放。 不管Block存储域在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。 在ARC有效时，多次调用copy方法完全没有问题： blk = [[[[blk copy] copy] copy] copy]; // 经过多次复制，变量blk仍然持有Block的强引用，该Block不会被废弃。 引用相关文章，查看block完整解释请点击传送门 传送门 ","link":"https://shineyangpro.com/ios-block-zai-zhan-shang-huan-shi-dui-shang/"},{"title":"iOS面试总结(2020-12-11)，持续更新。。。","content":"网络的七层协议 TCP跟UDP的区别 UDP: 面向无连接 有单播，多播，广播的功能 UDP是面向报文的 不可靠性 头部开销小，传输数据报文时是很高效的。 TCP： TCP连接过程(需要三次握手) TCP协议的特点(面向连接,仅支持单播传输,面向字节流,可靠传输,提供拥塞控制,TCP提供全双工通信) TCP是如何连接的？(答：三次握手连接; 追问:有没有四次连接?) 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开） HTTP是如何连接的？ 客户端打包请求,包括url，端口啊，你的账号密码等等。账号密码登陆应该用的是Post方式，所以相关的用户信息会被加载到body里面。这个请求应该包含三个方面：网络地址，协议，资源路径。注意，这里是HTTPS，就是HTTP + SSL / TLS，在HTTP上又加了一层处理加密信息的模块（相当于是个锁）。这个过程相当于是客户端请求钥匙。 服务器接受请求。一般客户端的请求会先发送到DNS服务器。 DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器。这其中可能发生Hosts Hijack和ISP failure的问题。过了DNS这一关，信息就到了服务器端，此时客户端会和服务器的端口之间建立一个socket连接，socket一般都是以file descriptor的方式解析请求。这个过程相当于是服务器端分析是否要向客户端发送钥匙模板。 服务器端返回数字证书。服务器端会有一套数字证书（相当于是个钥匙模板），这个证书会先发送给客户端。这个过程相当于是服务器端向客户端发送钥匙模板。 客户端生成加密信息。根据收到的数字证书（钥匙模板），客户端会生成钥匙，并把内容锁上，此时信息已经加密。这个过程相当于客户端生成钥匙并锁上请求。 客户端发送加密信息。服务器端会收到由自己发送出去的数字证书加锁的信息。 这个时候生成的钥匙也一并被发送到服务器端。这个过程是相当于客户端发送请求。 服务器端解锁加密信息。服务器端收到加密信息后，会根据得到的钥匙进行解密，并把要返回的数据进行对称加密。这个过程相当于服务器端解锁请求、生成、加锁回应信息。 服务器端向客户端返回信息。客户端会收到相应的加密信息。这个过程相当于服务器端向客户端发送回应。 客户端解锁返回信息。客户端会用刚刚生成的钥匙进行解密，将内容显示在浏览器上。 DNS服务器是如何将你的网络地址解析成IP地址?如果让你设计一个DNS服务器，你会怎么做？ 个人理解其实跟字典的原理是差不多的，网络地址相当于key,ip相当于value 网络客户端就是我们平常使用的电脑，打开浏览器，输入一个域名。比如输入www.163.com，这时，你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 参考资料 给一个数组，例如[0,20,3,25,34,39]、用哪种排序比较快？你知道哪几种排序(口述)(可能还会问排序是如何实现的?) 参考《十大排序算法》 直播实现流程 1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动 追问：你都知道哪些流媒体传输协议 RTMP HTTP-FLV HLS HLS与RTMP的区别是什么？ HLS主要是延时比较大，RTMP主要优势在于延时低 HLS协议的小切片方式会生成大量的文件，存储或处理这些文件会造成大量资源浪费 相比使用RTSP协议的好处在于，一旦切分完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了CDN边缘服务器的配置要求，可以使用任何现成的CDN,而一般服务器很少支持RTSP。 说一下你对KVO的理解？有没有用过KVO? 当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。 你对KVC的理解是什么？原理是什么？ KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性 调用 setValue:forKey: setKey,_setKey -&gt;找到了则进行赋值,未找到调用 accessInstanceVarlableDirctly 是否运行 修改值,返回YES 调用_key, _isKey, key, isKey 进行赋值 KVO 跟Notification的区别 Notification优势： 1.不需要编写多少代码，实现比较简单； 2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单 3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息 缺点： 1.在编译期不会检查通知是否能够被观察者正确的处理； 2.在释放注册的对象时，需要在通知中心取消注册； 3.在调试的时候应用的工作以及控制过程难跟踪； 4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系； 5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况； 6.通知发出后，controller不能从观察者获得任何的反馈信息 KVO优势: 1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步； 2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现； 3.能够提供观察的属性的最新值以及先前值； 4.用key paths来观察属性，因此也可以观察嵌套对象； 5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察 缺点： 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查； 2.对属性重构将导致我们的观察代码不再可用； 3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向； 4.当释放观察者时不需要移除观察者。 block的属性修饰词为什么是copy？ block 一旦没有进行copy操作，就不会在堆上 追问:那栈上会不会有block?block有几种形式？ 参考本文章 知道Runtime吗？什么是Runtime？ Objective-C runtime是一个运行时库，它为Objective-C语言的动态特性提供支持，我们所写的OC代码在运行时都转成了runtime相关的代码，类转换成C语言对应的结构体，方法转化为C语言对应的函数，发消息转成了C语言对应的函数调用。通过了解runtime以及源码,可以更加深入的了解OC其特性和原理 OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 runtime可以做什么呢？ 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题 assgin和week有什么区别？ weak和之间的唯一区别是，如果weak释放了属性所指向的对象，则weak指针的值将设置为nil，这样就永远不会报错。如果使用assign，对象被释放后，将会访问野指针，会报错。 讲一下进程与线程的区别? 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 一个程序至少有一个进程,一个进程至少有一个线程 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 一个OC对象占用多少内存? 系统分配了16个字节给NSObject对象（通过malloc_size函数获得）。 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）。 OC对象 最少占用 16 个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16 字节对齐标准 . 属性最终满足 8 字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 如何正确释放定时器Timer？定时器释放不掉是因为什么原因？（包括在dealloc不会被调用） NSTimer不释放原因是: Timer 添加到 Runloop 的时候，会被 Runloop 强引用；然后 Timer 又会有一个对 Target 的强引用（也就是 self ） 注意target参数的描述： The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. 注意：文档中写的很清楚，timer对target会有一个强引用，直到timer is invalidated。也就是说，在timer调用 invalidate方法之前，timer对target一直都有一个强引用。这也是为什么控制器的dealloc 方法不会被调用的原因。 方法的文档介绍： The receiver retains aTimer. To remove a timer from all run loop modes on which it is installed, send an invalidate message to the timer. 也就是说，runLoop会对timer有强引用，因此，timer修饰符是weak，timer还是不能释放，timer的target也就不能释放。 解决办法： viewWillDisappear或viewDidDisappear中 invalidate 这种方式是可以释放掉的 - (void)viewWillDisappear:(BOOL)animated - (void)viewDidDisappear:(BOOL)animated 除了NSTimer,你还知道哪些定时器？有什么注意事项？ 还有CADisplayLink CADisplayLink 保证调用频率和刷帧频率一直,60FPS, 不用设置时间间隔,每秒钟60次 可以使用 proxy 代理解决循环引用 CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用 详情参考 你知道哪些数据结构？iOS中常见的数据结构有哪些？ 集合结构 线性结构(栈、队列) 树形结构(堆) 圆形结构 iOS中最常见的三种数据结构是数组，字典和集合 具体参考详细讲解数据结构 你有了解过iOS的内存吗？ 代码段: 编译之后的代码 数据段: 字符串常量,已经初始化的全局变量,或者静态变量,未初始化的全局变量,静态变量 堆 (低&gt;高) 通过 alloc malloc calloc 动态分配的内存 栈 (高地址 从 低地址) 函数调用开销() 追问：讲一下对内存管理的理解？ 在iOS中，使用引用计数来管理OC对象的内存 一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间 调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1 内存管理的经验总结 当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它 想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1 在开发中，如何防止内存泄露？ 可以使用静态分析以及instruments的leaks 分析 注意 NStimer 以及 block ,delegate 等的使用,避免循环引用 你知道锁都有哪些吗？ os_unfair_lock ios10 开始 OSSpinLock ios10 废弃 dispatch_semaphore 建议使用,性能也比较好 dispatch_mutex dispatch_queue 串行 NSLock 对 mutex 封装 @synchronized 性能最差 追问：你有用过自旋和互斥锁吗？他们有什么区别？ 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 继续追问:两种锁的加锁原理描述一下？ 两种锁的加锁原理： 互斥锁：线程会从sleep（加锁）——&gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。 自旋锁：线程一直是running(加锁——&gt;解锁)，死循环检测锁的标志位 NSString什么时候用copy，什么时候用strong，有什么不同？ 一般情况下，我们不希望字串的值跟着变化，所以我们一般用copy来设置string的属性。 如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。 retain仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种retain方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝 ","link":"https://shineyangpro.com/ios-ms-2020/"},{"title":"十大排序算法","content":"算法概述 算法分类 十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现 function bubbleSort(arr) { var len = arr.length; for(vari = 0; i &lt; len - 1; i++) { for(varj = 0; j &lt; len - 1 - i; j++) { if(arr[j] &gt; arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } Swift func bubbleSort(arr:[Int]){ var soreArray = arr var len = soreArray.count for i in 1 ... len - 1 { for j in 0 ... len - 1 - i { if soreArray[j] &gt; soreArray[j + 1] { var temp = soreArray[j+1] soreArray[j+1] = soreArray[j] soreArray[j] = temp } } } print(&quot;冒泡排序输出的是：\\(soreArray)&quot;) } 个人比较常用冒泡排序 2、选择排序（Selection Sort） 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前+ 无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别+ 变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现 function selectionSort(arr) { var len = arr.length; var minIndex, temp; for(var i = 0; i &lt; len - 1; i++) { minIndex = i; for(var j = i + 1; j &lt; len; j++) { if(arr[j] &lt; arr[minIndex]) { // 寻找最小的数 minIndex = j; // 将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } Switf func selectSort(arr:[Int]) { var selectArray = arr var len = selectArray.count var minIndex:Int; var temp:Int; for i in 0..&lt;len - 1 { minIndex = i for j in i+1..&lt;len { if selectArray[j] &lt; selectArray[minIndex] { minIndex = j } } temp = selectArray[i] selectArray[i] = selectArray[minIndex] selectArray[minIndex] = temp } print(&quot;快速排序算法的:\\(selectArray)&quot;) } 2.4 算法分析 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.3 代码实现 function insertionSort(arr) { var len = arr.length; var preIndex, current; for(vari = 1; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr; } Switf func insertionSore(arr:[Int]) { var inserArray = arr var len = inserArray.count var preIndex:Int var current:Int for i in 1..&lt;len { preIndex = i - 1 current = inserArray[i] while preIndex &gt;= 0 &amp;&amp; inserArray[preIndex] &gt; current { inserArray[preIndex + 1] = inserArray[preIndex] preIndex-=1 } inserArray[preIndex + 1] = current } print(&quot;插入排序算法输出:\\(inserArray)&quot;) } 3.4 算法分析 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort） 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现 function shellSort(arr) { var len = arr.length; for(var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) { // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for(vari = gap; i &lt; len; i++) { varj = i; var current = arr[i]; while(j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j = j - gap; } arr[j] = current; } } return arr; } 4.4 算法分析 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现 function mergeSort(arr) { var len = arr.length; if(len &lt; 2) { returnarr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { varresult = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0) { if(left[0] &lt;= right[0]) { result.push(left.shift()); }else{ result.push(right.shift()); } } while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); return esult; } 5.4 算法分析 归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现 function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left =typeofleft !='number'? 0 : left, right =typeofright !='number'? len - 1 : right; if(left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } returnarr; } function partition(arr, left ,right) { // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for(var i = index; i &lt;= right; i++) { if(arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1; } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现 var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for(vari = Math.floor(len/2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { // 堆调整 varleft = 2 * i + 1, right = 2 * i + 2, largest = i; if(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if(largest != i) { swap(arr, i, largest); heapify(arr, largest); } } function swap(arr, i, j) { vartemp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } function heapSort(arr) { buildMaxHeap(arr); for(vari = arr.length - 1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } returnarr; } 8、计数排序（Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现 function countingSort(arr, maxValue) { var bucket =newArray(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for(var i = 0; i &lt; arrLen; i++) { if(!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for(var j = 0; j &lt; bucketLen; j++) { while(bucket[j] &gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } 8.4 算法分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.3 代码实现 function bucketSort(arr, bucketSize) { if(arr.length === 0) { returnarr; } vari; varminValue = arr[0]; varmaxValue = arr[0]; for(i = 1; i &lt; arr.length; i++) { if(arr[i] &lt; minValue) { minValue = arr[i]; // 输入数据的最小值 }elseif(arr[i] &gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 varDEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; varbucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; varbuckets =newArray(bucketCount); for(i = 0; i &lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for(i = 0; i &lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for(i = 0; i &lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for(varj = 0; j &lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } returnarr; } 9.4 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort） 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现 var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for(var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(va rj = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value =null; if(counter[j]!=null) { while((value = counter[j].shift()) !=null) { arr[pos++] = value; } } } } return arr; } 10.4 算法分析 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 ","link":"https://shineyangpro.com/shi-da-pai-xu-suan-fa/"},{"title":"Swift 函数派发机制","content":" 原文：Method Dispatch in Swift 作者：Brian King 派发机制是程序判断如何去调用函数或方法的机制，每次调用方法时都会触发，但一般我们都不会注意到。了解派发机制的工作原理，对于写出高性能的代码来说非常重要，派发机制也能解释一些Swift中的奇妙现象，和Objective-C中所谓的黑魔法。 编译型编程语言主要有三种派发方式：直接派发(Direct Dispatch)，函数表派发(Table Dispatch) 和 消息机制派发(Message Dispatch)。 Java默认使用函数表派发机制，但是我们可以通过final关键字来将其转换为直接派发。C++默认使用直接派发，但可以通过virtual关键字转化为消息机制派发。Objective-C总是使用消息机制派发，但允许开发者使用C进行直接派发来提高性能。Swift已经实现了三种派发机制的全部支持，但是也给开发者带来了很多困扰。 派发方式 派发机制的目的是为了让程序告诉CPU，当调用一个具体方法的时候要去内存的哪个地方找到可执行代码。在了解Swift之前，先来了解一下三种派发方式，以及它们如何在性能和动态性之间的取舍。 直接派发（Direct Dispatch） 直接派发是速度最快的派发机制，它生成的汇编指令最少，编译器也有很大的优化空间，例如函数内联等等，但这不在本文的讨论范围内。因为在编译时就能确定方法的调用位置，直接派发也被称为静态派发（Static Dispatch）。 但是，对于编程来说直接派发也是最局限的，因为它缺乏动态性，而无法支持继承。 函数表派发（Table Dispatch） 函数表派发是编译型编程语言动态性的最常见的实现，函数表维护了一个指针数组，每个指针都指向类中声明的函数，每个声明的函数也确保有指针指向它。大部分语言把这个表称为虚函数表（Virtual Table），但在Swift里称为（Witness Table）。 每个类都维护一张属于自己的函数表，里面记录着所有函数；子类会复制一张父类的表，以便完成继承操作，在子类重写方法时修改指针，指向覆盖的新函数，子类添加的新函数会被插入表的最后。每当调用函数时，根据函数表的指针来确定具体调用哪个函数。 举个栗子，有下面两个类： class ParentClass { func method1() {} func method2() {} } class ChildClass: ParentClass { override func method2() {} func method3() {} } 这时，编译器会创建两张函数表，一个是ParentClass的，一个是ChildClass let obj = ChildClass() obj.method2() method2是一个被继承且被重写的函数，当它被调用时，会经历以下过程： 读取地址为0xB00的子类函数表。 读取函数指针索引，在这里method2的偏移量是1，所以得到地址0xB00 + 1。 跳转到地址0x222并读取内容，即函数的实现。 查表是一种简单、易实现而且性能可预知的方式，但是，这种派发方式比起直接派发还是慢了一点。从字节码角度来看，查表时首先要读取方法表指针，然后根据偏移量跳转到函数指针，再读取函数指针，所以查表多了两次读操作和一次跳转操作，导致了性能损耗。另外一个原因就是编译器无法进行任何优化。 查表法的缺陷在于，基于数组实现的函数表无法为extension提供扩展。子类添加的新函数会插入函数表的尾部，所以没有位置可以让extension安全地插入函数。这篇文章详细描述了这种局限性。 消息机制派发 （Message Dispatch) 消息机制是动态性最高的调用方式，也是Cocoa的基石，同时也催生了KVO，UIAppearance，CoreData等技术。这种派发机制的关键在于，开发者可以在运行时修改函数的调用。例如 Method Swizzling 可以在运行时修改函数的实现和调用，甚至可以通过 ISA Swizzling 在运行时修改对象的继承关系，由此可以在面向对象的基础上实现自定义分发。 同样举一个栗子： class ParentClass { dynamic func method1() {} dynamic func method2() {} } class ChildClass: ParentClass { override func method2() {} dynamic func method3() {} } Swift 会通过树来简历继承关系 当一个消息被派发，Runtime会顺着继承关系向上查找应该被调用的函数，这样做的效率非常低。但是，这个查找操作会建立一个散列表用于缓存，一旦这个缓存被建立起来，消息机制派发就会像函数表派发一样快，这篇文章详细探讨了性能测试，这篇文章深入介绍了消息派发机制的技术细节。 Swift的派发机制 Swift的派发机制没有一个固定答案，但是影响派发方式的因素有四个： 声明的位置 引用类型 指定派发方式 显式优化 Swift没有在文档中写明什么时候会用什么派发机制，唯一说明的是：使用dynamic修饰的函数，会用过OC Runtime进行消息机制派发。 声明的位置（Location Matters） Swift中，一个函数有两种声明位置可以选择：类的声明和extension，根据声明位置不同，派发方式也不同。 class MyClass { func mainMethod() {} } extension MyClass { func extensionMethod() {} } 这个例子中，mainMethod会使用函数表派发，而extensionMethod会使用直接派发。原因前面也提到过，扩展中的方法没有插入方法表。具体根据不同声明位置， 总结起来有这么几点规律： 值类型总是直接派发 协议和类的声明作用域中的函数，除值类型外，都使用函数表派发 协议和类的extension中的函数，使用直接派发 NSObject的extension中的函数使用消息机制派发 引用类型（Reference Type Matters） 声明的引用类型决定了派发方式，一个常见的例子就是，协议拓展和对象拓展同时实现一个函数的时候： protocol MyProtocol { } struct MyStruct: MyProtocol { } extension MyStruct { func extensionMethod() { print(&quot;In Struct&quot;) } } extension MyProtocol { func extensionMethod() { print(&quot;In Protocol&quot;) } } let myStruct = MyStruct() let proto: MyProtocol = myStruct myStruct.extensionMethod() // -&gt; “In Struct” proto.extensionMethod() // -&gt; “In Protocol” 可以看到，在这种情况下因为proto的声明引用类型为MyProtocol，所以proto.extensionMethod()直接调用了协议拓展中的函数，Kotlin的扩展也遵循这个规律。但是如果把extensionMethod的声明移动到协议声明中，则会使用函数表派发，最终调用结构体里的实现。 由此我们得出结论，如果两种声明方式都使用了直接派发，那么我们不能完成预想的函数覆盖。 指定派发方式（Specifying Dispatch Behavior） Swift有一些修饰符可以指定派发方式： final final允许类里面的函数使用直接派发， 这个修饰符会让函数失去动态性。任何函数都可以使用这个修饰符，就算是extension里本来就是直接派发的函数， 这也会让Objective-C Runtime获取不到这个函数, 不会生成相应的selector。 dynamic dynamic可以让类里面所有的函数使用消息机制派发，使用时必须导入Foundation包，里面包括了NSObject和Objective-C的Runtime。dynamic可以用在所有NSObject的子类和所有Swift原生类，也可以让extension中的函数能够被继承。 @objc &amp; @nonobjc @objc和@nonobjc显式地声明了一个函数能否被Objective-C Runtime捕捉到。使用@objc的典型例子就是给selector一个命名空间，让这个函数可以在运行时被调用。@nonobjc表示不让这个函数注册到Runtime中，由此禁止消息机制来派发这个函数，和final非常相似。 final @objc 可以同时使用final和@objc来修饰函数，这样做的结果就是，调用函数时会直接派发，但可以将函数注册到Objective-C Runtime中，来让函数可以响应perform(selector:)或者其他特性。 @inline 可以通过@inline来使用直接派发，但是同时使用dynamic @inline修饰时，会使用消息机制派发。 修饰符总结 显式优化 Swift会尽可能优化函数派发方式，例如，一个函数从来没有继承或被继承过，Swift就会检测到并且在可能的情况下使用直接派发，在大多数情况下这样的优化效果非常好，但是对于Cocoa开发者就不太友好了： override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem( title: &quot;Sign In&quot;, style: .plain, target: nil, action: #selector(ViewController.signInAction) ) } private func signInAction() {} 这时编译器会报错： Argument of '#selector' refers to a method that is not exposed to Objective-C （Objective-C无法获取 #selector指定的函数） 这里Swift将signInAction优化为直接派发，所以没有注册到Runtime中，#selector 自然无法获取。 另一个需要注意的是， 如果你没有使用dynamic修饰的话，这个优化会默认让KVO失效。如果一个属性绑定了KVO的话，而这个属性的setter方法会被优化为直接派发。而KVO的原理就是通过Runtime创建原类的子类，然后重写setter方法，并在setter方法中通知value的变化。虽然代码依旧可以通过编译，不过动态生成的 KVO函数就不会被触发。 ","link":"https://shineyangpro.com/swift-han-shu-pai-fa-ji-zhi/"},{"title":"Go操作MySql数据库的方式","content":"Go操作Mysql数据库 使用Go操作MySQL等数据库，一般有两种方式：一是使用database/sql接口，直接在代码里硬编码sql语句；二是使用gorm，即对象关系映射的方式在代码里抽象的操作数据库。一般推荐使用第二种方式。 1、使用database/sql接口 Go没有内置的驱动支持任何数据库，但是Go定义了database/sql接口，用户可以基于驱动接口开发相应数据库的驱动。但缺点是，直接用 github.com/go-sql-driver/mysql 访问数据库都是直接写 sql，取出结果然后自己拼成对象，使用上面不是很方便，可读性也不好。 下载包 go get github.com/go-sql-driver/mysql 安装好 mysql 驱动之后，我们创建一张user表，并执行CRUD操作（增、删、改、查）。代码如下所示： package main import ( &quot;database/sql&quot; &quot;fmt&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;time&quot; ) //数据库连接信息 const ( USERNAME = &quot;root&quot; PASSWORD = &quot;123456&quot; NETWORK = &quot;tcp&quot; SERVER = &quot;127.0.0.1&quot; PORT = 3306 DATABASE = &quot;test&quot; ) //user表结构体定义 type User struct { Id int `json:&quot;id&quot; form:&quot;id&quot;` Username string `json:&quot;username&quot; form:&quot;username&quot;` Password string `json:&quot;password&quot; form:&quot;password&quot;` Status int `json:&quot;status&quot; form:&quot;status&quot;` // 0 正常状态， 1删除 Createtime int64 `json:&quot;createtime&quot; form:&quot;createtime&quot;` } func main() { conn := fmt.Sprintf(&quot;%s:%s@%s(%s:%d)/%s&quot;,USERNAME, PASSWORD, NETWORK, SERVER, PORT, DATABASE) DB, err := sql.Open(&quot;mysql&quot;, conn) if err != nil { fmt.Println(&quot;connection to mysql failed:&quot;, err) return } DB.SetConnMaxLifetime(100*time.Second) //最大连接周期，超时的连接就close DB.SetMaxOpenConns(100) //设置最大连接数 CreateTable(DB) InsertData(DB) QueryOne(DB) QueryMulti(DB) UpdateData(DB) DeleteData(DB) } func CreateTable(DB *sql.DB) { sql := `CREATE TABLE IF NOT EXISTS users( id INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL, username VARCHAR(64), password VARCHAR(64), status INT(4), createtime INT(10) ); ` if _, err := DB.Exec(sql); err != nil { fmt.Println(&quot;create table failed:&quot;, err) return } fmt.Println(&quot;create table successd&quot;) } //插入数据 func InsertData(DB *sql.DB) { result,err := DB.Exec(&quot;insert INTO users(username,password) values(?,?)&quot;,&quot;test&quot;,&quot;123456&quot;) if err != nil{ fmt.Printf(&quot;Insert data failed,err:%v&quot;, err) return } lastInsertID,err := result.LastInsertId() //获取插入数据的自增ID if err != nil { fmt.Printf(&quot;Get insert id failed,err:%v&quot;, err) return } fmt.Println(&quot;Insert data id:&quot;, lastInsertID) rowsaffected,err := result.RowsAffected() //通过RowsAffected获取受影响的行数 if err != nil { fmt.Printf(&quot;Get RowsAffected failed,err:%v&quot;,err) return } fmt.Println(&quot;Affected rows:&quot;, rowsaffected) } //查询单行 func QueryOne(DB *sql.DB) { user := new(User) //用new()函数初始化一个结构体对象 row := DB.QueryRow(&quot;select id,username,password from users where id=?&quot;, 1) //row.scan中的字段必须是按照数据库存入字段的顺序，否则报错 if err := row.Scan(&amp;user.Id,&amp;user.Username,&amp;user.Password); err != nil { fmt.Printf(&quot;scan failed, err:%v\\n&quot;, err) return } fmt.Println(&quot;Single row data:&quot;, *user) } //查询多行 func QueryMulti(DB *sql.DB) { user := new(User) rows, err := DB.Query(&quot;select id,username,password from users where id = ?&quot;, 2) defer func() { if rows != nil { rows.Close() //关闭掉未scan的sql连接 } }() if err != nil { fmt.Printf(&quot;Query failed,err:%v\\n&quot;, err) return } for rows.Next() { err = rows.Scan(&amp;user.Id, &amp;user.Username, &amp;user.Password) //不scan会导致连接不释放 if err != nil { fmt.Printf(&quot;Scan failed,err:%v\\n&quot;, err) return } fmt.Println(&quot;scan successd:&quot;, *user) } } //更新数据 func UpdateData(DB *sql.DB){ result,err := DB.Exec(&quot;UPDATE users set password=? where id=?&quot;,&quot;111111&quot;,1) if err != nil{ fmt.Printf(&quot;Insert failed,err:%v\\n&quot;, err) return } fmt.Println(&quot;update data successd:&quot;, result) rowsaffected,err := result.RowsAffected() if err != nil { fmt.Printf(&quot;Get RowsAffected failed,err:%v\\n&quot;,err) return } fmt.Println(&quot;Affected rows:&quot;, rowsaffected) } //删除数据 func DeleteData(DB *sql.DB){ result,err := DB.Exec(&quot;delete from users where id=?&quot;,1) if err != nil{ fmt.Printf(&quot;Insert failed,err:%v\\n&quot;,err) return } fmt.Println(&quot;delete data successd:&quot;, result) rowsaffected,err := result.RowsAffected() if err != nil { fmt.Printf(&quot;Get RowsAffected failed,err:%v\\n&quot;,err) return } fmt.Println(&quot;Affected rows:&quot;, rowsaffected) } 执行程序，输出结果如下所示： create table successd Insert data id: 1 Affected rows: 1 Single row data: {1 test 123456 0 0} update data successd: {0xc0000a0000 0xc000010280} Affected rows: 1 delete data successd: {0xc0000a0000 0xc0000102b0} Affected rows: 1 OK，到这里大家是不是觉得这种实现方式很繁琐，假如要修改某个sql语句需要在代码中修改，这样很麻烦，代码设计也比较糟糕。因此这种方式并不推荐使用。 2、使用GORM GORM（Object Relation Mapping），即Go语言中的对象关系映射，实际上就是对数据库的操作进行封装，对上层开发人员屏蔽数据操作的细节，开发人员看到的就是一个个对象，大大简化了开发工作，提高了生产效率。如GORM结合Gin等服务端框架使用可以开发出丰富的Rest API等。 首先，下载包 go get github.com/jinzhu/gorm go get github.com/gin-gonic/gin 使用Go的Gin框架和Gorm开发简单的CRUD API，代码如下 package main import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot; &quot;net/http&quot; ) var MysqlDB *gorm.DB type User struct { Id int `gorm:&quot;size:11;primary_key;AUTO_INCREMENT;not null&quot; json:&quot;id&quot;` Age int `gorm:&quot;size:11;DEFAULT NULL&quot; json:&quot;age&quot;` Name string `gorm:&quot;size:255;DEFAULT NULL&quot; json:&quot;name&quot;` //gorm后添加约束，json后为对应mysql里的字段 } func main() { MysqlDB, err := gorm.Open(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/test?charset=utf8&quot;) if err != nil { fmt.Println(&quot;failed to connect database:&quot;, err) return }else{ fmt.Println(&quot;connect database success&quot;) MysqlDB.SingularTable(true) MysqlDB.AutoMigrate(&amp;User{}) //自动建表 fmt.Println(&quot;create table success&quot;) } defer MysqlDB.Close() Router() } func Router() { router := gin.Default() //路径映射 router.GET(&quot;/user&quot;, InitPage) router.POST(&quot;/user/create&quot;, CreateUser) router.GET(&quot;/user/list&quot;, ListUser) router.PUT(&quot;/user/update&quot;, UpdateUser) router.GET(&quot;/user/find&quot;, GetUser) router.DELETE(&quot;/user/:id&quot;, DeleteUser) router.Run(&quot;:8080&quot;) } //每个路由都对应一个具体的函数操作,从而实现了对user的增,删,改,查操作 func InitPage(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) } func CreateUser(c *gin.Context) { var user User c.BindJSON(&amp;user) //使用bindJSON填充对象 MysqlDB.Create(&amp;user) //创建对象 c.JSON(http.StatusOK, &amp;user) //返回页面 } func UpdateUser(c *gin.Context) { var user User id := c.PostForm(&quot;id&quot;) //post方法取相应字段 err := MysqlDB.First(&amp;user, id).Error //数据库查找主键=ID的第一行 if err != nil { c.AbortWithStatus(404) fmt.Println(err.Error()) } else { c.BindJSON(&amp;user) MysqlDB.Save(&amp;user) //提交更改 c.JSON(http.StatusOK, &amp;user) } } func ListUser(c *gin.Context) { var user []User line := c.Query(&quot;line&quot;) MysqlDB.Limit(line).Find(&amp;user) //限制查找前line行 c.JSON(http.StatusOK, &amp;user) } func GetUser(c *gin.Context) { id := c.Query(&quot;id&quot;) var user User err := MysqlDB.First(&amp;user, id).Error if err != nil { c.AbortWithStatus(404) fmt.Println(err.Error()) } else { c.JSON(http.StatusOK, &amp;user) } } func DeleteUser(c *gin.Context) { id := c.Param(&quot;id&quot;) var user User MysqlDB.Where(&quot;id = ?&quot;, id).Delete(&amp;user) c.JSON(http.StatusOK, gin.H{ &quot;data&quot;: &quot;this has been deleted!&quot;, }) } 执行程序，输出结果如下所示： connect database success create table success ...... [GIN-debug] GET /user --&gt; main.InitPage (3 handlers) [GIN-debug] POST /user/create --&gt; main.CreateUser (3 handlers) [GIN-debug] GET /user/list --&gt; main.ListUser (3 handlers) [GIN-debug] PUT /user/update --&gt; main.UpdateUser (3 handlers) [GIN-debug] GET /user/find --&gt; main.GetUser (3 handlers) [GIN-debug] DELETE /user/:id --&gt; main.DeleteUser (3 handlers) [GIN-debug] Listening and serving HTTP on :8080 小结 通过非常简短的代码,就可以实现功能强大的restful接口,go语言的优势也是非常明显的.关于gin和gorm还有更加深入的内容.掌握好这两个工具可以轻松的构建web应用。 ","link":"https://shineyangpro.com/go-cao-zuo-mysql-shu-ju-ku-de-fang-shi/"},{"title":"Xcode占用大量空间的派生数据， iOS DeviceSupport，存档，模拟器和SwiftUI预览模拟器","content":"我们使用Xcode开发App时将产生派生数据，iOS DeviceSupport，存档，Simulator和SwiftUI预览模拟器，随着时间的累积，它们的空间将十分可观，甚至可以超过几十GB的规模。因此，接下来就让我们学习清除它们的小技巧，以备Mac空间不足时派上用场。下面给大家介绍三种清理方式: 1、为Xcode使用App DevCleaner App DevCleaner下载 使用大大开发的免费的Xcode App DevCleaner是其中最简单的方法，打开App后，可以自动帮我们找到可以删除的内容。 清除想要删除的档案后，按右下角的Clean开始删除。 2、使用App Xcode清洁程序 Xcode的清理程序将帮助我们发现Xcode占用大量空间的档案，点选X可以一键删除。 官网下载 3、手动删除衍生数据 1、点选Xcode-&gt;首选项，打开首选项窗口。 2.切换到位置分页，点选派生数据向下勾引着我们，路径旁边指向右边的箭头。 点选箭头后将打开Finder视窗，显示派生数据资料夹。 3.双击派生的数据资料夹，显示其中的资料夹。单击cmd + a全选这些资料夹后，从快捷方式选择单点选移至垃圾桶，将其杀得一干二净，丢到垃圾桶。 4.点选Finder-&gt; Empty Trash，清空垃圾桶里的资料。 从Finder视窗，可观察到空间从原本的16.64GB，瞬间成长到31.36GB，足足多了15G之多！ 4、手动删除iOS DeviceSupport 删除〜/ Library / Developer / Xcode / iOS DeviceSupport里的资料。iOSDeviceSupport包含了Mac接过装置的iOS支援挡，接过愈多装置，占用愈多空间。 手动删除 删除〜/ Library / Developer / Xcode / Archives里的资料。 Archives资料夹里是我们曾经使用Xcode&gt; Archive制作的App。 5、清除用不到的模拟器 Xcode的模拟器十分占空间，而且采用iOS版本的持续更新，Mac里可能存着很多我们用不到的旧版模拟器，比方以下CleanMyMac X列出目前用不到的模拟器占了38 GB的空间。 将这些不可用的模拟器通通清除很简单，只要在终端输入以下指令： xcrun simctl delete unavailable ","link":"https://shineyangpro.com/xcode-zhan-yong-da-liang-kong-jian-de-pai-sheng-shu-ju-ios-devicesupportcun-dang-mo-ni-qi-he-swiftui-yu-lan-mo-ni-qi/"},{"title":"Go框架-Gin里获取http请求的参数","content":"1、 Query / DefaultQuery 单个接收get参数 package main import ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;log&quot; &quot;strconv&quot; &quot;github.com/gin-gonic/gin&quot; ) func main() { engine := gin.Default() // Query / DefaultQuery 单个接收get参数 //http://localhost:8080/hello?name=haima engine.GET(&quot;/hello&quot;, func(context *gin.Context) { fmt.Println(context.FullPath()) //获取字符串参数 username := context.Query(&quot;name&quot;) //方法一 fmt.Println(username) //name := context.DefaultQuery(&quot;name&quot;, &quot;&quot;) //方法二 //fmt.Println(name) context.Writer.Write([]byte(&quot;Hello,&quot; + username)) //Hello,go }) } 2、ShouldBindQuery 批量接收get参数 type Student struct { Name string `form:&quot;name&quot;` Classes string `form:&quot;classes&quot;` } // http://localhost:8080/hello2?name=davie&amp;classes=软件工程 engine.GET(&quot;/hello2&quot;, func(context *gin.Context) { fmt.Println(context.FullPath()) var student Student err := context.ShouldBindQuery(&amp;student) if err != nil { log.Fatal(err.Error()) } fmt.Println(student.Name) //davie fmt.Println(student.Classes) //软件工程 context.Writer.Write([]byte(&quot;hello,&quot; + student.Name)) }) 3、单个接收post过来的参数 //http://localhost:8080/login engine.POST(&quot;/login&quot;, func(context *gin.Context) { fmt.Println(context.FullPath()) // /login username := context.PostForm(&quot;username&quot;) //方法一 //username, exist := context.GetPostForm(&quot;username&quot;) //方法二 userId, _ := strconv.ParseInt(context.Query(&quot;user_id&quot;), 10, 64) //if !exist { // fmt.Println(username) //adf //} //password := context.PostForm(&quot;pwd&quot;) password, exists := context.GetPostForm(&quot;pwd&quot;) //12323 //password:= com.StrTo(context.GetPostForm(&quot;pwd&quot;)).MustInt() if !exists { fmt.Println(password) //12323 } fmt.Printf(&quot;%T %s\\n&quot;, username,username) //string adf fmt.Printf(&quot;%T %d\\n&quot;, userId,userId) //int64 0 fmt.Printf(&quot;%T %s\\n&quot;, password,password) //string 12323 context.Writer.Write([]byte(&quot;Hello &quot; + username + &quot;, pwd:&quot; + password)) //Hello go, pwd:123 }) 4、ShouldBind 批量接收post数据 from-data type Register struct { UserName string `form:&quot;name&quot;` Phone string `form:&quot;phone&quot;` Password string `form:&quot;pwd&quot;` } //http://localhost:8080/register engine.POST(&quot;/register&quot;, func(context *gin.Context) { fmt.Println(context.FullPath()) var register Register if err := context.ShouldBind(&amp;register); err != nil { log.Fatal(err.Error()) return } fmt.Println(register.UserName) fmt.Println(register.Phone) context.Writer.Write([]byte(register.UserName + &quot; Register &quot;)) }) 5、BindJSON 批量接收 post raw json 数据 方法一 //http://localhost:8080/testpost engine.POST(&quot;/testpost&quot;, func(ctx *gin.Context) { fmt.Println(ctx.FullPath()) type delInfo struct { UserID int `from:&quot;user_id&quot;` LinkbookID string `from:&quot;linkbook_id&quot;` Type string `from:&quot;type&quot;` ID int `from:&quot;id&quot;` } var delInfoParam delInfo if err := ctx.BindJSON(&amp;delInfoParam); err != nil { log.Fatal(err.Error()) return } ctx.Writer.Write([]byte(&quot;Hello,&quot; + delInfoParam.Type)) //Hello,go }) 6、 BindJSON 批量接收 post raw json 数据 方法二 //http://localhost:8080/test engine.POST(&quot;/test&quot;, func(context *gin.Context) { fullPath := &quot;请求路径:&quot; + context.FullPath() fmt.Println(fullPath) SetBodyJson(context, &quot;json&quot;) var delInfo map[string]interface{} err := getRequestBody(context, &amp;delInfo) fmt.Println(err) fmt.Println(delInfo) }) //http://localhost:8080/user/22 engine.DELETE(&quot;/user/:id&quot;, DeleteHandle) engine.Run(&quot;:8090&quot;) //http://localhost:8080/user/adf func DeleteHandle(context *gin.Context) { fmt.Println(context.FullPath()) // /user/:id userID := context.Param(&quot;id&quot;) fmt.Println(userID) //adf context.Writer.Write([]byte(&quot;Delete user's id : &quot; + userID)) //Delete user's id : adf } func getRequestBody(context *gin.Context, s interface{}) error { body, _ := context.Get(&quot;json&quot;) reqBody, _ := body.(string) decoder := json.NewDecoder(bytes.NewReader([]byte(reqBody))) decoder.UseNumber() err := decoder.Decode(&amp;s) return err } // @desc 通过上下文获取body内容并将内容写到指定key中 func SetBodyJson(context *gin.Context, key string) { body := make([]byte, 1048576) n, _ := context.Request.Body.Read(body) fmt.Println(&quot;request body:&quot;, n) context.Set(key, string(body[0:n])) } ","link":"https://shineyangpro.com/go-kuang-jia-gin-li-huo-qu-http-qing-qiu-de-can-shu/"},{"title":"使用editor.md作为后台富文本编辑器以及前台Markdown文档展示","content":"整个流程 首先需要在后台管理页插入富文本编辑器 然后拿到编辑好的html代码并把它存入数据库，为了在前台展示时加载页面。同时还应拿到对应md源代码（也存入数据库），为了让文章在必要的时候可以重新编辑修改。 前端拿到html代码后，引入editor.md相应的css和js文件，对页面进行正确的加载。 1.下载安装 在github上把项目clone下来传送门 或者在官网上直接下载安装传送门 2.基本研究思路 不感兴趣的可以直接跳到实战部分 a.打开项目文件件下面的examples文件夹中的full.html或者use-zepto文件，可以看到需要引入的css和js文件如下： &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/editormd.css&quot; /&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../editormd.js&quot;&gt;&lt;/script&gt; editor.md的基本配置项以及可以使用的函数： &lt;script type=&quot;text/javascript&quot;&gt; var testEditor; $(function() { $.get('test.md', function(md){ testEditor = editormd(&quot;test-editormd&quot;, { width: &quot;90%&quot;, height: 740, path : '../lib/', theme : &quot;dark&quot;, previewTheme : &quot;dark&quot;, editorTheme : &quot;pastel-on-dark&quot;, markdown : md, codeFold : true, //syncScrolling : false, saveHTMLToTextarea : true, // 保存 HTML 到 Textarea searchReplace : true, //watch : false, // 关闭实时预览 htmlDecode : &quot;style,script,iframe|on*&quot;, // 开启 HTML 标签解析，为了安全性，默认不开启 //toolbar : false, //关闭工具栏 //previewCodeHighlight : false, // 关闭预览 HTML 的代码块高亮，默认开启 emoji : true, taskList : true, tocm : true, // Using [TOCM] tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //dialogLockScreen : false, // 设置弹出层对话框不锁屏，全局通用，默认为true //dialogShowMask : false, // 设置弹出层对话框显示透明遮罩层，全局通用，默认为true //dialogDraggable : false, // 设置弹出层对话框不可拖动，全局通用，默认为true //dialogMaskOpacity : 0.4, // 设置透明遮罩层的透明度，全局通用，默认值为0.1 //dialogMaskBgColor : &quot;#000&quot;, // 设置透明遮罩层的背景颜色，全局通用，默认为#fff imageUpload : true, imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], imageUploadURL : &quot;./php/upload.php&quot;, onload : function() { console.log('onload', this); //this.fullscreen(); //this.unwatch(); //this.watch().fullscreen(); //this.setMarkdown(&quot;#PHP&quot;); //this.width(&quot;100%&quot;); //this.height(480); //this.resize(&quot;100%&quot;, 640); } }); }); $(&quot;#goto-line-btn&quot;).bind(&quot;click&quot;, function(){ testEditor.gotoLine(90); }); $(&quot;#show-btn&quot;).bind('click', function(){ testEditor.show(); }); $(&quot;#hide-btn&quot;).bind('click', function(){ testEditor.hide(); }); $(&quot;#get-md-btn&quot;).bind('click', function(){ alert(testEditor.getMarkdown()); }); $(&quot;#get-html-btn&quot;).bind('click', function() { alert(testEditor.getHTML()); }); $(&quot;#watch-btn&quot;).bind('click', function() { testEditor.watch(); }); $(&quot;#unwatch-btn&quot;).bind('click', function() { testEditor.unwatch(); }); $(&quot;#preview-btn&quot;).bind('click', function() { testEditor.previewing(); }); $(&quot;#fullscreen-btn&quot;).bind('click', function() { testEditor.fullscreen(); }); $(&quot;#show-toolbar-btn&quot;).bind('click', function() { testEditor.showToolbar(); }); $(&quot;#close-toolbar-btn&quot;).bind('click', function() { testEditor.hideToolbar(); }); $(&quot;#toc-menu-btn&quot;).click(function(){ testEditor.config({ tocDropdown : true, tocTitle : &quot;目录 Table of Contents&quot;, }); }); $(&quot;#toc-default-btn&quot;).click(function() { testEditor.config(&quot;tocDropdown&quot;, false); }); }); &lt;/script&gt; 对于配置项只说明一点，就是主题theme的设置: 打开同一目录下的theme.html（用浏览器打开），这时候你可以看到不同主题的呈现效果，选定你想要的主题，对配置项进行相应的修改。 例如我修改的配置项如下： theme : &quot;default&quot;, previewTheme : &quot;default&quot;, editorTheme : &quot;base16-light&quot;, 对于函数，只有两个函数与我们的需求相关，那就是getHtml()还有getMarkDown()函数，这两个函数是否符合我们的需求的。 3.开始实战 清空example文件夹下的所有html文件,并建立两个html文件，admin.html是后台管理页，user.html用于前台展示页 两个文件分别引入相关的css和js文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/editormd.css&quot; /&gt; &lt;script src=&quot;js/zepto.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../editormd.js&quot;&gt;&lt;/script&gt; admin.html &lt;div id=&quot;layout&quot;&gt; &lt;div class=&quot;editormd&quot; id=&quot;test-editormd&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;br/&gt;&lt;input id=&quot;submit&quot; type=&quot;button&quot; name=&quot;submit&quot; value=&quot;Submit&quot; class=&quot;btn&quot; style=&quot;margin-left: 5%;&quot; /&gt; &lt;button id=&quot;preview-btn&quot;&gt;Preview HTML (Press Shift + ESC cancel)&lt;/button&gt; &lt;/div&gt; js部分新建一个editormd对象： testEditor = editormd(); submit函数用于获取html代码和markdown源代码： document.getElementById(&quot;submit&quot;).onclick = function(){ let htmlCode = document.getElementsByClassName(&quot;editormd-preview-container&quot;)[0].innerHTML; let mdCode = testEditor.getMarkdown(); console.log(htmlCode); } 模拟用户从数据库拿到md源代码，可以修改文章: document.getElementsByTagName('textarea')[0].innerHTML = &quot;##HELLO keke&quot;; user.html &lt;div class=&quot;markdown-body editormd-preview-container&quot;&gt;&lt;/div&gt; 模拟从后台获取数据 编辑后台管理（admin.html)md编辑器，按submit按钮，把控制台打印出来的代码贴到（user.html)markdowm-body标签里面： &lt;div class=&quot;markdown-body editormd-preview-container&quot;&gt; &lt;h2 id=&quot;h2-kek&quot;&gt;&lt;a name=&quot;kek&quot; class=&quot;reference-link&quot;&gt;&lt;/a&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;&gt;&lt;/span&gt;kek&lt;/h2&gt;&lt;p&gt;Wad&lt;/p&gt; &lt;div class=&quot;markdown-toc editormd-markdown-toc&quot;&gt;&lt;ul class=&quot;markdown-toc-list&quot;&gt;&lt;li&gt;&lt;a class=&quot;toc-level-2&quot; href=&quot;#kek&quot; level=&quot;2&quot;&gt;kek&lt;/a&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;pre class=&quot;prettyprint linenums prettyprinted&quot;&gt;&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; i &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt; &lt;/div&gt; 注意：关键点就在于获取容器editormd-preview-container里面的html代码了 ","link":"https://shineyangpro.com/shi-yong-editormd-zuo-wei-hou-tai-fu-wen-ben-bian-ji-qi-yi-ji-qian-tai-markdown-wen-dang-zhan-shi/"},{"title":"JQuery 如何ul动态添加li标签","content":"首先在html页面中找到相应的ul标签对。 如下图： &lt;ul id=&quot;ulPlayPist&quot;&gt; &lt;li class=&quot;li_style&quot;&gt; &lt;div id=&quot;divItem1&quot; class=&quot;div_item_v_style&quot;&gt; &lt;img id=&quot;img_item_1&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt; &lt;input id=&quot;listItem_1&quot; type=&quot;button&quot; value=&quot;暂无&quot; class=&quot;btn_list_item_v_style&quot; onclick=&quot;Item_Click(1);&quot;/&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; 上面是一个html文件内ul标签的一个范例，并且li标签内含有div 等子标签。这个就不多说了，如果不懂建议先学习一下html基础。 二、需要在js函数内找到ul标签控件。 要获取ul对象可以通过id来进行查找。不过jQuery提供了一些简单的方法。 如下图： //通过id=lPlayPist查找ul标签控件 $('#ulPlayPist').append(&quot;&quot;); 上面代码已经包含查找一阶添加。 三、动态添加。 组织需要添加标签String。如下 var li_str = '&lt;li class=&quot;li_style&quot;&gt;'; li_str += '&lt;div id=&quot;divItem'+(i+1).toString()+'&quot; class=&quot;div_item_v_style&quot;&gt;'; li_str += '&lt;img id=&quot;img_item_' + (i + 1).toString() + '&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt;'; li_str += '&lt;input id=&quot;listItem_' + (i + 1).toString() + '&quot; type=&quot;button&quot; value=&quot;' + dict_data[&quot;List&quot;][i] + '&quot; class=&quot;btn_list_item_v_style&quot; οnclick=&quot;Item_Click(' + (i + 1).toString() + ');&quot;/&gt;'; li_str += '&lt;/div&gt;&lt;/li&gt;'; 然后通过append这个语句，添加进去。 //添加数据到UL function AddListToUl(dict_data) { var list_count = parseInt(dict_data[&quot;Count&quot;]); $(&quot;#ulPlayPist&quot;).find(&quot;li&quot;).remove(); for (var i = 0; i &lt; list_count; i++) { var li_str = '&lt;li class=&quot;li_style&quot;&gt;'; li_str += '&lt;div id=&quot;divItem'+(i+1).toString()+'&quot; class=&quot;div_item_v_style&quot;&gt;'; li_str += '&lt;img id=&quot;img_item_' + (i + 1).toString() + '&quot; src=&quot;../img/Icon_Movie.png&quot; class=&quot;img_v_style&quot;/&gt;'; li_str += '&lt;input id=&quot;listItem_' + (i + 1).toString() + '&quot; type=&quot;button&quot; value=&quot;' + dict_data[&quot;List&quot;][i] + '&quot; class=&quot;btn_list_item_v_style&quot; οnclick=&quot;Item_Click(' + (i + 1).toString() + ');&quot;/&gt;'; li_str += '&lt;/div&gt;&lt;/li&gt;'; $('#ulPlayPist').append(li_str); } } 以上就是基本代码 ","link":"https://shineyangpro.com/jquery-ru-he-ul-dong-tai-tian-jia-li-biao-qian/"},{"title":"Gin框架介绍及使用","content":"Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上Gin。 Gin框架安装与使用 安装 下载并安装Gin: go get -u github.com/gin-gonic/gin 第一个Gin示例： package main import ( &quot;github.com/gin-gonic/gin&quot; ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(&quot;/hello&quot;, func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() } 将上面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。 RESTful API REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。 推荐阅读阮一峰 理解RESTful架构 简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。 GET用来获取资源 POST用来新建资源 PUT用来更新资源 DELETE用来删除资源。 只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。 例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式： Gin框架支持开发RESTful API的开发。 func main() { r := gin.Default() r.GET(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;GET&quot;, }) }) r.POST(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;POST&quot;, }) }) r.PUT(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;PUT&quot;, }) }) r.DELETE(&quot;/book&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;DELETE&quot;, }) }) } 开发RESTful API的时候我们通常使用Postman来作为客户端的测试工具。 Gin渲染 我们首先定义一个存放模板文件的templates文件夹，然后在其内部按照业务分别定义一个posts文件夹和一个users文件夹。 posts/index.html文件的内容如下： {{define &quot;posts/index.html&quot;}} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;posts/index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{.title}} &lt;/body&gt; &lt;/html&gt; {{end}} users/index.html文件的内容如下： {{define &quot;users/index.html&quot;}} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;users/index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{.title}} &lt;/body&gt; &lt;/html&gt; {{end}} Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。 func main() { r := gin.Default() r.LoadHTMLGlob(&quot;templates/**/*&quot;) //r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;) r.GET(&quot;/posts/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{ &quot;title&quot;: &quot;posts/index&quot;, }) }) r.GET(&quot;users/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{ &quot;title&quot;: &quot;users/index&quot;, }) }) r.Run(&quot;:8080&quot;) } 自定义模板函数 定义一个不转义相应内容的safe模板函数如下：func main() { router := gin.Default() router.SetFuncMap(template.FuncMap{ &quot;safe&quot;: func(str string) template.HTML{ return template.HTML(str) }, }) router.LoadHTMLFiles(&quot;./index.tmpl&quot;) router.GET(&quot;/index&quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &quot;index.tmpl&quot;, &quot;&lt;a href='https://liwenzhou.com'&gt;李文周的博客&lt;/a&gt;&quot;) }) router.Run(&quot;:8080&quot;) } 在index.tmpl中使用定义好的safe模板函数： <!DOCTYPE html> 修改模板引擎的标识符 {{ . | safe }} ``` + 静态文件处理 当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用gin.Static方法即可。 ``` func main() { r := gin.Default() r.Static(\"/static\", \"./static\") r.LoadHTMLGlob(\"templates/**/*\") // ... r.Run(\":8080\") } ``` + 使用模板继承 Gin框架默认都是使用单模板，如果需要使用block template功能，可以通过&quot;github.com/gin-contrib/multitemplate&quot;库实现，具体示例如下： 首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中home.tmpl和index.tmpl继承了base.tmpl： templates ├── includes │ ├── home.tmpl │ └── index.tmpl ├── layouts │ └── base.tmpl └── scripts.tmpl 然后我们定义一个loadTemplates函数如下： func loadTemplates(templatesDir string) multitemplate.Renderer { r := multitemplate.NewRenderer() layouts, err := filepath.Glob(templatesDir + &quot;/layouts/*.tmpl&quot;) if err != nil { panic(err.Error()) } includes, err := filepath.Glob(templatesDir + &quot;/includes/*.tmpl&quot;) if err != nil { panic(err.Error()) } // 为layouts/和includes/目录生成 templates map for _, include := range includes { layoutCopy := make([]string, len(layouts)) copy(layoutCopy, layouts) files := append(layoutCopy, include) r.AddFromFiles(filepath.Base(include), files...) } return r } 我们在main函数中 func indexFunc(c *gin.Context){ c.HTML(http.StatusOK, &quot;index.tmpl&quot;, nil) } func homeFunc(c *gin.Context){ c.HTML(http.StatusOK, &quot;home.tmpl&quot;, nil) } func main(){ r := gin.Default() r.HTMLRender = loadTemplates(&quot;./templates&quot;) r.GET(&quot;/index&quot;, indexFunc) r.GET(&quot;/home&quot;, homeFunc) r.Run() } 补充文件路径处理 关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。 func getCurrentPath() string { if ex, err := os.Executable(); err == nil { return filepath.Dir(ex) } return &quot;./&quot; } JSON渲染 func main() { r := gin.Default() // gin.H 是map[string]interface{}的缩写 r.GET(&quot;/someJSON&quot;, func(c *gin.Context) { // 方式一：自己拼接JSON c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;}) }) r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) { // 方法二：使用结构体 var msg struct { Name string `json:&quot;user&quot;` Message string Age int } msg.Name = &quot;小王子&quot; msg.Message = &quot;Hello world!&quot; msg.Age = 18 c.JSON(http.StatusOK, msg) }) r.Run(&quot;:8080&quot;) } XML渲染 注意需要使用具名的结构体类型。 func main() { r := gin.Default() // gin.H 是map[string]interface{}的缩写 r.GET(&quot;/someXML&quot;, func(c *gin.Context) { // 方式一：自己拼接JSON c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;}) }) r.GET(&quot;/moreXML&quot;, func(c *gin.Context) { // 方法二：使用结构体 type MessageRecord struct { Name string Message string Age int } var msg MessageRecord msg.Name = &quot;小王子&quot; msg.Message = &quot;Hello world!&quot; msg.Age = 18 c.XML(http.StatusOK, msg) }) r.Run(&quot;:8080&quot;) } YMAL渲染 r.GET(&quot;/someYAML&quot;, func(c *gin.Context) { c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK}) }) protobuf渲染 r.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) { reps := []int64{int64(1), int64(2)} label := &quot;test&quot; // protobuf 的具体定义写在 testdata/protoexample 文件中。 data := &amp;protoexample.Test{ Label: &amp;label, Reps: reps, } // 请注意，数据在响应中变为二进制数据 // 将输出被 protoexample.Test protobuf 序列化了的数据 c.ProtoBuf(http.StatusOK, data) }) 获取参数 获取querystring参数 querystring指的是URL中?后面携带的参数，例如：/user/search?username=小王子&amp;address=沙河。 获取请求的querystring参数的方法如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(&quot;/user/search&quot;, func(c *gin.Context) { username := c.DefaultQuery(&quot;username&quot;, &quot;小王子&quot;) //username := c.Query(&quot;username&quot;) address := c.Query(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run() } 获取form参数 请求的数据通过form表单来提交，例如向/user/search发送一个POST请求，获取请求数据的方式如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.POST(&quot;/user/search&quot;, func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 //username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;) username := c.PostForm(&quot;username&quot;) address := c.PostForm(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run(&quot;:8080&quot;) } 获取path参数 请求的参数通过URL路径传递，例如：/user/search/小王子/沙河。 获取请求URL路径中的参数的方式如下。 func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(&quot;/user/search/:username/:address&quot;, func(c *gin.Context) { username := c.Param(&quot;username&quot;) address := c.Param(&quot;address&quot;) //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;ok&quot;, &quot;username&quot;: username, &quot;address&quot;: address, }) }) r.Run(&quot;:8080&quot;) } 参数绑定 为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。 // Binding from JSON type Login struct { User string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;` Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;` } func main() { router := gin.Default() // 绑定JSON的示例 ({&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;}) router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) { var login Login if err := c.ShouldBind(&amp;login); err == nil { fmt.Printf(&quot;login info:%#v\\n&quot;, login) c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // 绑定form表单示例 (user=q1mi&amp;password=123456) router.POST(&quot;/loginForm&quot;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(&amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456) router.GET(&quot;/loginForm&quot;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(&amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ &quot;user&quot;: login.User, &quot;password&quot;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()}) } }) // Listen and serve on 0.0.0.0:8080 router.Run(&quot;:8080&quot;) } ShouldBind会按照下面的顺序解析请求中的数据完成绑定： 1、如果是 GET 请求，只使用 Form 绑定引擎（query）。 2、如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。 文件上传 单个文件上传 文件上传前端页面代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;title&gt;上传文件示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;f1&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 后端gin框架部分代码： func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(&quot;/upload&quot;, func(c *gin.Context) { // 单个文件 file, err := c.FormFile(&quot;f1&quot;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ &quot;message&quot;: err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: fmt.Sprintf(&quot;'%s' uploaded!&quot;, file.Filename), }) }) router.Run() } 多个文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(&quot;/upload&quot;, func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[&quot;file&quot;] for index, file := range files { log.Println(file.Filename) dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) } c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)), }) }) router.Run() } 重定向 HTTP重定向 HTTP 重定向很容易。 内部、外部重定向均支持。 r.GET(&quot;/test&quot;, func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, &quot;http://www.sogo.com/&quot;) }) 路由重定向 路由重定向，使用HandleContext： r.GET(&quot;/test&quot;, func(c *gin.Context) { // 指定重定向的URL c.Request.URL.Path = &quot;/test2&quot; r.HandleContext(c) }) r.GET(&quot;/test2&quot;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;}) }) 普通路由 r.GET(&quot;/index&quot;, func(c *gin.Context) {...}) r.GET(&quot;/login&quot;, func(c *gin.Context) {...}) r.POST(&quot;/login&quot;, func(c *gin.Context) {...}) 此外，还有一个可以匹配所有请求方法的Any方法如下： r.Any(&quot;/test&quot;, func(c *gin.Context) {...}) 为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回views/404.html页面。 r.NoRoute(func(c *gin.Context) { c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil) }) 路由组 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 func main() { r := gin.Default() userGroup := r.Group(&quot;/user&quot;) { userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...}) userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...}) } shopGroup := r.Group(&quot;/shop&quot;) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...}) shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...}) } r.Run() } 路由组也是支持嵌套的，例如： shopGroup := r.Group(&quot;/shop&quot;) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...}) shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...}) // 嵌套路由组 xx := shopGroup.Group(&quot;xx&quot;) xx.GET(&quot;/oo&quot;, func(c *gin.Context) {...}) } Gin中间件 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 定义中间件 Gin中的中间件必须是一个gin.HandlerFunc类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。 // StatCost 是一个统计耗时请求耗时的中间件 func StatCost() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Set(&quot;name&quot;, &quot;小王子&quot;) // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值 // 调用该请求的剩余处理程序 c.Next() // 不调用该请求的剩余处理程序 // c.Abort() // 计算耗时 cost := time.Since(start) log.Println(cost) } } 注册中间件 在gin框架中，我们可以为每个路由添加任意数量的中间件。 为全局路由注册 func main() { // 新建一个没有任何默认中间件的路由 r := gin.New() // 注册一个全局中间件 r.Use(StatCost()) r.GET(&quot;/test&quot;, func(c *gin.Context) { name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) r.Run() } 为某个路由单独注册 // 给/test2路由单独注册中间件（可注册多个） r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) { name := c.MustGet(&quot;name&quot;).(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;Hello world!&quot;, }) }) 为路由组注册中间件 为路由组注册中间件有以下两种写法。 写法1： shopGroup := r.Group(&quot;/shop&quot;, StatCost()) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) ... } 写法2: shopGroup := r.Group(&quot;/shop&quot;) shopGroup.Use(StatCost()) { shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...}) ... } 中间件注意事项 gin默认中间件 gin.Default()默认使用了Logger和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release。 Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。 gin中间件中使用goroutine 当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 运行多个服务 我们可以在多个端口启动服务，例如： package main import ( &quot;log&quot; &quot;net/http&quot; &quot;time&quot; &quot;github.com/gin-gonic/gin&quot; &quot;golang.org/x/sync/errgroup&quot; ) var ( g errgroup.Group ) func router01() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&quot;/&quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &quot;code&quot;: http.StatusOK, &quot;error&quot;: &quot;Welcome server 01&quot;, }, ) }) return e } func router02() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&quot;/&quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &quot;code&quot;: http.StatusOK, &quot;error&quot;: &quot;Welcome server 02&quot;, }, ) }) return e } func main() { server01 := &amp;http.Server{ Addr: &quot;:8080&quot;, Handler: router01(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server02 := &amp;http.Server{ Addr: &quot;:8081&quot;, Handler: router02(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } // 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务 g.Go(func() error { return server01.ListenAndServe() }) g.Go(func() error { return server02.ListenAndServe() }) if err := g.Wait(); err != nil { log.Fatal(err) } } ","link":"https://shineyangpro.com/gin-kuang-jia-jie-shao-ji-shi-yong/"},{"title":"MWeb 3.4.1 中文破解版 (专业Markdown写作软件)","content":"安装步骤 如果遇到xxx.app已损坏，你应该将它移到废纸篓」 或者 「来自身份不明开发者」问题，请看解决办法: 1、最简单的方式：按住键盘上的control键，点击或者右键应用图标，再点击打开即可，但是此方法无疑是麻烦的。 2、打开终端输入:sudo spctl --master-disable 安装与激活 MWeb 如图所示：按住 control 键点击[安装]，再点击打开 ，按提示操作即可自动完成 MWeb 破解安装。 软件介绍/功能 MWeb是一款适用于macOS的专业Markdown写作、笔记本应用软件。喜欢写博客的朋友，那你一定会需要MWeb 破解版这款软件。为您提供最佳的写作体验。现为大家带来MWeb mac 破解版，此版本已经为大家破解激活，无需输入MWeb 激活码。 Markdown 语法支持 使用 Github Flavored Markdown 语法，简称 GFM 语法。支持表格、TOC、LaTeX、代码块、任务列表、脚注等。画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。 辅助功能 支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。在兼容 Markdown 语法的情况下支持设置图片宽度。好用的表格插入和 LaTeX 书写辅助。 输出功能 支持导出为图片、HTML、Epub、PDF、RTF、Docx。支持发布到 Wordpress、印象笔记、Blogger、Medium、Tumblr等。支持七牛云、又拍云等以及自定义的图床服务。 更多详情进入官网了解，点我传送 下载安装 下载地址1:点我传送 下载地址2点我传送 如果下载地址1无法访问，请使用下载地址2 ","link":"https://shineyangpro.com/mweb-341-zhong-wen-po-jie-ban-zhuan-ye-markdown-xie-zuo-ruan-jian/"},{"title":"在 Mac 端获取【网易云音乐】付费音乐的播放地址（注意下载要坚决支持正版！）","content":"在网易云音乐下载付费音乐，如果你是未付费人员会弹出如下的提示： 出于好奇，感觉音乐既然已经能够试听肯定是有有效的下载地址，只是在下载的时候做了权限判断，既然有地址那怎么去获取呢？ 首先查看下 云音乐 这个软件的 Bundle identifier ： 然后按照 Mac 软件的惯例，存在默认的缓存目录，先去看看果真有一个 com.netease.163music 文件夹。路径如下： 但是查看里面的信息只有一部分数据库记录和音乐专辑封面图片的缓存内容，使用 Navicat 查看也并未找到音乐地址的相关信息，难道就这样结束了吗？ 既然 Bundle identifier 以及 缓存目录中 163music 这个关键字，依据大家习惯的命名规则，应该通过这个也能定位查找到一部分数据信息呀，采用直接的关键字全局搜索还真的找到了部分日志文件：(或者可以打开Mac自带的控制台) 通过修改日期排列下顺序，那就直接 cat 看一下最近的那一个，不看不知道，一看这里面还真记录了基本上我听过的每首歌曲的详细信息啊，那就 COM+F 直接搜索刚才的一首 【爸爸妈妈】，直接就定位如下： 可以看到，有相关的歌词信息，也有具体的下载信息，为了保证用户可以正常欣赏咱们可以看到具体的播放地址有三个，看来网易的工作人员还是蛮严谨的嘛，直接去浏览器验证下地址： 果真是刚才听得的哪一首 _ 不过到最后还是要说，这属于一次好奇心“研究”，生命在于折腾寻找不同的可行路线嘛。 大家下载音乐还是要支持正版啊，支持辛苦创作的音乐人！ ","link":"https://shineyangpro.com/zai-mac-duan-huo-qu-wang-yi-yun-yin-le-fu-fei-yin-le-de-bo-fang-di-zhi-zhu-yi-xia-zai-yao-jian-jue-zhi-chi-zheng-ban/"},{"title":"Mac版Office 2019官方原版安装包和激活工具，Office 2019激活工具：Microsoft_Office_2019_VL_Serializer.pkg","content":"步骤预览 1、下载并安装 Office 2019 for mac 安装包； 2、安装 Office 2019 for mac 激活软件包； Office 2019激活方法：安装完Office后，运行下载的pkg文件按照提示进行激活。 安装 ① 下载 Mac版Office 2019 ② 安装 下载好的Office 2019 for Mac 激活 ①下载 Office 2019 for mac激活软件 ②安装下载好的Office 2019 for mac激活软件 完成了 那两个都安装完成后就Office 2019 for mac破解成功了，功能也会全部解锁。 Mac版Office 2019简介 Office 2019 mac简体中文版已经推出，具体包含Word，Excel，PowerPoint，Outlook，OneNote五大套件，注册登陆用户可以漫游文具包以及个性化功能区。 Office 2019 mac新版中，Word支持焦点模式（专注模式），也就是类似Win10 v1803中的“专注助手”，可以让你专心码字而屏蔽掉一切通知，声音等干扰内容。同时，还有新的内置翻译，无障碍优化等。 PPT加入了更多的转场效果，3D模型，时序序列以及4K视频导出； Excel预先添加了更多函数（CONCAT，TEXTJOIN，IFS，SWITCH），表格甚至2D地图等，OutLook的收件箱体验改善。 ","link":"https://shineyangpro.com/mac-ban-office-2019-guan-fang-yuan-ban-an-zhuang-bao-he-ji-huo-gong-ju-office-2019-ji-huo-gong-ju-microsoft_office_2019_vl_serializerpkg/"},{"title":"Navicat Premium 15.0.22 强大的数据库管理工具(Big Sur 可用)","content":" Navicat Premium是一个可多重连接的数据库管理工具，Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器的新手来说又相当容易学习。它可让你以单一程序同時连接到目前世面上所有版本的主流数据库并进行管理和操作，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL。让管理不同类型的数据库更加方便。 应用介绍 Navicat Premium 结合了其他 Navicat 成员的功能。有了不同数据库类型的连接能力，Navicat Premium 支持在 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 之间传输数据。包括存储过程，事件，触发器，函数，视图等。 Navicat Premium 适用于三种平台 - Microsoft Windows、Mac OS X 及 Linux。它可以让用户连接本机或远程服务器、提供一些实用的数据库工具如数据模型工具、数据同步、结构同步、导入、导出、备份、还原及报表以协助管理数据。 下载 点我传送 推荐 如果上面的打不开，可以使用百度网盘下载点我下载 提取码:pdt8 ","link":"https://shineyangpro.com/navicat-premium-15022-qiang-da-de-shu-ju-ku-guan-li-gong-ju-big-sur-ke-yong/"},{"title":"Swift-如何实现Cell可收起和展开","content":"这是一个简单的iOS swift项目，旨在介绍如何实现可收起和展开的table section，并且，项目不需要main storyboard, XIB, 注册nib等，只需要纯的Swfit代码！ 项目源代码 如果你希望获得Swift 3.0的代码，可以在migrate-to-swift-3.0分支里找到, 最终将会汇入master分支。 效果 如何实现可收起和展开的Table Section? 第一步. 准备数据 假设我们有如下的数据，它已经按照不同的section进行组织和整理，每个section都是一个Section结构（或对象）： struct Section { var name: String! var items: [String]! var collapsed: Bool! init(name: String, items: [String], collapsed: Bool = false) { self.name = name self.items = items self.collapsed = collapsed } } var sections = [Section]() sections = [ Section(name: &quot;Mac&quot;, items: [&quot;MacBook&quot;, &quot;MacBook Air&quot;, &quot;MacBook Pro&quot;, &quot;iMac&quot;, &quot;Mac Pro&quot;, &quot;Mac mini&quot;, &quot;Accessories&quot;, &quot;OS X El Capitan&quot;]), Section(name: &quot;iPad&quot;, items: [&quot;iPad Pro&quot;, &quot;iPad Air 2&quot;, &quot;iPad mini 4&quot;, &quot;Accessories&quot;]), Section(name: &quot;iPhone&quot;, items: [&quot;iPhone 6s&quot;, &quot;iPhone 6&quot;, &quot;iPhone SE&quot;, &quot;Accessories&quot;]) ] collapsed表示当前的section是否被收起或展开，默认下是false，即展开。 第二步. Section Header 根据苹果 API reference, 我们应该使用UITableViewHeaderFooterView. 让我们创建一个section header的类来继承它，我们把这个section header类起名为CollapsibleTableViewHeader: class CollapsibleTableViewHeader: UITableViewHeaderFooterView { let titleLabel = UILabel() let arrowLabel = UILabel() override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) contentView.addSubview(titleLabel) contentView.addSubview(arrowLabel) } required init?(coder aDecoder: NSCoder) { fatalError(&quot;init(coder:) has not been implemented&quot;) } } 当用户点击section header的时候我们需要收起或者展开这个section，为了实现这样的效果，让我们借用一下UITapGestureRecognizer. 同时我们需要将这个tap事件通知给table view并让它来更新section的collapsed值。 protocol CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) } class CollapsibleTableViewHeader: UITableViewHeaderFooterView { var delegate: CollapsibleTableViewHeaderDelegate? var section: Int = 0 ... override init(reuseIdentifier: String?) { super.init(reuseIdentifier: reuseIdentifier) ... addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(CollapsibleTableViewHeader.tapHeader(_:)))) } ... func tapHeader(gestureRecognizer: UITapGestureRecognizer) { guard let cell = gestureRecognizer.view as? CollapsibleTableViewHeader else { return } delegate?.toggleSection(self, section: cell.section) } func setCollapsed(collapsed: Bool) { // Animate the arrow rotation (see Extensions.swf) arrowLabel.rotate(collapsed ? 0.0 : CGFloat(M_PI_2)) } } 既然我们不用任何storyboard或者XIB，如何实现自动布局呢？答案是运用NSLayoutConstraint的constraintsWithVisualFormat函数。 override init(reuseIdentifier: String?) { ... // arrowLabel must have fixed width and height arrowLabel.widthAnchor.constraintEqualToConstant(12).active = true arrowLabel.heightAnchor.constraintEqualToConstant(12).active = true titleLabel.translatesAutoresizingMaskIntoConstraints = false arrowLabel.translatesAutoresizingMaskIntoConstraints = false } override func layoutSubviews() { super.layoutSubviews() ... let views = [ &quot;titleLabel&quot; : titleLabel, &quot;arrowLabel&quot; : arrowLabel, ] contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;H:|-20-[titleLabel]-[arrowLabel]-20-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[titleLabel]-|&quot;, options: [], metrics: nil, views: views )) contentView.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat( &quot;V:|-[arrowLabel]-|&quot;, options: [], metrics: nil, views: views )) } 第三步. UITableView DataSource 以及 Delegate 首先，sections的数量为sections.count: override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return sections.count } 每个section里面cell的数量为: override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return sections[section].items.count } 接下来使用tableView的viewForHeaderInSection函数来渲染我们的section header: override func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { let header = tableView.dequeueReusableHeaderFooterViewWithIdentifier(&quot;header&quot;) as? CollapsibleTableViewHeader ?? CollapsibleTableViewHeader(reuseIdentifier: &quot;header&quot;) header.titleLabel.text = sections[section].name header.arrowLabel.text = &quot;&gt;&quot; header.setCollapsed(sections[section].collapsed) header.section = section header.delegate = self return header } 普通的cell就很简单了，没什么好说的： override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) as UITableViewCell? ?? UITableViewCell(style: .Default, reuseIdentifier: &quot;cell&quot;) cell.textLabel?.text = sections[indexPath.section].items[indexPath.row] return cell } 最后一步. 如何收起和展开？ 思路超级简单！如果该section的collapsed值为true, 我们就将这个section里所有cell的高度都设为0, 否则为 44.0! override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat { return sections[indexPath.section].collapsed! ? 0 : 44.0 } 切换收起和展开的函数如下: extension CollapsibleTableViewController: CollapsibleTableViewHeaderDelegate { func toggleSection(header: CollapsibleTableViewHeader, section: Int) { let collapsed = !sections[section].collapsed // Toggle collapse sections[section].collapsed = collapsed header.setCollapsed(collapsed) // Adjust the height of the rows inside the section tableView.beginUpdates() for i in 0 ..&lt; sections[section].items.count { tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: i, inSection: section)], withRowAnimation: .Automatic) } tableView.endUpdates() } } 注意到我们不是简单的重绘整个section，实际上我们只需要重绘section里的所有cell就好, 这样做的好处是避免了section header因重绘时闪烁的效果, 最重要是的可以让我们更平滑地处理我们想要的动画效果, 例如旋转那个箭头，改变背景颜色等等。 好了就这么多吧，如果你很感兴趣，请参考源码。 更多的关于table section收起和展开的项目 有时候你可能想要在grouped-style的table里实现section的收起和展开, 我写了另外一个Dome 实现的方法其实很类似。 ","link":"https://shineyangpro.com/swift-ru-he-shi-xian-cell-ke-shou-qi-he-zhan-kai/"},{"title":"构建更好的iOS App动画","content":" 动画是高质量用户体验的关键。它们具有多种用途，包括引导用户的注意力并将用户的操作与屏幕上的结果联系起来。 动画使您的应用程序体验独具特色-它们可以使其他媒体无法实现的响应性和交互性达到一定水平。为了制作更好的动画，他们需要传达一种更好的用户交互和视觉变化之间的直接联系感。实现此目的的一种方法是使动画完全互动。 为什么要创建互动动画？ 自从iPhone推出以来，互动动画就已经出现。世界上首次看到原始iPhone的是经典的“滑动解锁”屏幕，用户可以在其中直接移动滑块以解锁设备。对于以前从未使用过多点触摸设备的用户而言，此交互式动画立即直观。 交互式动画使用户可以更好地控制用户界面。直接操纵是自然的交互模型，尤其是在移动设备上。它将他们的动作连接到屏幕上的动画，并让他们完全控制其动作的完成或取消。 他们看起来也很棒。用户通常将应用程序的外观与应用程序的性能相关联，因此，如果应用程序看起来不错，则他们更有可能原谅其他缺点。 在本教程中，我们将使用来在Swift中构建一个交互式弹出动画UIViewPropertyAnimator。 UIViewPropertyAnimator简介 UIViewPropertyAnimator 已在iOS 10中添加到UIKit，并在iOS 11中进行了一些改进。它提供了UIView级别的面向对象的API来创建动画。 使用传统UIView动画，您可以编写如下内容： UIView.animate(withDuration: 1, delay: 0, options: [.curveEaseOut], animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }, completion: nil) 使用new UIViewPropertyAnimator，您可以编写以下代码： let animator = UIViewPropertyAnimator(duration: 1, curve: .easeOut, animations: { self.myView.transform = CGAffineTransform(translationX: 50, y: 0) self.myView.alpha = 0.5 }) animator.startAnimations() 代码非常相似。使用UIViewPropertyAnimator，您首先创建一个动画设计器对象，然后调用startAnimation()而不是在UIView类上调用静态方法。 随着动画复杂性的增加，UIViewPropertyAnimator变得更加有用。让我们看一个更复杂的动画。 该动画在平移视图时开始，可以在任一方向上进行擦洗，并且在平移完成后会动画到其最终位置。 在查看代码之前，了解状态机支持很重要UIViewPropertyAnimator。 动画师可以处于三种可能的状态之一：不活动，活动和停止。动画器初始化为非活动状态，但在启动或暂停时会移动到活动状态。动画完成后，它将返回到非活动状态。如果动画已开始且已暂停，则动画将保持活动状态，并且不会进行状态转换。 让我们看看如何使用UIPanGestureRecognizer旁边的UIViewPropertyAnimator来创建上面的动画。 var animator = UIViewPropertyAnimator() private func handlePan(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animator = UIViewPropertyAnimator(duration: 3, curve: .easeOut, animations: { myView.transform = CGAffineTransform(translationX: 275, y: 0) myView.alpha = 0 }) animator.startAnimation() animator.pauseAnimation() case .changed: animator.fractionComplete = recognizer.translation(in: myView).x / 275 case .ended: animator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 请注意，pauseAnimation()在之后立即调用startAnimation()。因为我们的动画是从平移手势开始的，所以用户最有可能先松开动画，然后再释放其点击。动画暂停时，设置fractionComplete属性以将视图与用户的触摸一起移动。 如果我们尝试使用标准UIView动画执行此操作，则将需要比上面示例中列出的逻辑更多的逻辑。UIView动画无法提供直接控制动画完成百分比的简便方法，也无法让我们轻松地暂停并继续动画直到完成。 让我们建立一个弹出菜单！ 我们将分十步构建一个完全交互式，可中断，可擦除和可逆的弹出菜单。（如果您希望从最终代码开始进行反向操作，则可以在本文末尾找到指向最终存储库的链接。） 为了简单起见，所有视图都将在代码中创建和修改（而不是在故事板中，尽管此代码与在故事板上创建的视图同样适用）。同样，所有代码都将放置在ViewController.swift文件中。 步骤＃1：点击以打开和关闭。 首先，让我们的弹出视图在打开状态和关闭状态之间进行动画处理。这里没有花哨的技巧，只是UIViewPropertyAnimator我们之前学习的基础知识。 private enum State { case closed case open } extension State { var opposite: State { switch self { case .open: return .closed case .closed: return .open } } } class ViewController: UIViewController { private lazy var popupView: UIView = { let view = UIView() view.backgroundColor = .gray return view }() override func viewDidLoad() { super.viewDidLoad() layout() popupView.addGestureRecognizer(tapRecognizer) } private var bottomConstraint = NSLayoutConstraint() private func layout() { popupView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(popupView) popupView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true popupView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true bottomConstraint = popupView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: 440) bottomConstraint.isActive = true popupView.heightAnchor.constraint(equalToConstant: 500).isActive = true } private var currentState: State = .closed private lazy var tapRecognizer: UITapGestureRecognizer = { let recognizer = UITapGestureRecognizer() recognizer.addTarget(self, action: #selector(popupViewTapped(recognizer:))) return recognizer }() @objc private func popupViewTapped(recognizer: UITapGestureRecognizer) { let state = currentState.opposite let transitionAnimator = UIViewPropertyAnimator(duration: 1, dampingRatio: 1, animations: { switch state { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } self.view.layoutIfNeeded() }) transitionAnimator.addCompletion { position in switch position { case .start: self.currentState = state.opposite case .end: self.currentState = state case .current: () } switch self.currentState { case .open: self.bottomConstraint.constant = 0 case .closed: self.bottomConstraint.constant = 440 } } transitionAnimator.startAnimation() } } popupViewTapped函数中有相关的动画代码，在点击视图时会调用该动画。我们只需创建一个动画师，设置其动画以修改约束的值，然后启动动画师。 我们引入一个State枚举来指示弹出窗口是打开还是关闭。它还具有计算opposite属性，该属性返回与当前状态相反的状态。我们本来可以用布尔标志来实现，但这更容易推论，尤其是当我们的动画代码变得更加复杂时。 需要指出的一件事-当动画完成时，我们正在手动更新约束的值。这应该由动画师自动处理，但是显式设置它们可以修复一些边缘错误。 步骤2：添加平移手势。 为了使动画具有交互性，我们将引入第二个手势识别器，即平移手势识别器。这将允许用户通过在弹出视图上滑动来开始和中断动画。 @objc private func popupViewPanned(recognizer: UIPanGestureRecognizer) { switch recognizer.state { case .began: animateTransitionIfNeeded(to: currentState.opposite, duration: 1.5) transitionAnimator.pauseAnimation() case .changed: let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } transitionAnimator.fractionComplete = fraction case .ended: transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) default: () } } 该代码与前面的示例非常相似，不同之处在于可以中断动画。我们已经将动画代码重构为一个名为的函数animateTransitionIfNeeded，该函数可以运行该popupViewTapped函数内部以前的所有代码。 步骤＃3：记录动画进度以修复中断偏移。 一个问题：当动画被中断时，它会偏离用户的触摸。这是由于平移处理程序未考虑动画的当前进度。要解决此问题，我们需要记录fractionComplete动画师的，并在计算平移偏移时将其用作基线。 我们将需要一个属性来存储动画的当前进度： private var animationProgress: CGFloat = 0 当平移手势处于其began状态时，我们记录动画的当前进度： animationProgress = transitionAnimator.fractionComplete 在平移手势的changed状态下，我们将动画进度添加到计算的分数中： transitionAnimator.fractionComplete = fraction + animationProgress 现在，平移手势可以按预期工作，并且可以更自然地跟踪用户的手指。 注意：为了对a进行子类化UIGestureRecognizer，您需要在文件顶部包含此导入： import UIKit.UIGestureRecognizerSubclass 步骤＃5：使用平移速度反转动画。 剩下的一个问题是，弹出窗口不考虑视图的“抛出”方式。如果我们点击关闭的弹出窗口，在动画中期捕获它，然后向下滑动，它将继续对打开的动画进行动画处理。 为了解决这个问题，我们可以有条件地反转动画师。这将基于以下几个因素：弹出窗口的当前状态，动画器当前是否反转以及平移手势的速度。 ended现在，平移手势处理程序的情况如下所示： let yVelocity = recognizer.velocity(in: popupView).y let shouldClose = yVelocity &gt; 0 if yVelocity == 0 { transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) break } switch currentState { case .open: if !shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } case .closed: if shouldClose &amp;&amp; !transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } if !shouldClose &amp;&amp; transitionAnimator.isReversed { transitionAnimator.isReversed = !transitionAnimator.isReversed } } transitionAnimator.continueAnimation(withTimingParameters: nil, durationFactor: 0) 这种逻辑乍一看似乎很复杂，但是可以通过考虑所有可能的情况来得出。 在平移手势处理程序发生更改的情况下，我们需要尊重isReversed动画设计器的属性： let translation = recognizer.translation(in: popupView) var fraction = -translation.y / popupOffset if currentState == .open { fraction *= -1 } if transitionAnimator.isReversed { fraction *= -1 } transitionAnimator.fractionComplete = fraction + animationProgress 现在我们的动画可以反转了！如果用户希望在动画中关闭弹出窗口，则这样做很容易直观。 步骤＃6：设置拐角半径的动画。 在iOS 11中，CALayer无需设置即可设置动画人物的拐角半径CABasicAnimation。这意味着我们可以在动画块中更新视图的角半径，它就可以工作！ self.popupView.layer.cornerRadius = 20 我们还可以指定圆角。在这种情况下，我们只希望对左上角和右上角进行圆角处理。 view.layer.maskedCorners = [.layerMaxXMinYCorner, .layerMinXMinYCorner] 现在，顶部的两个角与我们的原始动画一起被动画化。 步骤＃7：使其更漂亮！ 我们的灰色弹出视图效果很好，但可以进行一些视觉上的改进。让我们添加背景图像，叠加视图，标题标签，细微阴影和一些示例评论。 本教程将不介绍这些其他视图的实现。如果您想了解它们的创建方式，请在文章底部查看完整的源代码。 好多了。 😎 步骤＃8：对标签进行动画处理。 关闭弹出窗口时，“审阅”标签看起来不错，但是当打开时，它无法从其余内容中脱颖而出。打开弹出窗口时，我们希望为标签提供更大的字体大小和更深的颜色。由于我们的弹出窗口是完全交互式且可擦除的，因此需要对标签过渡进行动画处理。 没有内置的方式来设置标签的颜色或字体样式的动画。我们的解决方案是一个简单的解决方法：交叉淡化标签。 为了使动画平滑，我们需要对每个标签的比例和平移进行动画处理，以使它们在动画的整个过程中完美重叠。 在动画块内，我们修改标签的alpha和transform： switch state { case .open: // other animations here ... self.closedTitleLabel.transform = CGAffineTransform(scaleX: 1.6, y: 1.6).concatenating(CGAffineTransform(translationX: 0, y: 15)) self.openTitleLabel.transform = .identity self.openTitleLabel.alpha = 1 self.closedTitleLabel.alpha = 0 case .closed: // other animations here ... self.closedTitleLabel.transform = .identity self.openTitleLabel.transform = CGAffineTransform(scaleX: 0.65, y: 0.65).concatenating(CGAffineTransform(translationX: 0, y: -15)) self.openTitleLabel.alpha = 0 self.closedTitleLabel.alpha = 1 } 现在，标签看起来就像它们在彼此变形一样。正确对齐后，看起来只有一个标签。 步骤＃9：重构多个动画制作者。 标签动画效果很好，但是可以改善时间以进一步平滑过渡。为了修改标签动画的时序曲线，我们需要其他动画师。AUIViewPropertyAnimator只能有一条时序曲线，因此要使用多个时序曲线，我们需要协调多个动画制作者。 我们需要稍微重构代码以支持任意数量的动画制作者。为此，我们将创建一系列动画师。 private var runningAnimators = [UIViewPropertyAnimator]() 每当我们创建新的动画师时，我们都会将其添加到正在运行的动画师数组中。 runningAnimators.append(transitionAnimator) 每当动画结束时，我们都会将其从数组中删除。为了使其余代码可与多个动画师一起使用，应用于的所有内容transitionAnimator都将应用于整个数组。 步骤＃10：为标签alpha添加新的动画师。 借助新的基础架构，我们可以创建两个新的动画师：一个为新标签制作动画，另一个为旧标签制作动画。使用多个动画制作者的好处是每个动画制作者都有自己的时序曲线。 let inTitleAnimator = UIViewPropertyAnimator(duration: duration, curve: .easeIn, animations: { switch state { case .open: self.openTitleLabel.alpha = 1 case .closed: self.closedTitleLabel.alpha = 1 } }) inTitleAnimator.scrubsLinearly = false 我们将动画师的scrubsLinearly属性设置为false，以便fractionComplete动画的映射到缓动时序曲线，而不是线性时序曲线。通常，跟随用户手指的动画应遵循线性时序曲线，这就是为什么此属性默认为true的原因。 （注意：scrubsLinearly仅在iOS 11+上可用） 两者之间的差异很小，但可以在以后进一步自定义动画。当用户完全控制动画并可以将其拖到任何位置时，正确实现此过渡非常重要。 这是我们的最终动画！用户可以通过轻击或滑动开始动画，可以中断动画，并可以反转动画。相当少量的代码，很酷。 什么时候应该使用UIViewPropertyAnimator？ iOS中有如此众多的动画API，什么时候最好使用UIViewPropertyAnimator？ 差异是可中断性。如果要在飞行过程中“捕捉”视图，进行擦洗，然后继续或反转动画，UIViewPropertyAnimator则是最佳选择。其他一些动画策略是可中断的，例如在滚动视图的contentOffset属性旁边设置视图动画，但这些动画仅限于滚动视图的时序曲线。 有时，动画可中断是没有意义的。仅当用户可以在动画过程中点击视图时，才使动画可中断。动画应具有足够长的持续时间，以使用户可以足够快地做出反应以点击它，而动画视图应具有较大的点击目标。上面的弹出动画是满足这些要求的完美示例。 链接与资源 完整的源代码可在GitHub上找到：点我传送 ","link":"https://shineyangpro.com/gou-jian-geng-hao-de-ios-app-dong-hua/"},{"title":"ThinkPHP5.0路径中去除index.php入口文件方式","content":"1、httpd.conf配置文件中加载了mod_rewrite.so模块 //在APACHE里面去配置 #LoadModule rewrite_module modules/mod_rewrite.so把前面的警号去掉,如下图: 如果没有，可以自己添加进去（我的是没有，我自己添加进去的） 2、AllowOverride None 讲None改为 All （搜索到的全部改为All就好，小写的就改成小写的all） 3、确保URL_MODEL设置为2，在项目的配置文件里写 4、.htaccess文件必须放到跟目录下（没有就新建一个，TP5.0有自带(application这个文件夹)，可以拷贝出来，Mac下按command+Shift+.可以显示隐藏文件）在里面添加如下内容： &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/IfModule&gt; ","link":"https://shineyangpro.com/thinkphp50-lu-jing-zhong-qu-chu-indexphp-ru-kou-wen-jian-fang-shi/"},{"title":"Swift NSClassFromString初始化控制器","content":"在OC中我们反射是这样的： [[NSClassFromString(@&quot;Foo&quot;) alloc] init]; 但是在Swift中这种方式是不可用的，经过查找资料，琢磨，终于找到了方法 swift中的NSClassFromString是这样的： ","link":"https://shineyangpro.com/swift-nsclassfromstring-chu-shi-hua-kong-zhi-qi/"},{"title":"Mac下使用Visual Studio Code调试C#控制台程序以及相关的配置（2）","content":"安装.NET Core 在mac上打开终端输入以下命令: ~$ brew update ~$ brew install openssl ~$ brew link --force openssl 如果不能使用brew命令，先安装homebrew，玩转Mac必备。下载.NET Core SDK：https://go.microsoft.com/fwlink/?LinkID=80912下载完成后双击pkg安装，如下图所示：一路Next完成后.Net Core就在Mac上安装好了。 新建一个.NET Core的程序 打开Mac的终端： mkdir hwapp cd hwapp 然后创建一个简单控制台程序如：dotnet new console （创建控制台应用程序） 这几个命令是新建一个叫hwapp的目录然后在该目录下初始化一个项目，类似于用VS新建一个控制台项目，如下图所示： 运行一个程序 在终端定位到hwapp目录然后执行命令： dotnet restore dotnet run 这2个命令是说还原该项目的依赖，并且编译运行，输出Hello World， 安装Visual Studio Code Mac上没有宇宙第一IDE VS 那我们怎么写代码呢？别急，微软为了.NET Core的跨平台计划已经给我们开发了一款编辑器 VS Code。虽然VS Code没发布多久，但是个人觉得已经超越了Atom，Sublime Text等Mac上以前常用的编辑器。不光可以开发C#，而且调试Nodejs也是非常顺手。 下载：https://code.visualstudio.com/b?utm_expid=101350005-21.ckupCbvGQMiML5eJsxWmxw.1&amp;utm_referrer=https%3A%2F%2Fwww.microsoft.com%2Fnet%2Fcore 装完后用VS Code打开hwapp文件夹，如下图所示： 安装VS Code的C#扩展 打开VS Code，按快捷键：Command+p，在弹出的输入框里输入ext install csharp，在搜索出来的下拉框里选第一个C# 安装完C#的扩展插件后让我们打开Program.cs这个文件编辑一下吧。这个时候已经有C#标准的代码着色，跟智能提示了，如下图所示： 调试程序 在调试之前能，我们需要配置luanch.json文件。 luanch.json是用来描述Debugger的配置的文件。 我们主要是需要修改program属性的设置，其实就是当前可执行文件的Path，注意在Mac下没有exe，编译后是dll，如下图所示： “${workspaceRoot}/bin/Debug/netcoreapp1.0/hwapp.dll”配置好后我们就可以开始正式调试程序了。 VSCode的左侧边栏有一只虫子样的图标，点击后切换到调试模式，VS Code中下断点跟VS里一样，在代码行的最左边点击一下，出现一个红点，表示下断点成功。 在绿色箭头旁边的下拉框选择.NET Core Launch (Console)控制台调试模式。点击绿色的箭头就可以开始调试啦，如果有断点的话代码就会停止在断点位置 使用方式跟VS基本一致，F5执行，F10单步跳过，F11单步调试，鼠标悬停在变量上可以查看值，监控变量等等。(Mac上可能会出现热键冲突)； ","link":"https://shineyangpro.com/mac-xia-shi-yong-visual-studio-code-diao-shi-ckong-zhi-tai-cheng-xu-yi-ji-xiang-guan-de-pei-zhi-2/"},{"title":"iOS中比较当前日期与指定日期大小","content":"1、首先获取当前日期NSDate形式，指定一个日期格式 #pragma mark -得到当前时间 +(NSDate *)getCurrentTime{ NSDateFormatter *formatter=[[NSDateFormatter alloc]init]; [formatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *dateTime=[formatter stringFromDate:[NSDate date]]; NSDate *date = [formatter dateFromString:dateTime]; NSLog(@&quot;---------- currentDate == %@&quot;,date); return date; } 2、然后将指定日期（此处以2016-09-30-00点为例）转换为同样日期格式，返回NSDate形式 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSDate *date = [dateFormatter dateFromString:@&quot;30-09-2016-000000&quot;]; 3、最后进行比较，将现在的时间与指定时间比较，如果没达到指定日期，返回-1，刚好是这一时间，返回0，否则返回1 +(int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay { NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;dd-MM-yyyy-HHmmss&quot;]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; NSLog(@&quot;date1 : %@, date2 : %@&quot;, oneDay, anotherDay); if (result == NSOrderedDescending) { //NSLog(@&quot;Date1 is in the future&quot;); return 1; } else if (result == NSOrderedAscending){ //NSLog(@&quot;Date1 is in the past&quot;); return -1; } //NSLog(@&quot;Both dates are the same&quot;); return 0; } 4、调用 [self compareOneDay:[self getCurrentTime] withAnotherDay:date] ","link":"https://shineyangpro.com/ios-zhong-bi-jiao-dang-qian-ri-qi-yu-zhi-ding-ri-qi-da-xiao/"},{"title":"Swift 时间转换成今天、明天、昨天","content":"func dayDifference(from interval : TimeInterval) -&gt; String { let calendar = NSCalendar.current let date = Date(timeIntervalSince1970: interval) if calendar.isDateInYesterday(date) { return &quot;Yesterday&quot; } else if calendar.isDateInToday(date) { return &quot;Today&quot; } else if calendar.isDateInTomorrow(date) { return &quot;Tomorrow&quot; } else { let startOfNow = calendar.startOfDay(for: Date()) let startOfTimeStamp = calendar.startOfDay(for: date) let components = calendar.dateComponents([.day], from: startOfNow, to: startOfTimeStamp) let day = components.day! if day &lt; 1 { return &quot;\\(abs(day)) days ago&quot; } else { return &quot;In \\(day) days&quot; } } } ","link":"https://shineyangpro.com/swift-shi-jian-zhuan-huan-cheng-jin-tian-ming-tian-zuo-tian/"},{"title":"Xcode11以后新变化：SceneDelegate","content":"Xcode11后，运行旧项目，相安无事，心里捏了一把汗，终于没有跟往年那样一更新就给你一大堆报错了。刚才突发奇想，使用Xcode11新建iOS项目时,如果你跟往常一样在Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建根控制器，会崩溃报错： Appdelegate找不到设置window的方法。 然后发现Xcode自动新增了一个SceneDelegate文件，查找了一下官方文档WWDC2019：Optimizing App Launch 发现，iOS13中appdelegate的职责发现了改变： iOS13之前，Appdelegate的职责全权处理App生命周期和UI生命周期； iOS13之后，Appdelegate的职责是： 1、处理 App 生命周期 2、新的 Scene Session 生命周期 那UI的生命周期呢？交给新增的Scene Delegate处理 用图表示就是： iOS13之前： 这种模式完全没问题，因为只有一个进程，只有一个与这个进程对应的用户界面 但是iOS13之后，Appdelegate不在负责UI生命周期，所有UI生命周期交给SceneDelegate处理： 因此初始化window方法需要改变： 现在不再Appdelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions进行初始化，转交给SceneDelegate的willConnectToSession:方法进行根控制器设置： - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions { UIWindowScene *windowScene = (UIWindowScene *)scene; self.window = [[UIWindow alloc] initWithWindowScene:windowScene]; self.window.frame = windowScene.coordinateSpace.bounds; self.window.rootViewController = [UITabBarController new]; [self.window makeKeyAndVisible]; } ","link":"https://shineyangpro.com/xcode11-yi-hou-xin-bian-hua-scenedelegate/"},{"title":"如何修改Mac自带PHP版本，php-v和phpinfo两个不同的版本","content":"find / -name php.ini 得出两个ini /usr/local/php/etc/php.ini /etc/php.ini php -i | grep php.ini 查看PHP加载的是哪个配置文件,这个获取的是系统内的php.ini 的位置。不是网页apache加载的php.ini文件 查找一下系统里的PHP目录相关的东西 find / -name php /usr/bin/php -v 再环境变量里加上要使用的PHP的路径 vim /etc/profile 在文档最后，添加: export PATH=&quot;/usr/local/php/bin:$PATH&quot; 保存，退出，然后运行： source /etc/profile 如果profile这里添加成功后不能退出，请执行这个命令： :w !sudo tee % 解释： :w – write !sudo – call shell sudo command tee – the output of write (:w) command is redirected using tee % – current file name 参考文章https://stackoverflow.com/questions/28635647/how-can-i-save-a-file-i-opened-in-vim-as-the-wrong-user ","link":"https://shineyangpro.com/ru-he-xiu-gai-mac-zi-dai-php-ban-ben-php-v-he-phpinfo-liang-ge-bu-tong-de-ban-ben/"},{"title":"Apple美区官网购买礼品兑换充值卡（iTunes Gift Card ）","content":" 第一步：购买地址 点击我购买 第二步 填写购买信息 第三步：登陆 apple ID 第四步：填写支付信息 第五步：获取礼品兑换码 可以直接点击，会直接跳转到ituens,如果没跳转，可以鼠标右键复制链接的方式来获得兑换码 复制到记事本 第六步：在手机上输入兑换码 ","link":"https://shineyangpro.com/apple-mei-qu-guan-wang-gou-mai-li-pin-dui-huan-chong-zhi-qia-itunes-gift-card/"},{"title":"Xcode11 使用终端上传ipa","content":" 升级 Xcode 11 后, Xcode 删掉了 Application loader工具，使用 Xcode自带的上传功能，太卡，经常停留在进度条不动，于是便通过终端-&gt; xcrun altool上传。 整个过程5分钟内搞定，命令不多，就两个 校验 和 上传 校验 ipa xcrun altool --validate-app -f xxxx.ipa -t ios --apiKey xxxx --apiIssuer xxxx --verbose 上传 ipa xcrun altool --upload-app -f xxxx.ipa -t ios --apiKey xxxxx --apiIssuer xxxxx--verbose 上面一个命令，区别只在于， 校验是 validate-app , 上传是 upload-appxxxx.ipa 是 ipa文件的绝对路径 (以防万一，最好写绝对)apiKey xxxx 此处的 xxxx为 apiKey的值，获取方法见下面apiIssuer xxxx 此处的 xxxx为 apiIssuer的值，获取方法见下面 获取方式 1、进入开发者后台 -&gt; 用户和访问 2、apiKey 即密钥ID 3、 apiIssuer 即 Issuer ID 上传成功 要把开发者中心的密钥文件下载到电脑上，最好是放到用户的目录下面/用户/xxx ","link":"https://shineyangpro.com/xcode11-shi-yong-zhong-duan-shang-chuan-ipa/"},{"title":"Swift 把 1234656转化成 1.23万 或1.23亿 或 1 万 ，1亿","content":"extension Float { /** 战斗力值转换 */ var combatValues: String { if (self / 10000) &gt; 1 { let temp = self / 10000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;万&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;万&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;万&quot; } return str + &quot;万&quot; } } if (self / 100000000) &gt; 1 { let temp = self / 100000000 if fmodf(Float(temp), 1) == 0 { let str = String.init(format: &quot;%.0f&quot;, temp) return str + &quot;亿&quot; }else if fmodf(Float(temp) * 10, 1) == 0 { let str = String.init(format: &quot;%.1f&quot;, temp) return str + &quot;亿&quot; }else{ let str = String.init(format: &quot;%.2f&quot;, temp) let decimal = str.componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;00&quot; { return decimal[0] + &quot;亿&quot; } return str + &quot;亿&quot; } } let decimal = String.init(self).componentsSeparatedByString(&quot;.&quot;) let arrayString = decimal[1] if arrayString == &quot;0&quot; { return decimal[0] } return String.init(self) } } 字符串扩展 extension String { func attributedString(font:CGFloat)-&gt;NSMutableAttributedString{ let attributedS = NSMutableAttributedString(string: self) if self.containsString(&quot;万&quot;) || self.containsString(&quot;亿&quot;) { let normalAttributes = [NSFontAttributeName:UIFont.systemFontOfSize(font)] attributedS.addAttributes(normalAttributes, range: NSMakeRange(self.characters.count - 1,1)) } return attributedS } } 调用：label.attributedText = Float(number).combatValues ","link":"https://shineyangpro.com/swift-ba-1234656-zhuan-hua-cheng-123-wan-huo-123-yi-huo-1-wan-1-yi/"},{"title":"macOS Catalina (macOS 10.15) 已损坏无法打开解决办法","content":"最近有很多小伙伴更新系统后，提示“已损坏无法打开”的情况，按照以往的方法，在系统的“安全与隐私”中已经允许了“任何来源”，但还是一样打不开，怎么办呢？ App 在 macOS Catalina下提示已损坏无法打开解决办法： 1、在系统的“安全与隐私”中允许“任何来源”，再打开终端。 2、输入以下命令: sudo xattr -d com.apple.quarantine /Applications/xxxx.app 注意：Applications/xxxx.app 换成你的App路径或在sudo xattr -d com.apple.quarantine 后将软件拖进去即可。 3、最后，重启App即可。 ","link":"https://shineyangpro.com/macos-catalina-macos-1015-yi-sun-pi-wu-fa-da-kai-jie-jue-ban-fa/"},{"title":"Mac下配置Go开发环境","content":"Go（又称 Golang）是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go 的语法接近 C 语言，可以进行网络编程、系统编程、并发编程、分布式编程。 下面演示如何在 Mac 电脑上搭建 Go 语言开发环境。 1，安装 Golang 的 SDK 在官网下载对应的开发工具GoLand,地址如下:https://golang.org/dl/ 2，配置环境变量 （1）在终端执行如下命令进入用户主目录： cd ~ （2）执行如下命令打开 .bash_profile 文件： vim .bash_profile （3）按下 i 进入编辑模式，在文件末尾添加如下内容（GOPATH地址是自己创建项目的地址，比如我的是在桌面的文件夹下创建的）： export GOPATH=/Users/yangchen/Desktop/ReactNatve/Go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN （4）按下 ESC 键，然后输入 :wq 保存并退出编辑。 （5）接着执行如下命令让配置生效。 source ~/.bash_profile 最后我们执行 go env 查看配置结果，可以看到 GO 的环境变量已成功配置了。 ","link":"https://shineyangpro.com/mac-xia-pei-zhi-go-kai-fa-huan-jing/"},{"title":"Swift  从子视图跳转到指定tabBar主界面","content":"从tabbar的子页面跳转到指定的tabbar主页面,话不多说直接上代码: self.navigationController?.tabBarController?.selectedIndex = 0 self.navigationController?.popViewController(animated: false) ","link":"https://shineyangpro.com/swift-cong-zi-shi-tu-tiao-zhuan-dao-zhi-ding-tabbar-zhu-jie-mian/"},{"title":"Swift UICollectionView横向分页滚动，cell左右排版","content":"废话不多说，直接上代码 自定义一个SYitemViewLayout，继承UICollectionViewFlowLayout mport UIKit //根据需求设置列跟行 let kEmotionCellNumberOfOneRow = 3 let kEmotionCellRow = 2 class SYitemViewLayout: UICollectionViewFlowLayout { // 保存所有item fileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] // MARK:- 重新布局 override func prepare() { super.prepare() let itemWH: CGFloat = (kScreenWitdh - 30) / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH - 50) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true // let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 // collectionView?.contentInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10) var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount { let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * (kScreenWitdh - 30)) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) } } override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? { var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map({ if rect.contains($0.frame) { rectAttributes.append($0) } }) return rectAttributes } } ","link":"https://shineyangpro.com/swift-uicollectionview-heng-xiang-fen-ye-gun-dong-cell-zuo-you-pai-ban/"},{"title":"Swift框架-章：1、开发一个Swift框架","content":"Swift已成为一种流行的编程语言，并且每天都在发展。 开发Swift框架具有以下优点。 隐藏您的代码实现。 由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 开发Swift框架具有以下优点。 1、隐藏您的代码实现。 2、由于.framework文件已经编译，因此将减少重新编译并节省开发时间。 这就是苹果公司使用的，例如：UIKit.framework。 那么，您在寻找什么？让我们现在开始开发自己的Swift框架。 使用的工具：XCode 11.6 +，Swift 5.1+ 步骤1：-安装框架项目 1、创建新的XCode项目。 2、 创建框架 为您的项目命名，我们使用了类似于Alamofire的AlamoWater名字。 （请确保选择语言-Swift） 单击目标内的AlamoWater文件夹，然后按⌘+N。 选择文件名AlamoWater和以下子类：NSObject 在AlameWater.swift中添加以下代码**。** **注意：-**确保您的类和方法设置为Public import UIKit public protocol AlamoWaterProtocol { func didCallHello() } open class AlamoWater: NSObject { public static let shared = AlamoWater() public var delegate:AlamoWaterProtocol? open func hello(){ debugPrint(&quot;Hello from AlamoWater!&quot;) AlamoWater.shared.delegate?.didCallHello() } } 要为iOS设备和模拟器创建框架，请向您的项目添加新的Aggregate目标。 并添加[运行脚本] #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # make sure the output directory exists mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # Step 1. Build Device and Simulator versions xcodebuild -target &quot;AlamoWater&quot; ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build xcodebuild -target &quot;AlamoWater&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build # Step 2. Copy the framework structure (from iphoneos build) to the universal folder cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/&quot; # Step 3. Copy Swift modules from iphonesimulator build (if it exists) to the copied framework directory SIMULATOR_SWIFT_MODULES_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/Modules/AlamoWater.swiftmodule/.&quot; if [ -d &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; ]; then cp -R &quot;${SIMULATOR_SWIFT_MODULES_DIR}&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/Modules/AlamoWater.swiftmodule&quot; fi # Step 4. Create universal binary file using lipo and place the combined executable in the copied framework directory lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/AlamoWater.framework/AlamoWater&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/AlamoWater.framework/AlamoWater&quot; # Step 5. Convenience step to copy the framework to the project's directory cp -R &quot;${UNIVERSAL_OUTPUTFOLDER}/AlamoWater.framework&quot; &quot;${PROJECT_DIR}&quot; # Step 6. Convenience step to open the project's directory in Finder open &quot;${PROJECT_DIR}&quot; 注意：AlamoWater改为自己项目的名字 通过按⌘+ B选择UniversalAlamoWater目标来构建您的第一个框架 构建完成后，您将看到Finder与其中的Framework一起打开。 注意：-如果出现以下错误， … Reason: image not found 确保在嵌入式二进制文件和链接的框架和库中都添加了框架 ","link":"https://shineyangpro.com/swift-kuang-jia-zhang-1kai-fa-yi-ge-swift-kuang-jia/"},{"title":"Go实战项目【一】Golang和Gin框架的安装和使用","content":"Golang的安装 根据所使用的电脑操作系统，下载相对应的版本Golang 下载 比如我的电脑是macOS系统，下载的是 安装完毕后配置路径 打开终端，执行: vi ~/.bash_profile .bash_profile 添加的内容如下： #Go export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 然后执行 source ~/.bash_profile 让配置生效 执行 go version 查看Golang是否安装成功，出现以下信息即为安装成功 初始化项目目录 选一个你自己喜欢的路径，创建一个文件夹，比如我的是/Users/newmac/Documents/Go-app这个文件夹下 cd /Users/newmac/Documents/Go-app mkdir api &amp;&amp; cd api go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go mod init api mkdir api &amp;&amp; cd api：创建并进入api文件夹 go env -w GO111MODULE=on：开启Go modules go env -w GOPROXY=https://goproxy.cn,direct：设置 GOPROXY 代理，也可以把GOPROXY写入.bash_profile中 go mod init [MODULE_PATH]：初始化 Go modules，它将会生成 go.mod 文件，MODULE_PATH 填写的是模块引入路径，如果想要把项目放到Github上，可以填写GitHub的项目路径，这个根据自己情况填写。 然后就会在api文件夹下出现go.mod文件 安装Gin框架 在api文件夹下，执行 go get -u github.com/gin-gonic/gin 安装完毕后，创建一个test.go文件，测试下Gin框架是否能使用test.go 我用的是GoLang开发工具，可以直接在编译器里面执行 如果用的是VS code，可以在终端运行:go run test.go 在浏览器打开127.0.0.1:8080/ping这个地址，可以看到有返回的数据，代表Gin框架安装和使用成功。 Go相关学习知识 ","link":"https://shineyangpro.com/go-shi-zhan-xiang-mu-yi-golang-he-gin-kuang-jia-de-an-zhuang-he-shi-yong/"},{"title":"清理Xcode占用的Mac硬盘空间","content":"主要是操作两个目录下的文件 ~/Library/Developer/Xcode 和 ~/Library/Developer/CoreSimulator ~/Library/Developer/Xcode 1、DerivedData 此文件夹内的每个目录是Xcode运行每个APP时生成的缓存文件，删除之后再运行APP会重新生成该APP对应的文件，只是编译时间变长了。 可保留近期运行的APP相关的文件夹，对于以前运行过近期不再使用的APP，例如网上下载的demo，建议清理。 Archives 此文件夹中的内容对应Xcode-&gt;Window-&gt;Organizer-&gt;Archives中列出的打包文件。 可保留有用的打包文件，其它删除。 iOS DeviceSupport 此文件夹存放的是Xcode对你所连接真机的版本支持，每个文件夹几乎都是几个G的大小（我个人的情况是11个目录占了26G空间），手机每升级一个版本，再次连接Xcode时，这里都会生成一个目录。 建议保留你手机当前版本的文件夹。全部删除也没关系，手机再次连接Xcode时会重新生成。 2. ~/Library/Developer/CoreSimulator Devices 此文件夹下的目录是以模拟器的UDID命名的，运行模拟器时每安装一个新的APP，相应的文件夹内容也会增大，就像手机上安装应用会占用手机空间一样。 可删除全部文件夹。再次运行模拟器，会重新生成。 删除后开启Xcode运行模拟器，可能会出现下面的错误，不要惊慌，重启Xcode就好了。 建议在退出Xcode后进行清理，清理后重启电脑 ","link":"https://shineyangpro.com/qing-li-xcode-zhan-yong-de-mac-ying-pan-kong-jian/"},{"title":"iOS 13：Swift以编程方式设置应用程序根视图控制器不起作用","content":"在iOS以后直接使用window?.makeKeyAndVisible()是不起作用的，正确用法是: static func redirectToMainNavRVC(currentVC: UIViewController){ let appDelegate = UIApplication.shared.delegate as! AppDelegate let vc = UIStoryboard(name: appDelegate.storyBoardName, bundle: nil).instantiateViewController(withIdentifier: &quot;MainNavigationViewController&quot;) as! MainNavigationViewController if #available(iOS 13.0, *){ if let scene = UIApplication.shared.connectedScenes.first{ guard let windowScene = (scene as? UIWindowScene) else { return } print(&quot;&gt;&gt;&gt; windowScene: \\(windowScene)&quot;) let window: UIWindow = UIWindow(frame: windowScene.coordinateSpace.bounds) window.windowScene = windowScene //Make sure to do this window.rootViewController = vc window.makeKeyAndVisible() appDelegate.window = window } } else { appDelegate.window?.rootViewController = vc appDelegate.window?.makeKeyAndVisible() } } ","link":"https://shineyangpro.com/ios-13swift-yi-bian-cheng-fang-shi-she-zhi-ying-yong-cheng-xu-gen-shi-tu-kong-zhi-qi-bu-qi-zuo-yong/"}]}